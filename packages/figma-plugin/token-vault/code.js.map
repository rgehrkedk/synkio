{
  "version": 3,
  "sources": ["src/backend/import/collection.ts", "src/backend/utils/type-mappers.ts", "src/backend/utils/parsers.ts", "src/backend/import/variable.ts", "src/backend/import/alias-resolver.ts", "src/backend/type-inference/patterns.ts", "src/backend/type-inference/rules.ts", "src/backend/import/index.ts", "src/backend/export/transformer.ts", "src/backend/export/baseline.ts", "src/backend/export/index.ts", "src/backend/utils/constants.ts", "src/backend/sync/chunker.ts", "src/backend/sync/node-manager.ts", "src/backend/sync/metadata.ts", "src/backend/sync/index.ts", "src/backend/handlers/message-router.ts", "src/code.ts"],
  "sourcesContent": ["/**\n * Collection management for token import\n */\n\nimport type { CollectionConfig } from '../../types/index.js';\n\n/**\n * Find existing collection by name or create a new one\n */\nexport async function findOrCreateCollection(name: string): Promise<VariableCollection> {\n  const collections = await figma.variables.getLocalVariableCollectionsAsync();\n  let collection = collections.find(c => c.name === name);\n\n  if (!collection) {\n    collection = figma.variables.createVariableCollection(name);\n  }\n\n  return collection;\n}\n\n/**\n * Setup modes for a collection based on configuration\n * @param collection - The variable collection\n * @param config - Collection configuration\n * @returns Map of file names to mode IDs\n */\nexport function setupModes(\n  collection: VariableCollection,\n  config: CollectionConfig\n): Map<string, string> {\n  const fileModeMap = new Map<string, string>();\n\n  if (config.isModeCollection) {\n    // Each file is a separate mode\n    const defaultMode = collection.modes[0];\n\n    for (let i = 0; i < config.files.length; i++) {\n      const file = config.files[i];\n      let modeId: string;\n\n      if (i === 0) {\n        // Rename default mode to first file name\n        modeId = defaultMode.modeId;\n        collection.renameMode(modeId, file.name);\n      } else {\n        // Add new mode for each additional file\n        modeId = collection.addMode(file.name);\n      }\n\n      fileModeMap.set(file.name, modeId);\n    }\n  } else {\n    // Single mode, all files merged\n    const defaultMode = collection.modes[0];\n    // Map all files to the default mode\n    for (const file of config.files) {\n      fileModeMap.set(file.name, defaultMode.modeId);\n    }\n  }\n\n  return fileModeMap;\n}\n\n/**\n * Merge token files into a single token object\n */\nexport function mergeTokenFiles(files: Array<{ name: string; content: any }>): any {\n  const merged = {};\n  for (const file of files) {\n    Object.assign(merged, file.content);\n  }\n  return merged;\n}\n", "/**\n * Type conversion utilities between token types and Figma types\n */\n\nimport type { TokenType } from '../../types/index.js';\n\n/**\n * Map token type to Figma variable type\n */\nexport function mapTokenTypeToFigmaType(tokenType: string): VariableResolvedDataType {\n  const typeMap: Record<string, VariableResolvedDataType> = {\n    'color': 'COLOR',\n    'dimension': 'FLOAT',\n    'spacing': 'FLOAT',\n    'fontFamily': 'STRING',\n    'fontWeight': 'STRING',\n    'fontSize': 'FLOAT',\n    'duration': 'STRING',\n    'string': 'STRING',\n    'number': 'FLOAT',\n    'boolean': 'BOOLEAN',\n    'shadow': 'STRING',\n    'gradient': 'STRING'\n  };\n\n  return typeMap[tokenType] || 'STRING';\n}\n\n/**\n * Map Figma variable type to token type\n */\nexport function mapFigmaTypeToTokenType(figmaType: VariableResolvedDataType): TokenType {\n  const typeMap: Record<VariableResolvedDataType, TokenType> = {\n    'COLOR': 'color',\n    'FLOAT': 'number',\n    'STRING': 'string',\n    'BOOLEAN': 'boolean'\n  };\n  return typeMap[figmaType] || 'string';\n}\n\n/**\n * Get default value for a given Figma type\n */\nexport function getDefaultValueForType(type: VariableResolvedDataType): any {\n  switch (type) {\n    case 'COLOR':\n      return { r: 0, g: 0, b: 0 }; // Black\n    case 'FLOAT':\n      return 0;\n    case 'STRING':\n      return '';\n    case 'BOOLEAN':\n      return false;\n    default:\n      return null;\n  }\n}\n", "/**\n * Value parsing utilities for different token types\n */\n\n/**\n * Parse hex color string to RGB object\n * Supports #RRGGBB format\n */\nexport function parseColor(value: string): RGB | null {\n  if (!value || typeof value !== 'string') return null;\n\n  // Handle hex colors\n  if (value.startsWith('#')) {\n    const hex = value.replace('#', '');\n\n    if (hex.length === 6) {\n      const r = parseInt(hex.substring(0, 2), 16) / 255;\n      const g = parseInt(hex.substring(2, 4), 16) / 255;\n      const b = parseInt(hex.substring(4, 6), 16) / 255;\n      return { r, g, b };\n    }\n  }\n\n  // Handle rgba\n  if (value.startsWith('rgba')) {\n    const match = value.match(/rgba\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)/);\n    if (match) {\n      return {\n        r: parseInt(match[1]) / 255,\n        g: parseInt(match[2]) / 255,\n        b: parseInt(match[3]) / 255\n      };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Parse number value, stripping units\n * Supports numeric values and strings with units (px, rem, em, etc.)\n */\nexport function parseNumber(value: any): number | null {\n  if (typeof value === 'number') return value;\n  if (typeof value === 'string') {\n    // Remove units (px, rem, em, etc.)\n    const num = parseFloat(value.replace(/[a-z%]+$/i, ''));\n    return isNaN(num) ? null : num;\n  }\n  return null;\n}\n\n/**\n * Parse font weight value\n * Maps numeric weights to names\n */\nexport function parseFontWeight(value: any): string {\n  const weightMap: Record<number, string> = {\n    100: 'Thin',\n    200: 'Extra Light',\n    300: 'Light',\n    400: 'Regular',\n    500: 'Medium',\n    600: 'Semi Bold',\n    700: 'Bold',\n    800: 'Extra Bold',\n    900: 'Black'\n  };\n\n  if (typeof value === 'number') {\n    return weightMap[value] || value.toString();\n  }\n\n  return value.toString();\n}\n\n/**\n * Convert RGB to hex color string\n */\nexport function rgbToHex(color: RGB | RGBA): string {\n  const toHex = (value: number) => {\n    const hex = Math.round(value * 255).toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n  };\n  return `#${toHex(color.r)}${toHex(color.g)}${toHex(color.b)}`;\n}\n", "/**\n * Variable management for token import\n * Creates and updates Figma variables with token values\n */\n\nimport type { NormalizedToken } from '../../types/index.js';\nimport { mapTokenTypeToFigmaType, getDefaultValueForType } from '../utils/type-mappers.js';\nimport { parseColor, parseNumber, parseFontWeight } from '../utils/parsers.js';\n\n/**\n * Callback to register alias references during variable creation\n */\nexport type AliasCallback = (variable: Variable, modeId: string, aliasPath: string) => void;\n\n/**\n * Create or update a Figma variable for a token\n * @param collection - The variable collection\n * @param modeId - The mode ID to set the value for\n * @param path - The token path (becomes variable name)\n * @param token - The normalized token data\n * @param onAlias - Optional callback for alias references\n */\nexport async function createOrUpdateVariable(\n  collection: VariableCollection,\n  modeId: string,\n  path: string,\n  token: NormalizedToken,\n  onAlias?: AliasCallback\n): Promise<Variable> {\n  const variableName = path;\n\n  // Find existing variable or create new\n  const variables = await figma.variables.getLocalVariablesAsync();\n  let variable = variables.find(\n    v => v.name === variableName && v.variableCollectionId === collection.id\n  );\n\n  if (!variable) {\n    const resolvedType = mapTokenTypeToFigmaType(token.type);\n    variable = figma.variables.createVariable(variableName, collection, resolvedType);\n  }\n\n  // Set description if provided\n  if (token.description) {\n    variable.description = token.description;\n  }\n\n  // Parse and set value\n  const resolvedValue = parseTokenValue(token.value, token.type, variable, modeId, onAlias);\n\n  if (resolvedValue !== null) {\n    try {\n      variable.setValueForMode(modeId, resolvedValue);\n    } catch (error) {\n      console.error(`Failed to set value for ${path}:`, error instanceof Error ? error.message : String(error));\n      console.error(`Type: ${token.type}, Value: ${token.value}, Resolved: ${JSON.stringify(resolvedValue)}`);\n\n      // Set a default value based on type\n      const defaultValue = getDefaultValueForType(variable.resolvedType);\n      if (defaultValue !== null) {\n        variable.setValueForMode(modeId, defaultValue);\n      }\n    }\n  } else {\n    // For aliases, set a temporary default value\n    const defaultValue = getDefaultValueForType(variable.resolvedType);\n    if (defaultValue !== null) {\n      variable.setValueForMode(modeId, defaultValue);\n    }\n  }\n\n  return variable;\n}\n\n/**\n * Parse token value based on type\n * Detects alias references and delegates to type-specific parsers\n * @returns Parsed value or null if alias reference\n */\nfunction parseTokenValue(\n  value: any,\n  type: string,\n  variable?: Variable,\n  modeId?: string,\n  onAlias?: AliasCallback\n): any {\n  // Check if value contains alias references\n  if (typeof value === 'string' && value.includes('{')) {\n    // Check if it's a single alias: \"{path.to.token}\"\n    if (value.startsWith('{') && value.endsWith('}') && value.indexOf('}') === value.length - 1) {\n      // Single alias - store for resolution\n      if (variable && modeId && onAlias) {\n        onAlias(variable, modeId, value);\n      }\n      return null;\n    } else {\n      // Multiple aliases or mixed content (e.g., \"{space.1} {space.3}\")\n      // Figma doesn't support multi-alias, so keep as string\n      return String(value);\n    }\n  }\n\n  // Parse based on type\n  switch (type) {\n    case 'color':\n      return parseColor(value);\n\n    case 'dimension':\n    case 'spacing':\n    case 'fontSize':\n    case 'number':\n      return parseNumber(value);\n\n    case 'fontWeight':\n      return parseFontWeight(value);\n\n    case 'fontFamily':\n    case 'string':\n    case 'shadow':\n    case 'gradient':\n    case 'duration':\n      return String(value);\n\n    case 'boolean':\n      return Boolean(value);\n\n    default:\n      // Return string for unknown types\n      return String(value);\n  }\n}\n\n/**\n * Check if an object is a token value (leaf node)\n * Supports W3C format ($value/$type) and legacy format (value/type)\n */\nexport function isTokenValue(obj: any): boolean {\n  return obj && typeof obj === 'object' &&\n    (('$value' in obj) || ('value' in obj && !hasNestedTokens(obj)));\n}\n\n/**\n * Check if object has nested token objects\n */\nfunction hasNestedTokens(obj: any): boolean {\n  for (const key of Object.keys(obj)) {\n    if (key === 'value' || key === 'type' || key === 'description' ||\n        key === '$value' || key === '$type' || key === '$description') {\n      continue;\n    }\n    // If there's any other key, this might be a container\n    const nested = obj[key];\n    if (nested && typeof nested === 'object') {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Normalize token to internal format\n * Converts W3C format ($value/$type) to internal format\n * @param obj - Raw token object\n * @param path - Token path for type inference\n * @param inferType - Function to infer type from path if not specified\n */\nexport function normalizeToken(\n  obj: any,\n  path: string,\n  inferType: (path: string) => string\n): NormalizedToken {\n  const explicitType = obj.$type ?? obj.type;\n  const inferredType = explicitType || inferType(path);\n\n  return {\n    value: obj.$value ?? obj.value,\n    type: inferredType as any,\n    description: obj.$description ?? obj.description\n  };\n}\n", "/**\n * Alias resolution system for token imports\n * Manages two-pass import: create variables first, then resolve alias references\n */\n\n/**\n * Alias reference to resolve in pass 2\n */\nexport interface AliasReference {\n  variable: Variable;\n  modeId: string;\n  aliasPath: string; // Format: \"{path.to.token}\"\n}\n\n/**\n * Alias resolver manages alias references and resolves them after all variables are created\n */\nexport class AliasResolver {\n  private references: AliasReference[] = [];\n\n  /**\n   * Register an alias reference for later resolution\n   */\n  registerAlias(variable: Variable, modeId: string, aliasPath: string): void {\n    this.references.push({\n      variable,\n      modeId,\n      aliasPath\n    });\n  }\n\n  /**\n   * Resolve all registered aliases\n   * @returns Summary of resolution results\n   */\n  async resolveAll(): Promise<{ resolved: number; failed: number; warnings: string[] }> {\n    const warnings: string[] = [];\n    let resolved = 0;\n    let failed = 0;\n\n    // Build variable lookup map\n    const allVariables = await figma.variables.getLocalVariablesAsync();\n    const variableMap = new Map<string, Variable>();\n    for (const variable of allVariables) {\n      variableMap.set(variable.name, variable);\n    }\n\n    // Resolve each alias\n    for (const ref of this.references) {\n      // Parse alias path: \"{path.to.token}\" -> \"path/to/token\"\n      const aliasPath = ref.aliasPath\n        .replace(/^{/, '')\n        .replace(/}$/, '')\n        .replace(/\\./g, '/');\n\n      const targetVariable = variableMap.get(aliasPath);\n\n      if (targetVariable) {\n        try {\n          // Create alias reference\n          ref.variable.setValueForMode(ref.modeId, {\n            type: 'VARIABLE_ALIAS',\n            id: targetVariable.id\n          });\n          resolved++;\n        } catch (error) {\n          const message = `Failed to create alias ${ref.variable.name} -> ${aliasPath}: ${error instanceof Error ? error.message : String(error)}`;\n          console.error(message);\n          warnings.push(message);\n          failed++;\n        }\n      } else {\n        const message = `Alias target not found: ${aliasPath} (referenced by ${ref.variable.name})`;\n        console.warn(message);\n        warnings.push(message);\n        failed++;\n      }\n    }\n\n    return { resolved, failed, warnings };\n  }\n\n  /**\n   * Clear all stored alias references\n   */\n  clear(): void {\n    this.references.length = 0;\n  }\n\n  /**\n   * Get count of pending alias references\n   */\n  getPendingCount(): number {\n    return this.references.length;\n  }\n}\n", "/**\n * Type inference patterns for token path analysis\n */\n\nimport type { TokenType } from '../../types/index.js';\n\n/**\n * Pattern definition for type inference\n */\nexport interface TypePattern {\n  /** Keywords to match (case-insensitive) */\n  keywords: string[];\n  /** Base token type this pattern infers */\n  type: TokenType;\n  /** Priority (higher = checked first) */\n  priority: number;\n  /** Optional refinement function */\n  refine?: (path: string) => TokenType;\n}\n\n/**\n * Type inference patterns ordered by priority\n */\nexport const TYPE_PATTERNS: TypePattern[] = [\n  // Font-related patterns (need refinement based on context)\n  {\n    keywords: ['font', 'typography'],\n    type: 'string',\n    priority: 100,\n    refine: (path: string) => {\n      const lower = path.toLowerCase();\n      if (lower.includes('size')) return 'dimension';\n      if (lower.includes('weight')) return 'fontWeight';\n      if (lower.includes('family')) return 'fontFamily';\n      if (lower.includes('lineheight') || lower.includes('line-height')) return 'number';\n      return 'string';\n    }\n  },\n\n  // Color patterns\n  {\n    keywords: ['color', 'colors', 'colours'],\n    type: 'color',\n    priority: 90\n  },\n\n  // Dimension patterns\n  {\n    keywords: ['spacing', 'space', 'size', 'radius', 'borderradius', 'border-radius'],\n    type: 'dimension',\n    priority: 85\n  },\n\n  // Shadow patterns\n  {\n    keywords: ['shadow', 'boxshadow'],\n    type: 'shadow',\n    priority: 80\n  },\n\n  // Number patterns\n  {\n    keywords: ['opacity', 'zindex', 'z-index'],\n    type: 'number',\n    priority: 75\n  },\n\n  // Semantic patterns\n  {\n    keywords: ['brand', 'semantic', 'component', 'background', 'foreground', 'border', 'fill', 'stroke'],\n    type: 'color',\n    priority: 70\n  },\n\n  // Layout patterns\n  {\n    keywords: ['gap', 'padding', 'margin'],\n    type: 'dimension',\n    priority: 65\n  },\n\n  // Animation patterns\n  {\n    keywords: ['transition', 'animation', 'breakpoint'],\n    type: 'string',\n    priority: 60\n  }\n];\n", "/**\n * Type inference rule engine\n */\n\nimport type { TokenType } from '../../types/index.js';\nimport { TYPE_PATTERNS } from './patterns.js';\n\n/**\n * Infer token type from path using pattern matching\n * @param path - Token path (e.g., 'colors/primary', 'spacing/small')\n * @returns Inferred token type\n */\nexport function inferTypeFromPath(path: string): TokenType {\n  const lowerPath = path.toLowerCase();\n  const segments = lowerPath.split('/');\n  const firstSegment = segments[0];\n\n  // Try patterns in priority order\n  for (const pattern of TYPE_PATTERNS) {\n    // Check if any keyword matches the first segment\n    if (pattern.keywords.includes(firstSegment)) {\n      // Apply refinement if available\n      if (pattern.refine) {\n        return pattern.refine(lowerPath);\n      }\n      return pattern.type;\n    }\n\n    // Check if any keyword appears anywhere in path\n    for (const keyword of pattern.keywords) {\n      if (lowerPath.includes(keyword)) {\n        // Apply refinement if available\n        if (pattern.refine) {\n          return pattern.refine(lowerPath);\n        }\n        return pattern.type;\n      }\n    }\n  }\n\n  // Default to string for unknown types\n  return 'string';\n}\n\n/**\n * Infer type from value structure\n * @param value - Token value\n * @returns Inferred token type or null if cannot determine\n */\nexport function inferTypeFromValue(value: unknown): TokenType | null {\n  if (typeof value === 'string') {\n    // Check for color patterns\n    if (value.startsWith('#') || value.startsWith('rgb')) {\n      return 'color';\n    }\n    // Check for number with units\n    if (/^\\d+(\\.\\d+)?(px|rem|em|%)$/.test(value)) {\n      return 'dimension';\n    }\n  }\n\n  if (typeof value === 'number') {\n    return 'number';\n  }\n\n  if (typeof value === 'boolean') {\n    return 'boolean';\n  }\n\n  return null;\n}\n", "/**\n * Import orchestrator\n * Coordinates the two-pass import process:\n * - Pass 1: Create all variables and collections\n * - Pass 2: Resolve all alias references\n *\n * @module backend/import\n */\n\nimport type { CollectionConfig } from '../../types/index.js';\nimport { findOrCreateCollection, setupModes, mergeTokenFiles } from './collection.js';\nimport { createOrUpdateVariable, isTokenValue, normalizeToken } from './variable.js';\nimport { AliasResolver } from './alias-resolver.js';\nimport { inferTypeFromPath } from '../type-inference/index.js';\n\n/**\n * Import tokens from collection configurations into Figma.\n *\n * Performs a two-pass import process:\n * - **Pass 1**: Creates all variable collections, modes, and variables with initial values\n * - **Pass 2**: Resolves all alias references between variables\n *\n * This two-pass approach is necessary because aliases may reference variables that\n * haven't been created yet during sequential processing.\n *\n * @param collectionConfigs - Array of collection configurations containing token data\n * @returns Promise that resolves when import is complete\n *\n * @throws {Error} If collection creation fails\n * @throws {Error} If variable creation fails\n *\n * @example\n * ```ts\n * const configs: CollectionConfig[] = [\n *   {\n *     name: 'Design Tokens',\n *     isModeCollection: true,\n *     files: [\n *       { name: 'light', content: { colors: { primary: '#0000ff' } }, size: 100 },\n *       { name: 'dark', content: { colors: { primary: '#ffffff' } }, size: 100 }\n *     ]\n *   }\n * ];\n *\n * await importTokens(configs);\n * // Creates collection with two modes: 'light' and 'dark'\n * // Each mode has its own color values\n * ```\n */\nexport async function importTokens(collectionConfigs: CollectionConfig[]): Promise<void> {\n  figma.notify('Starting token import...');\n\n  // Create alias resolver for this import session\n  const aliasResolver = new AliasResolver();\n\n  // Pass 1: Create all variables and collections\n  for (const config of collectionConfigs) {\n    await importCollection(config, aliasResolver);\n  }\n\n  // Pass 2: Resolve aliases\n  figma.notify('Resolving aliases...');\n  const result = await aliasResolver.resolveAll();\n\n  if (result.resolved > 0) {\n    console.log(`Resolved ${result.resolved} alias references`);\n  }\n\n  if (result.failed > 0) {\n    console.warn(`Failed to resolve ${result.failed} aliases`);\n    // Show first few warnings in notification\n    if (result.warnings.length > 0) {\n      figma.notify(`Warning: ${result.failed} aliases could not be resolved`, { timeout: 5000 });\n    }\n  }\n\n  // Clear resolver\n  aliasResolver.clear();\n\n  figma.notify('\u2713 Import complete!');\n}\n\n/**\n * Import a single collection configuration.\n *\n * Handles both mode-based collections (one file per mode) and single-mode\n * collections (multiple files merged into one mode).\n *\n * @param config - Collection configuration\n * @param aliasResolver - Alias resolver instance to register aliases during import\n * @returns Promise that resolves when collection import is complete\n *\n * @internal\n */\nasync function importCollection(\n  config: CollectionConfig,\n  aliasResolver: AliasResolver\n): Promise<void> {\n  // Find or create collection\n  const collection = await findOrCreateCollection(config.name);\n\n  // Setup modes\n  const fileModeMap = setupModes(collection, config);\n\n  if (config.isModeCollection) {\n    // Each file is a separate mode\n    for (const file of config.files) {\n      const modeId = fileModeMap.get(file.name);\n      if (modeId) {\n        await importTokensForMode(collection, modeId, file.content, aliasResolver);\n      }\n    }\n  } else {\n    // Single mode, merge all files\n    const mergedTokens = mergeTokenFiles(config.files);\n    const defaultMode = collection.modes[0];\n    await importTokensForMode(collection, defaultMode.modeId, mergedTokens, aliasResolver);\n  }\n}\n\n/**\n * Import tokens for a specific mode.\n *\n * Recursively processes nested token structures, creating variables for each\n * leaf token found. Supports both W3C format ($value, $type) and legacy format\n * (value, type).\n *\n * @param collection - Variable collection to import into\n * @param modeId - Mode ID to set values for\n * @param tokens - Token structure (nested objects)\n * @param aliasResolver - Alias resolver to register aliases\n * @param prefix - Current path prefix for nested tokens\n * @returns Promise that resolves when all tokens are imported\n *\n * @internal\n */\nasync function importTokensForMode(\n  collection: VariableCollection,\n  modeId: string,\n  tokens: any,\n  aliasResolver: AliasResolver,\n  prefix: string = ''\n): Promise<void> {\n  for (const [key, value] of Object.entries(tokens)) {\n    // Skip internal properties (both W3C and legacy formats)\n    if (key === 'value' || key === 'type' || key === 'description' ||\n        key === '$value' || key === '$type' || key === '$description') {\n      continue;\n    }\n\n    const path = prefix ? `${prefix}/${key}` : key;\n\n    if (isTokenValue(value)) {\n      // This is a leaf token - normalize and create variable\n      const normalizedToken = normalizeToken(value, path, inferTypeFromPath);\n\n      await createOrUpdateVariable(\n        collection,\n        modeId,\n        path,\n        normalizedToken,\n        (variable, modeId, aliasPath) => {\n          aliasResolver.registerAlias(variable, modeId, aliasPath);\n        }\n      );\n    } else if (typeof value === 'object' && value !== null) {\n      // Recurse into nested object\n      await importTokensForMode(collection, modeId, value, aliasResolver, path);\n    }\n  }\n}\n", "/**\n * Export transformer module\n * Handles value transformation from Figma format to token format\n */\n\nimport { rgbToHex } from '../utils/parsers.js';\n\n/**\n * Resolve a variable's value for a specific mode\n * Handles VARIABLE_ALIAS references and color transformations\n *\n * @param variable - Figma variable to resolve\n * @param modeId - Mode ID to get value for\n * @returns Resolved value (alias string, hex color, or raw value)\n */\nexport async function resolveVariableValue(variable: Variable, modeId: string): Promise<any> {\n  const value = variable.valuesByMode[modeId];\n\n  // Check if it's an alias reference\n  if (typeof value === 'object' && value !== null && 'type' in value && value.type === 'VARIABLE_ALIAS') {\n    const aliasedVariable = await figma.variables.getVariableByIdAsync(value.id);\n    if (aliasedVariable) {\n      // Return alias in {path.to.token} format\n      return '{' + aliasedVariable.name.replace(/\\//g, '.') + '}';\n    }\n  }\n\n  // Handle color values - convert RGB to hex\n  if (variable.resolvedType === 'COLOR' && typeof value === 'object' && value !== null && 'r' in value) {\n    return rgbToHex(value as RGB | RGBA);\n  }\n\n  // Return raw value for other types\n  return value;\n}\n\n/**\n * Set a nested value in an object using a path\n * Creates intermediate objects as needed\n *\n * @param obj - Target object to modify\n * @param pathParts - Array of path segments (e.g., ['colors', 'primary'])\n * @param value - Value to set at the path\n */\nexport function setNestedValue(obj: any, pathParts: string[], value: any): void {\n  let current = obj;\n\n  // Navigate/create nested structure up to the last segment\n  for (let i = 0; i < pathParts.length - 1; i++) {\n    const part = pathParts[i];\n    if (!(part in current)) {\n      current[part] = {};\n    }\n    current = current[part];\n  }\n\n  // Set the final value\n  current[pathParts[pathParts.length - 1]] = value;\n}\n", "/**\n * Export baseline builder module\n * Builds baseline snapshot structure from Figma variables\n */\n\nimport type { BaselineSnapshot, BaselineEntry, ExportToken } from '../../types/index.js';\nimport { mapFigmaTypeToTokenType } from '../utils/type-mappers.js';\nimport { resolveVariableValue, setNestedValue } from './transformer.js';\n\n/**\n * Build a complete baseline snapshot from Figma variables\n * Generates both nested token structure and flat baseline lookup\n *\n * @param filterCollectionIds - Optional array of collection IDs to export (null = all)\n * @returns Complete baseline snapshot with metadata\n */\nexport async function buildBaselineSnapshot(\n  filterCollectionIds: string[] | null = null\n): Promise<BaselineSnapshot> {\n  let collections = await figma.variables.getLocalVariableCollectionsAsync();\n  const allVariables = await figma.variables.getLocalVariablesAsync();\n\n  // Filter collections if specific IDs provided\n  if (filterCollectionIds && filterCollectionIds.length > 0) {\n    collections = collections.filter(c => filterCollectionIds.includes(c.id));\n  }\n\n  // Initialize output structure with metadata\n  const output: BaselineSnapshot = {\n    $metadata: {\n      version: '2.0.0',\n      exportedAt: new Date().toISOString(),\n      pluginVersion: '1.0.0',\n      fileKey: figma.fileKey || '',\n      fileName: figma.root.name\n    },\n    baseline: {}\n  };\n\n  // Process each collection\n  for (const collection of collections) {\n    const collectionName = collection.name;\n    const variables = allVariables.filter(v => v.variableCollectionId === collection.id);\n\n    // Initialize collection in output\n    if (!output[collectionName]) {\n      output[collectionName] = {};\n    }\n\n    // Process each mode\n    for (const mode of collection.modes) {\n      // Use \"value\" as default mode name if Figma's default \"Mode 1\" is detected\n      const modeName = mode.name === 'Mode 1' ? 'value' : mode.name;\n\n      // Initialize mode in collection\n      if (!output[collectionName][modeName]) {\n        output[collectionName][modeName] = {};\n      }\n\n      // Process each variable in this mode\n      for (const variable of variables) {\n        const pathParts = variable.name.split('/').map(p => p.trim());\n        const value = await resolveVariableValue(variable, mode.modeId);\n        const tokenType = mapFigmaTypeToTokenType(variable.resolvedType);\n\n        // Create prefixed variable ID: collectionName:modeName:VariableID\n        const prefixedId = `${collectionName}:${modeName}:${variable.id}`;\n\n        // Create token for nested structure\n        const token: ExportToken = {\n          $type: tokenType,\n          $value: value,\n          $variableId: prefixedId\n        };\n\n        // Add to nested structure\n        setNestedValue(output[collectionName][modeName], pathParts, token);\n\n        // Add to baseline (flat structure)\n        const fullPath = `${collectionName}.${modeName}.${pathParts.join('.')}`;\n        output.baseline[prefixedId] = {\n          path: fullPath,\n          value: value,\n          type: tokenType,\n          collection: collectionName,\n          mode: modeName\n        };\n      }\n    }\n  }\n\n  return output;\n}\n", "/**\n * Export orchestrator module\n * Main entry point for exporting baseline snapshots from Figma variables\n *\n * @module backend/export\n */\n\nimport type { BaselineSnapshot } from '../../types/index.js';\nimport { buildBaselineSnapshot } from './baseline.js';\n\n/**\n * Export baseline snapshot with optional collection filtering.\n *\n * Creates a complete snapshot of Figma variables in a standardized baseline format\n * that can be used for:\n * - Syncing to the registry node for API access\n * - Exporting to JSON files for version control\n * - Diffing against previous baselines to detect changes\n *\n * The baseline snapshot includes:\n * - Nested token structure organized by collection \u2192 mode \u2192 group \u2192 token\n * - Flat baseline lookup mapping variable IDs to metadata\n * - Metadata about the export (timestamp, file info, plugin version)\n *\n * @param filterCollectionIds - Optional array of collection IDs to export.\n *                              If null or empty, all collections are exported.\n * @returns Promise resolving to complete baseline snapshot\n *\n * @throws {Error} If Figma API calls fail\n * @throws {Error} If variable value resolution fails\n *\n * @example\n * ```ts\n * // Export all collections\n * const fullBaseline = await exportBaseline();\n *\n * // Export specific collections\n * const filteredBaseline = await exportBaseline(['collection-id-1', 'collection-id-2']);\n *\n * // Access nested structure\n * const primaryColor = fullBaseline['Design Tokens'].light.colors.primary;\n *\n * // Access flat baseline\n * const variableInfo = fullBaseline.baseline['123:456'];\n * // { path: 'colors/primary', value: '#0000ff', type: 'color', ... }\n * ```\n */\nexport async function exportBaseline(\n  filterCollectionIds: string[] | null = null\n): Promise<BaselineSnapshot> {\n  return buildBaselineSnapshot(filterCollectionIds);\n}\n\n// Re-export transformer utilities for convenience\nexport { resolveVariableValue, setNestedValue } from './transformer.js';\nexport { buildBaselineSnapshot } from './baseline.js';\n", "/**\n * Plugin constants and configuration\n */\n\n/** Plugin namespace for sharedPluginData storage */\nexport const PLUGIN_NAMESPACE = 'token_vault';\n\n/** Legacy namespace for backwards compatibility */\nexport const LEGACY_NAMESPACE = 'design_token_importer';\n\n/** Name of the registry node */\nexport const REGISTRY_NODE_NAME = '_token_registry';\n\n/** Chunk size for splitting data (90KB to stay under 100KB limit) */\nexport const CHUNK_SIZE = 90000;\n\n/** Plugin version */\nexport const PLUGIN_VERSION = '2.0.0';\n\n/** Baseline version */\nexport const BASELINE_VERSION = '2.0.0';\n", "/**\n * Data chunking utilities for handling Figma's 100KB sharedPluginData limit\n *\n * @module backend/sync/chunker\n */\n\nimport { CHUNK_SIZE } from '../utils/constants.js';\n\n/**\n * Result of chunking operation\n */\nexport interface ChunkedData {\n  /** Array of chunk strings */\n  chunks: string[];\n  /** Total size in bytes */\n  totalSize: number;\n  /** Number of chunks created */\n  chunkCount: number;\n}\n\n/**\n * Split data into safe-sized chunks for storage in sharedPluginData.\n * Uses 90KB chunks to stay under Figma's 100KB limit per entry.\n *\n * @param data - Data to chunk (will be JSON stringified)\n * @returns Chunked data with metadata\n *\n * @example\n * ```ts\n * const snapshot = { tokens: {...} };\n * const chunked = chunkData(snapshot);\n * console.log(`Split into ${chunked.chunkCount} chunks`);\n * ```\n */\nexport function chunkData(data: unknown): ChunkedData {\n  // Stringify the data\n  const jsonData = JSON.stringify(data);\n  const totalSize = jsonData.length;\n  const chunks: string[] = [];\n\n  // Split into chunks\n  for (let i = 0; i < jsonData.length; i += CHUNK_SIZE) {\n    chunks.push(jsonData.slice(i, i + CHUNK_SIZE));\n  }\n\n  return {\n    chunks,\n    totalSize,\n    chunkCount: chunks.length\n  };\n}\n\n/**\n * Reassemble chunked data back into original object.\n *\n * @param chunks - Array of chunk strings\n * @returns Parsed data object\n * @throws Error if JSON parsing fails\n *\n * @example\n * ```ts\n * const original = unchunkData(chunked.chunks);\n * ```\n */\nexport function unchunkData(chunks: string[]): unknown {\n  // Join all chunks\n  const jsonData = chunks.join('');\n\n  // Parse and return\n  try {\n    return JSON.parse(jsonData);\n  } catch (error) {\n    throw new Error(`Failed to parse unchunked data: ${error instanceof Error ? error.message : 'Unknown error'}`);\n  }\n}\n", "/**\n * Registry node management for token synchronization\n *\n * @module backend/sync/node-manager\n */\n\nimport { REGISTRY_NODE_NAME } from '../utils/constants.js';\n\n/**\n * Find the registry node across all pages.\n * The registry node is a hidden, locked frame that stores token data.\n *\n * @returns Registry node if found, null otherwise\n *\n * @example\n * ```ts\n * const node = await findRegistryNode();\n * if (node) {\n *   console.log(`Found registry node: ${node.id}`);\n * }\n * ```\n */\nexport async function findRegistryNode(): Promise<FrameNode | null> {\n  // Search all pages for the registry node\n  for (const page of figma.root.children) {\n    // Load page before accessing children\n    await page.loadAsync();\n\n    for (const node of page.children) {\n      if (node.type === 'FRAME' && node.name === REGISTRY_NODE_NAME) {\n        return node;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Create a new registry node on the current page.\n * The node is created off-canvas, hidden, and locked to prevent accidental deletion.\n *\n * @returns Newly created registry node\n *\n * @example\n * ```ts\n * const node = await createRegistryNode();\n * console.log(`Created registry node: ${node.id}`);\n * ```\n */\nexport async function createRegistryNode(): Promise<FrameNode> {\n  const frame = figma.createFrame();\n  frame.name = REGISTRY_NODE_NAME;\n  frame.resize(100, 100);\n\n  // Position off-canvas to keep it out of the way\n  frame.x = -1000;\n  frame.y = -1000;\n\n  // Hide and lock to prevent accidental interaction\n  frame.visible = false;\n  frame.locked = true;\n\n  return frame;\n}\n\n/**\n * Get the registry node, creating it if it doesn't exist.\n * This is the primary entry point for accessing the registry node.\n *\n * @returns Registry node (existing or newly created)\n *\n * @example\n * ```ts\n * const node = await getOrCreateRegistryNode();\n * // Node is guaranteed to exist here\n * ```\n */\nexport async function getOrCreateRegistryNode(): Promise<FrameNode> {\n  const existing = await findRegistryNode();\n\n  if (existing) {\n    return existing;\n  }\n\n  return await createRegistryNode();\n}\n\n/**\n * Clear all chunk data from the registry node.\n * Removes up to 20 chunks to ensure clean slate for new data.\n *\n * @param node - Registry node to clear\n * @param namespace - Plugin namespace to clear data from\n *\n * @example\n * ```ts\n * const node = await getOrCreateRegistryNode();\n * clearNodeChunks(node, 'token_vault');\n * ```\n */\nexport function clearNodeChunks(node: FrameNode, namespace: string): void {\n  // Clear up to 20 chunks (should be more than enough)\n  for (let i = 0; i < 20; i++) {\n    node.setSharedPluginData(namespace, `registry_${i}`, '');\n  }\n}\n\n/**\n * Save chunk data to the registry node.\n *\n * @param node - Registry node to save to\n * @param namespace - Plugin namespace\n * @param chunks - Array of chunk strings to save\n *\n * @example\n * ```ts\n * const node = await getOrCreateRegistryNode();\n * saveChunksToNode(node, 'token_vault', chunked.chunks);\n * ```\n */\nexport function saveChunksToNode(\n  node: FrameNode,\n  namespace: string,\n  chunks: string[]\n): void {\n  for (let i = 0; i < chunks.length; i++) {\n    node.setSharedPluginData(namespace, `registry_${i}`, chunks[i]);\n  }\n}\n\n/**\n * Load chunk data from the registry node.\n *\n * @param node - Registry node to load from\n * @param namespace - Plugin namespace\n * @param chunkCount - Number of chunks to load\n * @returns Array of chunk strings\n *\n * @example\n * ```ts\n * const node = await findRegistryNode();\n * if (node) {\n *   const chunks = loadChunksFromNode(node, 'token_vault', 3);\n * }\n * ```\n */\nexport function loadChunksFromNode(\n  node: FrameNode,\n  namespace: string,\n  chunkCount: number\n): string[] {\n  const chunks: string[] = [];\n\n  for (let i = 0; i < chunkCount; i++) {\n    const chunk = node.getSharedPluginData(namespace, `registry_${i}`);\n    chunks.push(chunk);\n  }\n\n  return chunks;\n}\n", "/**\n * Sync metadata management for registry node\n *\n * @module backend/sync/metadata\n */\n\nimport { PLUGIN_NAMESPACE, LEGACY_NAMESPACE } from '../utils/constants.js';\nimport type { SyncMetadata, SyncInfo } from '../../types/message.types.js';\n\n/**\n * Read sync metadata from a registry node.\n * Supports both current and legacy namespaces for backwards compatibility.\n *\n * @param node - Registry node to read from\n * @returns Sync information\n *\n * @example\n * ```ts\n * const node = await findRegistryNode();\n * if (node) {\n *   const info = readSyncMetadata(node);\n *   console.log(`Last synced: ${info.updatedAt}`);\n * }\n * ```\n */\nexport function readSyncMetadata(node: FrameNode): SyncInfo {\n  // Try current namespace first\n  let updatedAt = node.getSharedPluginData(PLUGIN_NAMESPACE, 'updatedAt');\n  let variableCount = node.getSharedPluginData(PLUGIN_NAMESPACE, 'variableCount');\n\n  // Fallback to legacy namespace for backwards compatibility\n  if (!updatedAt) {\n    updatedAt = node.getSharedPluginData(LEGACY_NAMESPACE, 'updatedAt');\n    variableCount = node.getSharedPluginData(LEGACY_NAMESPACE, 'variableCount');\n  }\n\n  if (!updatedAt) {\n    return { exists: false };\n  }\n\n  return {\n    exists: true,\n    nodeId: node.id,\n    updatedAt,\n    variableCount: variableCount ? parseInt(variableCount, 10) : undefined\n  };\n}\n\n/**\n * Write sync metadata to a registry node.\n *\n * @param node - Registry node to write to\n * @param metadata - Metadata to save\n *\n * @example\n * ```ts\n * const node = await getOrCreateRegistryNode();\n * writeSyncMetadata(node, {\n *   chunkCount: 3,\n *   updatedAt: new Date().toISOString(),\n *   variableCount: 150\n * });\n * ```\n */\nexport function writeSyncMetadata(node: FrameNode, metadata: SyncMetadata): void {\n  node.setSharedPluginData(PLUGIN_NAMESPACE, 'chunkCount', String(metadata.chunkCount));\n  node.setSharedPluginData(PLUGIN_NAMESPACE, 'updatedAt', metadata.updatedAt);\n  node.setSharedPluginData(PLUGIN_NAMESPACE, 'variableCount', String(metadata.variableCount));\n}\n", "/**\n * Sync orchestrator - coordinates export, chunking, and node storage\n *\n * This module manages the synchronization of Figma variables to a registry node,\n * enabling the Synkio CLI to fetch token data via the Figma API without requiring\n * manual export steps from the plugin.\n *\n * @module backend/sync\n */\n\nimport { chunkData } from './chunker.js';\nimport {\n  getOrCreateRegistryNode,\n  findRegistryNode,\n  clearNodeChunks,\n  saveChunksToNode\n} from './node-manager.js';\nimport { readSyncMetadata, writeSyncMetadata } from './metadata.js';\nimport { PLUGIN_NAMESPACE } from '../utils/constants.js';\nimport type { SyncInfo } from '../../types/message.types.js';\n\n/**\n * Sync token data to registry node.\n *\n * This is the main entry point for the sync flow. It orchestrates the complete\n * process of persisting token data to a hidden registry node in the Figma file.\n *\n * **Flow:**\n * 1. Export baseline snapshot (passed as parameter to avoid circular dependency)\n * 2. Chunk the data into safe-sized pieces (under 100KB per chunk)\n * 3. Get or create registry node (_token_registry frame)\n * 4. Clear old chunks from previous sync\n * 5. Save new chunks to node's sharedPluginData\n * 6. Save metadata (chunk count, timestamp, variable count)\n *\n * The registry node is:\n * - A hidden, locked FrameNode named \"_token_registry\"\n * - Positioned off-canvas at (-10000, -10000)\n * - Stores data in sharedPluginData with namespace 'synkio.token-vault'\n * - Accessible via Figma API for CLI fetching\n *\n * @param exportData - Baseline snapshot data to sync (from exportBaseline)\n * @returns Promise resolving to sync result with node ID and variable count\n *\n * @throws {Error} If node creation/update fails\n * @throws {Error} If data chunking fails (data too large even after chunking)\n *\n * @example\n * ```ts\n * // Typical usage in message handler\n * const snapshot = await exportBaseline(['collection-id']);\n * const result = await syncToNode(snapshot);\n *\n * console.log(`Synced to node ${result.nodeId}`);\n * console.log(`Saved ${result.variableCount} variables`);\n *\n * // CLI can now fetch via Figma API:\n * // GET /v1/files/:fileKey/nodes/:nodeId?plugin_data=synkio.token-vault\n * ```\n */\nexport async function syncToNode(exportData: unknown): Promise<{\n  nodeId: string;\n  variableCount: number;\n}> {\n  console.log('[Sync] Starting sync to node...');\n\n  // Calculate variable count from baseline\n  const variableCount = exportData && typeof exportData === 'object' && 'baseline' in exportData\n    ? Object.keys((exportData as any).baseline).length\n    : 0;\n\n  console.log(`[Sync] Syncing ${variableCount} variables`);\n\n  // Chunk the data\n  const chunked = chunkData(exportData);\n  console.log(`[Sync] Split ${chunked.totalSize} bytes into ${chunked.chunkCount} chunks`);\n\n  // Get or create registry node\n  const node = await getOrCreateRegistryNode();\n  console.log(`[Sync] Using registry node: ${node.id}`);\n\n  // Clear old chunks\n  clearNodeChunks(node, PLUGIN_NAMESPACE);\n\n  // Save new chunks\n  saveChunksToNode(node, PLUGIN_NAMESPACE, chunked.chunks);\n\n  // Save metadata\n  const metadata = {\n    chunkCount: chunked.chunkCount,\n    updatedAt: new Date().toISOString(),\n    variableCount\n  };\n  writeSyncMetadata(node, metadata);\n\n  console.log(`[Sync] Successfully synced ${chunked.totalSize} bytes in ${chunked.chunkCount} chunks to node ${node.id}`);\n\n  return {\n    nodeId: node.id,\n    variableCount\n  };\n}\n\n/**\n * Get information about the last sync.\n *\n * Searches all pages in the current Figma file for the registry node and reads\n * its metadata to determine when the last sync occurred and how many variables\n * were synced.\n *\n * Used by the UI to display sync status and help users understand if their\n * local token data is up-to-date.\n *\n * @returns Promise resolving to sync information\n *          - If registry node exists: { exists: true, nodeId, updatedAt, variableCount }\n *          - If no sync found: { exists: false }\n *\n * @example\n * ```ts\n * const info = await getLastSyncInfo();\n *\n * if (info.exists) {\n *   console.log(`Last synced: ${info.updatedAt}`);\n *   console.log(`Node ID: ${info.nodeId}`);\n *   console.log(`Variables: ${info.variableCount}`);\n * } else {\n *   console.log('No sync found. Sync to create registry node.');\n * }\n * ```\n */\nexport async function getLastSyncInfo(): Promise<SyncInfo> {\n  const node = await findRegistryNode();\n\n  if (!node) {\n    return { exists: false };\n  }\n\n  return readSyncMetadata(node);\n}\n\n// Re-export types and utilities for convenience\nexport type { SyncInfo, SyncMetadata } from '../../types/message.types.js';\nexport { chunkData, unchunkData } from './chunker.js';\nexport {\n  findRegistryNode,\n  getOrCreateRegistryNode,\n  createRegistryNode\n} from './node-manager.js';\nexport { readSyncMetadata, writeSyncMetadata } from './metadata.js';\n", "/**\n * Message handler router\n * Routes incoming messages from UI to appropriate backend modules\n *\n * This module serves as the central message dispatcher for the plugin backend,\n * receiving all messages from the UI iframe and routing them to the appropriate\n * feature handlers (import, export, sync).\n *\n * @module backend/handlers/message-router\n */\n\nimport type { UIMessage, PluginMessage } from '../../types/message.types.js';\nimport { importTokens } from '../import/index.js';\nimport { exportBaseline } from '../export/index.js';\nimport { syncToNode, getLastSyncInfo } from '../sync/index.js';\n\n/**\n * Handle incoming message from UI.\n *\n * This is the main entry point for all UI-to-backend communication in the plugin.\n * It receives type-safe messages from the UI and routes them to appropriate handlers.\n *\n * The message routing is exhaustive - TypeScript enforces that all message types\n * are handled via the never type check at the end of the switch statement.\n *\n * **Message Flow:**\n * ```\n * UI \u2192 message-bridge.ts \u2192 figma.ui.onmessage \u2192 handleMessage \u2192 [handler] \u2192 response\n * ```\n *\n * **Supported Messages:**\n * - `get-last-sync`: Retrieve sync metadata from registry node\n * - `get-collections`: List all local variable collections\n * - `import-tokens`: Import tokens from JSON files into Figma\n * - `export-baseline`: Export variables to JSON baseline format\n * - `sync-to-node`: Sync variables to registry node for API access\n * - `cancel`: Close the plugin\n *\n * @param msg - Type-safe message from UI (UIMessage union type)\n * @returns Promise that resolves when message handling is complete\n *\n * @example\n * ```ts\n * // In code.ts entry point\n * figma.ui.onmessage = async (msg: UIMessage) => {\n *   await handleMessage(msg);\n * };\n * ```\n */\nexport async function handleMessage(msg: UIMessage): Promise<void> {\n  switch (msg.type) {\n    case 'get-last-sync':\n      await handleGetLastSync();\n      break;\n\n    case 'get-collections':\n      await handleGetCollections();\n      break;\n\n    case 'import-tokens':\n      await handleImportTokens(msg.data.collections);\n      break;\n\n    case 'export-baseline':\n      await handleExportBaseline(msg.collectionIds);\n      break;\n\n    case 'sync-to-node':\n      await handleSyncToNode(msg.collectionIds);\n      break;\n\n    case 'cancel':\n      handleCancel();\n      break;\n\n    default:\n      // TypeScript exhaustiveness check\n      const _exhaustive: never = msg;\n      console.warn('Unknown message type:', _exhaustive);\n  }\n}\n\n/**\n * Post message to UI.\n *\n * Type-safe wrapper around figma.ui.postMessage. All responses to the UI\n * must use PluginMessage types.\n *\n * @param msg - Type-safe plugin message\n * @internal\n */\nfunction postMessage(msg: PluginMessage): void {\n  figma.ui.postMessage(msg);\n}\n\n/**\n * Handle get-last-sync message.\n *\n * Retrieves and sends last sync information to UI. If no registry node exists\n * or metadata can't be read, sends { exists: false }.\n *\n * @internal\n */\nasync function handleGetLastSync(): Promise<void> {\n  try {\n    const syncInfo = await getLastSyncInfo();\n    postMessage({\n      type: 'last-sync-loaded',\n      ...syncInfo\n    });\n  } catch (error) {\n    console.error('Error loading last sync info:', error);\n    postMessage({\n      type: 'last-sync-loaded',\n      exists: false\n    });\n  }\n}\n\n/**\n * Handle get-collections message.\n *\n * Retrieves all local variable collections and sends summary to UI.\n * The summary includes collection ID, name, mode count, and variable count\n * for display in export/sync tabs.\n *\n * @internal\n */\nasync function handleGetCollections(): Promise<void> {\n  try {\n    const collections = await figma.variables.getLocalVariableCollectionsAsync();\n    const allVariables = await figma.variables.getLocalVariablesAsync();\n\n    const collectionData = collections.map(col => ({\n      id: col.id,\n      name: col.name,\n      modeCount: col.modes.length,\n      variableCount: allVariables.filter(v => v.variableCollectionId === col.id).length\n    }));\n\n    postMessage({\n      type: 'collections-loaded',\n      collections: collectionData\n    });\n  } catch (error) {\n    console.error('Error loading collections:', error);\n  }\n}\n\n/**\n * Handle import-tokens message.\n *\n * Orchestrates the token import flow by delegating to the import module.\n * Sends success or error message back to UI when complete.\n *\n * @param collections - Array of collection configurations with token data\n * @internal\n */\nasync function handleImportTokens(collections: any[]): Promise<void> {\n  try {\n    await importTokens(collections);\n    postMessage({\n      type: 'import-complete',\n      message: 'Tokens imported successfully!'\n    });\n  } catch (error) {\n    postMessage({\n      type: 'import-error',\n      message: error instanceof Error ? error.message : String(error)\n    });\n  }\n}\n\n/**\n * Handle export-baseline message.\n *\n * Exports baseline snapshot and sends to UI for display/download.\n * Supports optional collection filtering.\n *\n * @param collectionIds - Array of collection IDs to export (empty = all)\n * @internal\n */\nasync function handleExportBaseline(collectionIds: string[]): Promise<void> {\n  try {\n    console.log('Export baseline requested');\n    figma.notify('Exporting baseline snapshot...');\n\n    const filterIds = collectionIds && collectionIds.length > 0 ? collectionIds : null;\n    const baseline = await exportBaseline(filterIds);\n    const jsonString = JSON.stringify(baseline);\n\n    console.log('Export complete, data size:', jsonString.length, 'bytes');\n\n    postMessage({\n      type: 'export-complete',\n      data: baseline\n    });\n\n    figma.notify('Export complete!');\n  } catch (error) {\n    console.error('Export error:', error);\n    const errorMessage = error instanceof Error ? error.message : String(error);\n\n    postMessage({\n      type: 'export-error',\n      message: errorMessage\n    });\n\n    figma.notify('Export failed: ' + errorMessage, { error: true });\n  }\n}\n\n/**\n * Handle sync-to-node message.\n *\n * Syncs token registry to node for API access by the Synkio CLI.\n * This enables developers to fetch tokens without manual plugin interaction.\n *\n * @param collectionIds - Array of collection IDs to sync (empty = all)\n * @internal\n */\nasync function handleSyncToNode(collectionIds: string[]): Promise<void> {\n  try {\n    console.log('Sync to Node requested');\n    figma.notify('Syncing registry to node...');\n\n    const filterIds = collectionIds && collectionIds.length > 0 ? collectionIds : null;\n\n    // Export baseline first\n    const exportData = await exportBaseline(filterIds);\n\n    // Then sync to node\n    const result = await syncToNode(exportData);\n\n    postMessage({\n      type: 'sync-complete',\n      nodeId: result.nodeId,\n      variableCount: result.variableCount\n    });\n\n    figma.notify(`\u2713 Synced ${result.variableCount} variables to node!`);\n  } catch (error) {\n    console.error('Sync error:', error);\n    const errorMessage = error instanceof Error ? error.message : String(error);\n\n    postMessage({\n      type: 'sync-error',\n      message: errorMessage\n    });\n\n    figma.notify('Sync failed: ' + errorMessage, { error: true });\n  }\n}\n\n/**\n * Handle cancel message.\n *\n * Closes the plugin when user clicks cancel button.\n *\n * @internal\n */\nfunction handleCancel(): void {\n  figma.closePlugin();\n}\n", "/**\n * Token Vault - Figma Plugin Entry Point\n * Import, export, and sync design tokens as Figma Variables\n *\n * This is the main entry point for the plugin backend.\n * All business logic is delegated to specialized modules.\n *\n * @module code\n */\n\nimport { handleMessage } from './backend/handlers/message-router.js';\n\n/**\n * Initialize plugin UI\n * Shows the plugin window with configured dimensions and theme support\n */\nfigma.showUI(__html__, {\n  width: 600,\n  height: 700,\n  themeColors: true\n});\n\n/**\n * Message handler\n * Routes all messages from UI to the message router\n */\nfigma.ui.onmessage = async (msg) => {\n  await handleMessage(msg);\n};\n"],
  "mappings": "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",
  "names": ["modeId"]
}
