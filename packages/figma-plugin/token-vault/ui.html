<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
/**
 * Base styles - resets, typography, and global styles
 */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  font-size: 11px;
  color: var(--figma-color-text);
  background: var(--figma-color-bg);
}

/* Utility classes */
.hidden {
  display: none !important;
}

/* Divider */
.divider {
  height: 1px;
  background: var(--figma-color-border);
  margin: 16px 0;
}

/* Loading state */
.loading {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 40px;
  color: var(--figma-color-text-secondary);
}

.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--figma-color-border);
  border-top-color: var(--figma-color-bg-brand);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  margin-right: 8px;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Empty state */
.empty-state {
  text-align: center;
  padding: 32px;
  color: var(--figma-color-text-secondary);
}

.empty-state-icon {
  font-size: 32px;
  margin-bottom: 8px;
  opacity: 0.5;
}

/* Info box */
.info-box {
  background: var(--figma-color-bg-secondary);
  border-radius: 6px;
  padding: 10px 12px;
  margin-top: 12px;
}

.info-box-title {
  font-weight: 500;
  color: var(--figma-color-text);
  margin-bottom: 4px;
}

.info-box-text {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  line-height: 1.4;
}

/**
 * Tab system styles - segmented control and tab panels
 */

/* Segmented Control */
.segmented-control {
  display: flex;
  background: var(--figma-color-bg-secondary);
  border-radius: 6px;
  padding: 2px;
  margin: 12px;
}

.segmented-control button {
  flex: 1;
  padding: 8px 12px;
  border: none;
  background: transparent;
  color: var(--figma-color-text-secondary);
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.15s ease;
}

.segmented-control button:hover {
  color: var(--figma-color-text);
}

.segmented-control button.active {
  background: var(--figma-color-bg);
  color: var(--figma-color-text);
  box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* Tab Panels */
.tab-panel {
  display: none;
  padding: 0 12px 12px;
}

.tab-panel.active {
  display: block;
}

/* Action buttons footer */
.action-footer {
  display: flex;
  gap: 8px;
  padding: 12px;
  border-top: 1px solid var(--figma-color-border);
  background: var(--figma-color-bg);
  position: sticky;
  bottom: 0;
}

.action-footer .button {
  flex: 1;
}

/**
 * Component styles - buttons, forms, cards, and UI elements
 */

/* Buttons */
.button {
  padding: 8px 16px;
  border: none;
  border-radius: 6px;
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
}

.button-primary {
  background: var(--figma-color-bg-brand);
  color: white;
}

.button-primary:hover:not(:disabled) {
  background: var(--figma-color-bg-brand-hover);
}

.button-primary:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.button-secondary {
  background: var(--figma-color-bg-secondary);
  color: var(--figma-color-text);
}

.button-secondary:hover {
  background: var(--figma-color-bg-hover);
}

.button-ghost {
  background: transparent;
  color: var(--figma-color-text-secondary);
  padding: 4px 8px;
}

.button-ghost:hover {
  background: var(--figma-color-bg-hover);
  color: var(--figma-color-text);
}

.button-full {
  width: 100%;
}

.button-add {
  width: 100%;
  padding: 8px;
  background: transparent;
  color: var(--figma-color-text-secondary);
  border: 1px dashed var(--figma-color-border);
  margin-bottom: 12px;
}

.button-add:hover {
  background: var(--figma-color-bg-hover);
  color: var(--figma-color-text);
  border-color: var(--figma-color-border-strong);
}

/* Form elements - Figma style */
input[type="text"] {
  width: 100%;
  padding: 7px 8px;
  border: 1px solid var(--figma-color-border);
  border-radius: 4px;
  background: var(--figma-color-bg);
  color: var(--figma-color-text);
  font-size: 11px;
  outline: none;
}

input[type="text"]:focus {
  border-color: var(--figma-color-border-brand);
  box-shadow: 0 0 0 1px var(--figma-color-border-brand);
}

input[type="file"] {
  display: none;
}

/* Checkbox - Figma style */
.checkbox-container {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  padding: 4px 0;
}

.checkbox-container input[type="checkbox"] {
  width: 12px;
  height: 12px;
  margin: 0;
  accent-color: var(--figma-color-bg-brand);
}

.checkbox-label {
  font-size: 11px;
  color: var(--figma-color-text);
}

.checkbox-sublabel {
  font-size: 10px;
  color: var(--figma-color-text-tertiary);
  margin-left: 20px;
  margin-top: 2px;
}

/* Section styling */
.section {
  margin-bottom: 16px;
}

.section-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--figma-color-text);
  margin-bottom: 8px;
}

.section-description {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  margin-bottom: 8px;
}

/* File upload area */
.file-upload {
  border: 1px dashed var(--figma-color-border);
  border-radius: 6px;
  padding: 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.15s ease;
  background: var(--figma-color-bg);
}

.file-upload:hover {
  background: var(--figma-color-bg-hover);
  border-color: var(--figma-color-border-strong);
}

.file-upload.dragover {
  background: var(--figma-color-bg-brand-tertiary);
  border-color: var(--figma-color-border-brand);
}

.file-upload-icon {
  font-size: 24px;
  margin-bottom: 8px;
}

/* File list */
.file-list {
  margin-top: 8px;
}

.file-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 10px;
  background: var(--figma-color-bg-secondary);
  border-radius: 4px;
  margin-bottom: 4px;
}

.file-info {
  display: flex;
  align-items: center;
  gap: 8px;
}

.file-name {
  font-weight: 500;
  color: var(--figma-color-text);
}

.file-size {
  color: var(--figma-color-text-tertiary);
  font-size: 10px;
}

/* Collection config */
.collection-config {
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  padding: 12px;
  margin-bottom: 8px;
  background: var(--figma-color-bg);
}

.collection-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.collection-header input[type="text"] {
  flex: 1;
}

/* File assignment area */
.file-assignment {
  margin-top: 8px;
  padding: 8px;
  background: var(--figma-color-bg-secondary);
  border-radius: 4px;
}

.file-assignment-title {
  font-size: 10px;
  font-weight: 500;
  color: var(--figma-color-text-secondary);
  margin-bottom: 6px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Collection list for export/sync */
.collection-list {
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  overflow: hidden;
}

.collection-list-item {
  display: flex;
  align-items: center;
  padding: 10px 12px;
  border-bottom: 1px solid var(--figma-color-border);
  background: var(--figma-color-bg);
}

.collection-list-item:last-child {
  border-bottom: none;
}

.collection-list-item:hover {
  background: var(--figma-color-bg-hover);
}

.collection-list-item input[type="checkbox"] {
  margin-right: 10px;
}

.collection-info {
  flex: 1;
}

.collection-name {
  font-weight: 500;
  color: var(--figma-color-text);
}

.collection-meta {
  font-size: 10px;
  color: var(--figma-color-text-tertiary);
  margin-top: 2px;
}

/* Select all / none buttons */
.selection-controls {
  display: flex;
  gap: 8px;
  margin-bottom: 8px;
}

.selection-controls button {
  font-size: 10px;
  padding: 4px 8px;
}

/* Success Screen */
.success-screen {
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 32px 24px;
  text-align: center;
}

.success-screen.active {
  display: flex;
}

.success-icon {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  background: var(--figma-color-bg-success-tertiary, #e6f4ea);
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 16px;
}

.success-icon svg {
  width: 32px;
  height: 32px;
  color: var(--figma-color-icon-success, #1e8e3e);
}

.success-title {
  font-size: 14px;
  font-weight: 600;
  color: var(--figma-color-text);
  margin-bottom: 8px;
}

.success-description {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  margin-bottom: 20px;
  max-width: 280px;
}

.success-details {
  width: 100%;
  background: var(--figma-color-bg-secondary);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 20px;
}

.success-detail-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 0;
  border-bottom: 1px solid var(--figma-color-border);
}

.success-detail-row:last-child {
  border-bottom: none;
}

.success-detail-label {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
}

.success-detail-value {
  font-size: 11px;
  font-weight: 500;
  color: var(--figma-color-text);
  font-family: 'SF Mono', Monaco, 'Courier New', monospace;
}

.success-detail-value.copyable {
  cursor: pointer;
  padding: 4px 8px;
  background: var(--figma-color-bg);
  border-radius: 4px;
  border: 1px solid var(--figma-color-border);
  transition: all 0.15s ease;
  display: inline-flex;
  align-items: center;
  gap: 6px;
}

.success-detail-value.copyable:hover {
  background: var(--figma-color-bg-hover);
  border-color: var(--figma-color-border-strong);
}

.success-detail-value.copyable:active {
  background: var(--figma-color-bg-pressed);
}

.copy-icon {
  opacity: 0.5;
  flex-shrink: 0;
  transition: opacity 0.15s ease;
}

.success-detail-value.copyable:hover .copy-icon {
  opacity: 1;
}

.copy-hint {
  font-size: 9px;
  color: var(--figma-color-text-tertiary);
  margin-top: 4px;
}

.success-actions {
  display: flex;
  gap: 8px;
  width: 100%;
}

.success-actions .button {
  flex: 1;
}

/* Node preview */
.node-preview {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: var(--figma-color-bg);
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  margin-bottom: 16px;
  width: 100%;
}

.node-preview-icon {
  width: 40px;
  height: 40px;
  background: var(--figma-color-bg-secondary);
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-shrink: 0;
}

.node-preview-icon svg {
  width: 20px;
  height: 20px;
  color: var(--figma-color-icon-secondary);
}

.node-preview-info {
  flex: 1;
  text-align: left;
  min-width: 0;
}

.node-preview-name {
  font-size: 11px;
  font-weight: 500;
  color: var(--figma-color-text);
  margin-bottom: 2px;
}

.node-preview-type {
  font-size: 10px;
  color: var(--figma-color-text-tertiary);
}

/**
 * Baseline Confirmation Component Styles
 *
 * Styles for the baseline detection and confirmation UI,
 * including valid, warning, and error states.
 */

.baseline-confirmation {
  background: var(--figma-color-bg);
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  padding: 16px;
  margin: 16px 0;
}

/* Header Section */
.baseline-header {
  display: flex;
  gap: 12px;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--figma-color-border);
}

.baseline-header.error {
  border-bottom-color: var(--figma-color-border-danger, #f24822);
}

.baseline-header.warning {
  border-bottom-color: var(--figma-color-border-warning, #f9a825);
}

.status-icon {
  font-size: 24px;
  line-height: 1;
  flex-shrink: 0;
}

.baseline-title {
  flex: 1;
  min-width: 0;
}

.filename {
  font-weight: 600;
  font-size: 13px;
  margin-bottom: 4px;
  color: var(--figma-color-text);
}

.file-info {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
}

/* Content Section */
.baseline-content {
  margin-bottom: 16px;
}

.collections-summary {
  margin: 12px 0;
}

.summary-title {
  font-weight: 500;
  font-size: 11px;
  margin-bottom: 8px;
  color: var(--figma-color-text);
}

.collection-item {
  font-size: 11px;
  padding: 4px 0;
  color: var(--figma-color-text-secondary);
}

.validation-status {
  margin: 12px 0;
  padding: 8px;
  background: var(--figma-color-bg-success-tertiary, #e6f4ea);
  border-radius: 4px;
}

.status-item {
  font-size: 11px;
  padding: 4px 0;
}

.status-item.valid {
  color: var(--figma-color-text-success, #1e8e3e);
}

.confirmation-question {
  font-weight: 500;
  font-size: 12px;
  margin: 16px 0 0;
  color: var(--figma-color-text);
}

/* Error State */
.baseline-confirmation.blocked {
  border-color: var(--figma-color-border-danger, #f24822);
}

.error-summary {
  font-weight: 500;
  font-size: 12px;
  color: var(--figma-color-text-danger, #f24822);
  margin-bottom: 12px;
}

.broken-aliases-list {
  max-height: 200px;
  overflow-y: auto;
  margin: 12px 0;
  padding-right: 8px;
}

/* Custom scrollbar */
.broken-aliases-list::-webkit-scrollbar {
  width: 6px;
}

.broken-aliases-list::-webkit-scrollbar-track {
  background: var(--figma-color-bg-secondary);
  border-radius: 3px;
}

.broken-aliases-list::-webkit-scrollbar-thumb {
  background: var(--figma-color-border);
  border-radius: 3px;
}

.broken-aliases-list::-webkit-scrollbar-thumb:hover {
  background: var(--figma-color-border-strong);
}

.broken-alias-item {
  padding: 8px;
  margin: 8px 0;
  background: var(--figma-color-bg-secondary);
  border-left: 3px solid var(--figma-color-border-danger, #f24822);
  border-radius: 0 4px 4px 0;
  font-size: 11px;
}

.alias-path {
  font-weight: 500;
  margin-bottom: 4px;
  color: var(--figma-color-text);
}

.alias-error {
  color: var(--figma-color-text-secondary);
  margin-left: 12px;
  font-size: 10px;
  line-height: 1.4;
}

.more-errors {
  font-size: 11px;
  color: var(--figma-color-text-tertiary);
  font-style: italic;
  margin-top: 8px;
  text-align: center;
}

.fix-instructions {
  margin: 12px 0;
  padding: 12px;
  background: var(--figma-color-bg-warning-tertiary, #fff3e0);
  border-radius: 4px;
  font-size: 11px;
  color: var(--figma-color-text);
}

.fix-instructions ol {
  margin: 8px 0 0 20px;
  padding: 0;
}

.fix-instructions li {
  margin: 4px 0;
  padding-left: 4px;
}

/* Warning State */
.baseline-confirmation.warning {
  border-color: var(--figma-color-border-warning, #f9a825);
}

.warning-message {
  padding: 12px;
  background: var(--figma-color-bg-warning-tertiary, #fff3e0);
  border-radius: 4px;
  font-size: 11px;
  color: var(--figma-color-text-warning, #f9a825);
  margin-bottom: 12px;
  line-height: 1.4;
}

/* Actions Footer */
.baseline-actions {
  display: flex;
  gap: 8px;
  margin-top: 16px;
}

.baseline-actions .button {
  flex: 1;
}

/* Responsive adjustments */
@media (max-width: 400px) {
  .baseline-actions {
    flex-direction: column-reverse;
  }

  .baseline-actions .button {
    width: 100%;
  }
}

/* Hidden state */
#baselineConfirmationSection {
  display: none;
}

#baselineConfirmationSection.active {
  display: block;
}

/**
 * Sync Changes Diff Styles
 *
 * Styles for the changes detection and version bump UI in the sync tab.
 */

.sync-changes {
  background: var(--figma-color-bg);
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  padding: 16px;
  margin: 16px 0;
}

.changes-header {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 16px;
}

.changes-header .icon {
  font-size: 20px;
}

.changes-header .title {
  font-size: 13px;
  font-weight: 600;
  color: var(--figma-color-text);
}

.changes-content {
  margin-bottom: 16px;
}

/* Change Sections */
.change-section {
  margin: 16px 0;
  padding: 12px;
  border-radius: 4px;
}

.change-section.breaking {
  background: var(--figma-color-bg-danger-secondary, #fee);
}

.change-section.addition {
  background: var(--figma-color-bg-warning-secondary, #fff4e5);
}

.change-section.patch {
  background: var(--figma-color-bg-success-secondary, #e6f4ea);
}

.section-header {
  font-size: 11px;
  font-weight: 600;
  color: var(--figma-color-text);
  margin-bottom: 8px;
}

.section-items {
  margin-left: 8px;
}

.change-item {
  font-size: 11px;
  color: var(--figma-color-text);
  padding: 2px 0;
  line-height: 1.4;
}

.more-changes {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  font-style: italic;
  padding: 4px 0;
}

/* Version Bump Box */
.version-bump-box {
  margin: 16px 0;
  padding: 12px;
  border: 2px solid var(--figma-color-border);
  border-radius: 6px;
  background: var(--figma-color-bg-secondary);
}

.bump-title {
  font-size: 11px;
  font-weight: 600;
  color: var(--figma-color-text);
  margin-bottom: 8px;
}

.bump-display {
  font-size: 16px;
  margin: 8px 0;
  display: flex;
  align-items: center;
  gap: 8px;
}

.version-current {
  color: var(--figma-color-text-secondary);
  font-family: 'SF Mono', Monaco, 'Courier New', monospace;
}

.version-new {
  font-weight: 600;
  color: var(--figma-color-text-brand);
  font-family: 'SF Mono', Monaco, 'Courier New', monospace;
}

/* Version Override */
.version-override {
  margin-top: 12px;
}

.version-override label {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  display: block;
  margin-bottom: 6px;
}

.version-inputs {
  display: flex;
  gap: 4px;
  align-items: center;
}

.version-inputs input {
  width: 60px;
  padding: 4px 8px;
  text-align: center;
  border: 1px solid var(--figma-color-border);
  border-radius: 4px;
  font-size: 11px;
  font-family: 'SF Mono', Monaco, 'Courier New', monospace;
  background: var(--figma-color-bg);
  color: var(--figma-color-text);
}

.version-inputs input:focus {
  outline: none;
  border-color: var(--figma-color-border-brand);
  box-shadow: 0 0 0 1px var(--figma-color-border-brand);
}

/* Sync Actions */
.sync-actions {
  display: flex;
  gap: 8px;
  margin-top: 16px;
}

.sync-actions .button {
  flex: 1;
}

/* Hidden by default */
#syncChangesSection {
  display: none;
}

/**
 * Import Changes Diff Styles
 *
 * Styles for the import preview diff UI.
 * Extends sync-changes.css patterns.
 */

/* Import-specific styles */
.import-changes {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: calc(100% - 32px);
  max-width: 480px;
  max-height: calc(100% - 64px);
  overflow-y: auto;
  z-index: 1000;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.25);
}

.import-changes-section {
  display: none;
}

.import-changes-section::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
}

/* Header subtitle */
.changes-header .subtitle {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  font-weight: normal;
  margin-top: 4px;
}

.changes-header {
  flex-wrap: wrap;
}

/* Version comparison */
.version-comparison {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  padding: 12px;
  background: var(--figma-color-bg-secondary);
  border-radius: 6px;
  margin-bottom: 16px;
}

.version-comparison .label {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
}

.version-comparison .arrow {
  font-size: 14px;
  color: var(--figma-color-text-tertiary);
}

.version-badge {
  font-family: 'SF Mono', Monaco, 'Courier New', monospace;
  font-size: 12px;
  font-weight: 600;
  padding: 4px 8px;
  border-radius: 4px;
}

.version-badge.current {
  background: var(--figma-color-bg-tertiary);
  color: var(--figma-color-text-secondary);
}

.version-badge.importing {
  background: var(--figma-color-bg-brand-tertiary, #e8f0fe);
  color: var(--figma-color-text-brand);
}

/* No changes state */
.no-changes {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 24px 16px;
  background: var(--figma-color-bg-success-secondary, #e6f4ea);
  border-radius: 6px;
  color: var(--figma-color-text-success, #137333);
}

.no-changes .icon {
  font-size: 24px;
}

/* Import summary */
.import-summary {
  display: flex;
  gap: 16px;
  padding: 12px;
  background: var(--figma-color-bg-secondary);
  border-radius: 6px;
  margin-top: 16px;
}

.summary-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex: 1;
}

.summary-item .count {
  font-size: 20px;
  font-weight: 600;
  color: var(--figma-color-text);
}

.summary-item .label {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  text-transform: uppercase;
}

/* Change path and values */
.change-item {
  display: flex;
  flex-direction: column;
  gap: 4px;
  padding: 6px 0;
  border-bottom: 1px solid var(--figma-color-border);
}

.change-item:last-child {
  border-bottom: none;
}

.change-path {
  font-family: 'SF Mono', Monaco, 'Courier New', monospace;
  font-size: 11px;
  color: var(--figma-color-text);
  font-weight: 500;
}

.change-values {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 10px;
}

.change-values .before {
  color: var(--figma-color-text-danger, #c5221f);
  text-decoration: line-through;
}

.change-values .after {
  color: var(--figma-color-text-success, #137333);
}

.change-values .arrow {
  color: var(--figma-color-text-tertiary);
}

.change-values .new {
  background: var(--figma-color-bg-success-secondary, #e6f4ea);
  padding: 2px 6px;
  border-radius: 3px;
}

.change-values .removed {
  background: var(--figma-color-bg-danger-secondary, #fee);
  padding: 2px 6px;
  border-radius: 3px;
}

/* Section description */
.section-desc {
  font-weight: normal;
  color: var(--figma-color-text-secondary);
  margin-left: 4px;
}

/* Import actions */
.import-actions {
  position: sticky;
  bottom: 0;
  background: var(--figma-color-bg);
  padding-top: 16px;
  margin-top: 0;
}

/* Hidden by default */
#importChangesSection {
  display: none;
}

#importChangesSection[style*="display: block"] {
  display: block;
}

/**
 * Structure Preview Styles
 *
 * Tree view with collapsible levels, key badges, and sample values
 */

.structure-preview {
  background: var(--figma-color-bg-secondary);
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  padding: 16px;
  margin: 16px 0;
}

.structure-header {
  margin-bottom: 12px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--figma-color-border);
}

.structure-header h3 {
  margin: 0 0 4px 0;
  font-size: 14px;
  font-weight: 600;
  color: var(--figma-color-text);
}

.structure-meta {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
}

.structure-meta strong {
  color: var(--figma-color-text);
  font-weight: 500;
}

/* Tree structure */
.structure-tree {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.structure-level {
  background: var(--figma-color-bg);
  border: 1px solid var(--figma-color-border);
  border-radius: 4px;
  overflow: hidden;
}

/* Level header (clickable) */
.level-header {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  cursor: pointer;
  user-select: none;
  transition: background-color 0.15s ease;
}

.level-header:hover {
  background: var(--figma-color-bg-hover);
}

.level-toggle {
  width: 12px;
  text-align: center;
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  transition: transform 0.15s ease;
}

.level-toggle.expanded {
  transform: rotate(0deg);
}

.level-toggle.collapsed {
  transform: rotate(-90deg);
}

.level-label {
  font-size: 12px;
  font-weight: 600;
  color: var(--figma-color-text);
}

.level-count {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  margin-left: auto;
}

/* Level content (collapsible) */
.level-content {
  padding: 12px;
  border-top: 1px solid var(--figma-color-border);
  display: block;
  animation: slideDown 0.15s ease;
}

.level-content.hidden {
  display: none;
}

@keyframes slideDown {
  from {
    opacity: 0;
    max-height: 0;
  }
  to {
    opacity: 1;
    max-height: 500px;
  }
}

/* Keys display */
.level-keys {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 12px;
}

.key-badge {
  display: inline-block;
  padding: 4px 8px;
  background: var(--figma-color-bg-brand);
  color: var(--figma-color-text-onbrand);
  border-radius: 3px;
  font-size: 11px;
  font-family: monospace;
  font-weight: 500;
}

.key-badge.more {
  background: var(--figma-color-bg-disabled);
  color: var(--figma-color-text-disabled);
}

/* Sample values */
.level-samples {
  margin-top: 8px;
  padding-top: 8px;
  border-top: 1px solid var(--figma-color-border);
}

.samples-label {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  margin-bottom: 6px;
  font-weight: 500;
}

.sample-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 0;
  font-size: 11px;
  font-family: monospace;
}

.sample-path {
  color: var(--figma-color-text-secondary);
}

.sample-separator {
  color: var(--figma-color-text-tertiary);
}

.sample-value {
  color: var(--figma-color-text);
  font-weight: 500;
}

.sample-value.string {
  color: #10B981;
}

.sample-value.number {
  color: #3B82F6;
}

.sample-value.boolean {
  color: #F59E0B;
}

.sample-value.object,
.sample-value.array {
  color: var(--figma-color-text-secondary);
  font-style: italic;
}

/* Footer */
.structure-footer {
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--figma-color-border);
}

.info-text {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
}

.info-text strong {
  color: var(--figma-color-text);
  font-weight: 500;
}

/* Indentation for nested display (optional enhancement) */
.structure-level[data-depth="1"] .level-header {
  padding-left: 12px;
}

.structure-level[data-depth="2"] .level-header {
  padding-left: 16px;
}

.structure-level[data-depth="3"] .level-header {
  padding-left: 20px;
}

.structure-level[data-depth="4"] .level-header {
  padding-left: 24px;
}

.structure-level[data-depth="5"] .level-header {
  padding-left: 28px;
}

/**
 * Level Selector Component Styles
 * Radio buttons for configuring JSON level mapping
 */

.level-selector {
  background: var(--figma-color-bg);
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  padding: 16px;
  margin: 16px 0;
}

.level-selector-header {
  margin-bottom: 16px;
}

.level-selector-header .section-title {
  font-size: 13px;
  font-weight: 600;
  color: var(--figma-color-text);
  margin-bottom: 4px;
}

.level-selector-header .section-description {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  line-height: 1.4;
}

.level-selector-levels {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 16px;
}

/* Individual level option */
.level-option {
  background: var(--figma-color-bg-secondary);
  border: 1px solid var(--figma-color-border);
  border-radius: 6px;
  padding: 12px;
}

.level-option-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.level-label {
  font-size: 11px;
  font-weight: 600;
  color: var(--figma-color-text);
}

.level-key-count {
  font-size: 10px;
  color: var(--figma-color-text-tertiary);
  background: var(--figma-color-bg);
  padding: 2px 6px;
  border-radius: 3px;
}

.level-option-keys {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  font-family: 'SF Mono', Monaco, 'Courier New', monospace;
  margin-bottom: 10px;
  padding: 6px 8px;
  background: var(--figma-color-bg);
  border-radius: 4px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* Radio button group */
.level-option-radios {
  display: flex;
  gap: 12px;
  align-items: center;
}

.radio-label {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: var(--figma-color-text);
  cursor: pointer;
  transition: opacity 0.15s ease;
}

.radio-label:hover:not(.disabled) {
  color: var(--figma-color-text-brand);
}

.radio-label.disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.radio-label input[type="radio"] {
  width: 14px;
  height: 14px;
  margin: 0;
  cursor: pointer;
  accent-color: var(--figma-color-bg-brand);
}

.radio-label.disabled input[type="radio"] {
  cursor: not-allowed;
}

/* Validation messages */
.level-selector-validation {
  margin-top: 12px;
}

.validation-error,
.validation-warning {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  border-radius: 6px;
  font-size: 11px;
  line-height: 1.4;
}

.validation-error {
  background: var(--figma-color-bg-danger-tertiary, #fee);
  color: var(--figma-color-text-danger, #c00);
  border: 1px solid var(--figma-color-border-danger, #fcc);
}

.validation-error svg {
  flex-shrink: 0;
  color: var(--figma-color-icon-danger, #c00);
}

.validation-warning {
  background: var(--figma-color-bg-warning-tertiary, #fffbf0);
  color: var(--figma-color-text-warning, #b87900);
  border: 1px solid var(--figma-color-border-warning, #ffe4a0);
}

.validation-warning svg {
  flex-shrink: 0;
  color: var(--figma-color-icon-warning, #b87900);
}

/* Responsive adjustments */
@media (max-width: 400px) {
  .level-option-radios {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }
}

/* Compact mode for multi-collection cards */
.level-selector-compact {
  background: transparent;
  border: none;
  padding: 0;
  margin: 0;
}

.level-selector-compact .level-selector-levels {
  gap: 8px;
  margin-bottom: 8px;
}

.level-selector-compact .level-option {
  padding: 8px 10px;
}

.level-selector-compact .level-option-header {
  margin-bottom: 4px;
}

.level-selector-compact .level-option-keys {
  margin-bottom: 6px;
}

.level-selector-compact .level-option-radios {
  gap: 12px;
}

.level-selector-compact .level-selector-validation {
  margin-top: 8px;
}

/**
 * File Grouping Component Styles
 * Drag-and-drop file organization into collection groups
 */

/* Main container */
.file-grouping {
  padding: 16px 0;
}

/* Groups container */
.groups-container {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 12px;
}

/* Group card */
.group-card {
  border: 1px solid var(--figma-color-border);
  border-radius: 8px;
  padding: 12px;
  background: var(--figma-color-bg);
  transition: all 0.15s ease;
}

.group-card:hover {
  border-color: var(--figma-color-border-strong);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

/* Group header */
.group-header {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
}

.group-icon {
  font-size: 18px;
  flex-shrink: 0;
}

.group-name-input {
  flex: 1;
  padding: 6px 8px;
  border: 1px solid var(--figma-color-border);
  border-radius: 4px;
  background: var(--figma-color-bg);
  color: var(--figma-color-text);
  font-size: 12px;
  font-weight: 500;
  outline: none;
}

.group-name-input:focus {
  border-color: var(--figma-color-border-brand);
  box-shadow: 0 0 0 1px var(--figma-color-border-brand);
}

/* Group files container (drop zone) */
.group-files {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding: 8px;
  background: var(--figma-color-bg-secondary);
  border-radius: 6px;
  min-height: 60px;
  transition: all 0.2s ease;
  border: 2px dashed transparent;
}

.group-files.drop-zone-active {
  border-color: var(--figma-color-border-brand);
  background: var(--figma-color-bg-brand-tertiary);
}

.group-files:empty::before {
  content: 'Drag files here';
  display: block;
  text-align: center;
  color: var(--figma-color-text-tertiary);
  font-size: 11px;
  padding: 16px 0;
}

/* File card (draggable) */
.file-card {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  background: var(--figma-color-bg);
  border: 1px solid var(--figma-color-border);
  border-radius: 4px;
  cursor: grab;
  transition: all 0.15s ease;
  user-select: none;
}

.file-card:hover {
  background: var(--figma-color-bg-hover);
  border-color: var(--figma-color-border-strong);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.file-card:active {
  cursor: grabbing;
}

.file-card.dragging {
  opacity: 0.5;
  cursor: grabbing;
}

.file-card-icon {
  font-size: 16px;
  flex-shrink: 0;
}

.file-card-info {
  flex: 1;
  min-width: 0;
}

.file-card-name {
  font-size: 11px;
  font-weight: 500;
  color: var(--figma-color-text);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.file-card-size {
  font-size: 10px;
  color: var(--figma-color-text-tertiary);
  margin-top: 2px;
}

.file-card-drag-handle {
  font-size: 14px;
  color: var(--figma-color-text-tertiary);
  flex-shrink: 0;
  cursor: grab;
}

.file-card:active .file-card-drag-handle {
  cursor: grabbing;
}

/* Mode options */
.mode-options {
  margin-top: 12px;
  padding: 12px;
  background: var(--figma-color-bg-secondary);
  border-radius: 6px;
  border: 1px solid var(--figma-color-border);
}

.mode-options-title {
  font-size: 11px;
  font-weight: 500;
  color: var(--figma-color-text);
  margin-bottom: 10px;
}

/* Mode option radio */
.mode-option {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  padding: 10px 12px;
  margin-bottom: 8px;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s ease;
  background: var(--figma-color-bg);
  border: 1px solid var(--figma-color-border);
  position: relative;
}

.mode-option:hover {
  background: var(--figma-color-bg-hover);
  border-color: var(--figma-color-border-selected);
}

.mode-option.selected {
  border-color: var(--figma-color-bg-brand);
  background: var(--figma-color-bg-brand-tertiary, rgba(24, 160, 251, 0.08));
}

.mode-option:last-of-type {
  margin-bottom: 0;
}

.mode-option input[type="radio"] {
  position: absolute;
  opacity: 0;
  pointer-events: none;
}

.mode-option .radio-indicator {
  width: 16px;
  height: 16px;
  border: 2px solid var(--figma-color-border);
  border-radius: 50%;
  flex-shrink: 0;
  position: relative;
  transition: all 0.15s ease;
  margin-top: 1px;
}

.mode-option.selected .radio-indicator {
  border-color: var(--figma-color-bg-brand);
}

.mode-option .radio-indicator::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%) scale(0);
  width: 8px;
  height: 8px;
  background: var(--figma-color-bg-brand);
  border-radius: 50%;
  transition: transform 0.15s ease;
}

.mode-option.selected .radio-indicator::after {
  transform: translate(-50%, -50%) scale(1);
}

.mode-option-content {
  flex: 1;
}

.mode-option-label {
  font-size: 11px;
  font-weight: 500;
  color: var(--figma-color-text);
  margin-bottom: 2px;
}

.mode-option-description {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
}

/* Mode names list */
.mode-names-list {
  margin: 10px 0 10px 26px;
  padding: 10px 12px;
  background: var(--figma-color-bg);
  border-radius: 4px;
  border: 1px solid var(--figma-color-border);
}

.mode-names-label {
  font-size: 10px;
  font-weight: 500;
  color: var(--figma-color-text-secondary);
  margin-bottom: 8px;
}

.mode-name-item {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.mode-name-item:last-child {
  margin-bottom: 0;
}

.mode-name-file {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  white-space: nowrap;
  font-family: 'SF Mono', Monaco, 'Courier New', monospace;
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
}

.mode-name-arrow {
  font-size: 10px;
  color: var(--figma-color-text-tertiary);
  flex-shrink: 0;
}

.mode-name-input {
  width: 80px;
  padding: 4px 6px;
  border: 1px solid var(--figma-color-border);
  border-radius: 3px;
  background: var(--figma-color-bg);
  color: var(--figma-color-text);
  font-size: 11px;
  outline: none;
  flex-shrink: 0;
}

.mode-name-input:focus {
  border-color: var(--figma-color-border-brand);
  box-shadow: 0 0 0 1px var(--figma-color-border-brand);
}

/* Actions */
.grouping-actions {
  margin-top: 16px;
  display: flex;
  gap: 8px;
}

.grouping-actions .button {
  flex: 1;
}

/* Create new collection button */
.button-add {
  width: 100%;
  padding: 10px;
  background: transparent;
  color: var(--figma-color-text-secondary);
  border: 1px dashed var(--figma-color-border);
  border-radius: 6px;
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s ease;
}

.button-add:hover {
  background: var(--figma-color-bg-hover);
  color: var(--figma-color-text);
  border-color: var(--figma-color-border-strong);
}

/* Empty state */
.groups-container:empty::before {
  content: 'No collections yet. Click "Create New Collection" to get started.';
  display: block;
  text-align: center;
  color: var(--figma-color-text-tertiary);
  font-size: 11px;
  padding: 32px 16px;
  border: 1px dashed var(--figma-color-border);
  border-radius: 6px;
  background: var(--figma-color-bg-secondary);
}

/* Responsive adjustments */
@media (max-width: 400px) {
  .file-card {
    padding: 6px 8px;
  }

  .file-card-name {
    font-size: 10px;
  }

  .mode-names-list {
    margin-left: 16px;
  }
}

/**
 * Live Preview Styles
 *
 * Tree structure for displaying import preview with collections,
 * modes, and variables.
 */

/* Preview container */
#live-preview {
  margin-top: 24px;
  padding: 16px;
  background: var(--figma-color-bg-secondary);
  border-radius: 4px;
  display: none; /* Hidden by default, shown when preview is rendered */
}

/* Preview header */
.preview-header {
  margin-bottom: 16px;
}

.preview-header h3 {
  font-size: 13px;
  font-weight: 600;
  margin: 0 0 4px 0;
  color: var(--figma-color-text);
}

.preview-description {
  font-size: 11px;
  color: var(--figma-color-text-secondary);
  margin: 0;
}

/* Tree container */
.preview-tree {
  margin: 12px 0;
  font-family: 'Roboto Mono', monospace;
  font-size: 11px;
  line-height: 1.6;
}

/* Collection */
.preview-collection {
  margin-bottom: 12px;
}

.collection-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  cursor: pointer;
  border-radius: 3px;
  transition: background 0.15s ease;
}

.collection-header:hover {
  background: var(--figma-color-bg-hover);
}

.expand-icon {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  width: 12px;
  display: inline-block;
  text-align: center;
}

.collection-icon {
  font-size: 14px;
}

.collection-name {
  font-weight: 600;
  color: var(--figma-color-text);
  flex: 1;
}

.collection-count {
  font-size: 10px;
  color: var(--figma-color-text-secondary);
  font-style: italic;
}

/* Modes container */
.modes-container {
  margin-left: 20px;
  margin-top: 4px;
  transition: all 0.2s ease;
}

/* Mode */
.preview-mode {
  margin: 8px 0;
}

.mode-header {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 0;
}

.mode-indent {
  color: var(--figma-color-text-disabled);
  font-size: 11px;
  margin-right: 2px;
}

.mode-icon {
  font-size: 13px;
}

.mode-name {
  color: var(--figma-color-text);
  font-weight: 500;
}

.default-badge {
  display: inline-block;
  padding: 2px 6px;
  background: var(--figma-color-bg-warning);
  color: var(--figma-color-text);
  border-radius: 3px;
  font-size: 9px;
  font-weight: 500;
  margin-left: 6px;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

/* Variables */
.mode-variables {
  margin-left: 20px;
  margin-top: 4px;
  padding: 4px 0;
}

.var-indent {
  color: var(--figma-color-text-disabled);
  font-size: 11px;
  margin-right: 6px;
}

.var-samples {
  color: var(--figma-color-text-secondary);
  font-size: 10px;
}

.var-count {
  color: var(--figma-color-text-tertiary);
  font-size: 10px;
  margin-left: 26px;
  margin-top: 2px;
}

/* Summary */
.preview-summary {
  margin-top: 16px;
  padding-top: 12px;
}

.summary-line {
  width: 100%;
  height: 1px;
  background: var(--figma-color-border);
  margin-bottom: 8px;
}

.summary-counts {
  text-align: center;
  color: var(--figma-color-text-secondary);
  font-size: 11px;
  font-weight: 500;
}

/* Warning state for default modes */
.preview-collection:has(.default-badge) .collection-header {
  border-left: 3px solid var(--figma-color-border-warning);
  padding-left: 5px;
}

/* Empty state */
.preview-empty {
  padding: 24px;
  text-align: center;
  color: var(--figma-color-text-disabled);
  font-size: 11px;
}

/* Responsive adjustments */
@media (max-width: 400px) {
  .preview-tree {
    font-size: 10px;
  }

  .mode-variables {
    margin-left: 12px;
  }
}


  </style>
</head>
<body>
  <!-- Segmented Control -->
  <div class="segmented-control" role="tablist">
    <button class="active" data-tab="import" role="tab" aria-selected="true">Import</button>
    <button data-tab="export" role="tab" aria-selected="false">Export JSON</button>
    <button data-tab="sync" role="tab" aria-selected="false">Sync to Node</button>
  </div>

  <!-- IMPORT TAB -->
  <div id="tab-import" class="tab-panel active">
    <div class="section">
      <div class="section-title">1. Upload Token Files</div>
      <div class="file-upload" id="dropZone">
        <div class="file-upload-icon">üìÅ</div>
        <div>Drop JSON files here or click to browse</div>
      </div>
      <input type="file" id="fileInput" accept=".json" multiple>
      <div class="file-list" id="fileList"></div>
    </div>

    <!-- Baseline Confirmation Section (hidden by default) -->
    <div id="baselineConfirmationSection" style="display: none;"></div>

    <!-- NEW: Structure Preview Section (hidden by default) -->
    <div id="structurePreviewSection" style="display: none;"></div>

    <!-- NEW: File Grouping Section (hidden by default, shown for multi-file imports) -->
    <div id="fileGroupingSection" style="display: none;">
      <div id="fileGroupingContainer"></div>
    </div>

    <!-- NEW: Multi-Collection Configuration Section (hidden by default, for multi-file imports) -->
    <div id="multiCollectionConfigSection" style="display: none;"></div>

    <!-- NEW: Level Selector Section (hidden by default, for single-file imports) -->
    <div id="levelSelectorSection" style="display: none;">
      <div id="levelSelectorContainer"></div>
    </div>

    <!-- NEW: Live Preview Section (hidden by default) -->
    <div id="livePreviewSection" style="display: none;">
      <div id="live-preview"></div>
    </div>
  </div>

  <!-- EXPORT JSON TAB -->
  <div id="tab-export" class="tab-panel">
    <div class="section">
      <div class="section-title">Export Variables as JSON</div>
      <div class="section-description">Select which collections to include in the export.</div>

      <div class="selection-controls">
        <button class="button button-ghost" id="exportSelectAll">Select All</button>
        <button class="button button-ghost" id="exportSelectNone">Select None</button>
      </div>

      <div id="exportCollectionList" class="collection-list">
        <div class="loading">
          <div class="spinner"></div>
          Loading collections...
        </div>
      </div>

      <div class="info-box">
        <div class="info-box-title">Export Format</div>
        <div class="info-box-text">
          Exports all selected variables as a baseline-snapshot.json file with nested token structure and flat baseline lookup.
        </div>
      </div>
    </div>
  </div>

  <!-- SYNC TO NODE TAB -->
  <div id="tab-sync" class="tab-panel">
    <div class="section">
      <div class="section-title">Sync to Node</div>
      <div class="section-description">Store variables in a hidden node for access via Figma REST API.</div>

      <div class="selection-controls">
        <button class="button button-ghost" id="syncSelectAll">Select All</button>
        <button class="button button-ghost" id="syncSelectNone">Select None</button>
      </div>

      <div id="syncCollectionList" class="collection-list">
        <div class="loading">
          <div class="spinner"></div>
          Loading collections...
        </div>
      </div>

      <!-- Last Sync Info -->
      <div id="lastSyncInfo" class="info-box" style="display: none; margin-bottom: 12px;">
        <div class="info-box-title" style="display: flex; align-items: center; gap: 6px;">
          <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="color: var(--figma-color-icon-success, #1e8e3e);">
            <polyline points="20 6 9 17 4 12"></polyline>
          </svg>
          Last Sync
        </div>
        <div class="info-box-text" style="margin-top: 8px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
            <span>Node ID:</span>
            <span id="lastSyncNodeId" style="font-family: 'SF Mono', Monaco, monospace; cursor: pointer;" title="Click to copy">--</span>
          </div>
          <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
            <span>Variables:</span>
            <span id="lastSyncVariables">--</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span>Synced:</span>
            <span id="lastSyncTime">--</span>
          </div>
        </div>
      </div>

      <!-- Sync Changes Section (hidden by default) -->
      <div id="syncChangesSection" style="display: none;"></div>

      <!-- Check for Changes Button -->
      <div class="sync-actions" style="margin-bottom: 12px;">
        <button id="checkChangesBtn" class="button button-secondary" style="width: 100%;">
          Check for Changes
        </button>
      </div>

      <div class="info-box">
        <div class="info-box-title">How it works</div>
        <div class="info-box-text">
          Creates a hidden frame (_token_registry) that stores variable data as sharedPluginData. This data can then be fetched via the Figma REST API without needing Variables API access.
        </div>
      </div>
    </div>

    <!-- Sync Success Screen -->
    <div id="syncSuccessScreen" class="success-screen">
      <div class="success-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
      </div>
      <div class="success-title">Sync Complete</div>
      <div class="success-description">
        Your variables have been synced to a hidden node and can now be accessed via the Figma REST API.
      </div>

      <div class="node-preview">
        <div class="node-preview-icon">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          </svg>
        </div>
        <div class="node-preview-info">
          <div class="node-preview-name">_token_registry</div>
          <div class="node-preview-type">Hidden Frame</div>
        </div>
      </div>

      <div class="success-details">
        <div class="success-detail-row">
          <span class="success-detail-label">Node ID</span>
          <span class="success-detail-value copyable" id="syncNodeIdValue" title="Click to copy">
            <span class="node-id-text">--</span>
            <svg class="copy-icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
          </span>
        </div>
        <div class="success-detail-row">
          <span class="success-detail-label">Variables Synced</span>
          <span class="success-detail-value" id="syncVariableCount">--</span>
        </div>
        <div class="success-detail-row">
          <span class="success-detail-label">Synced At</span>
          <span class="success-detail-value" id="syncTimestamp">--</span>
        </div>
      </div>

      <div class="copy-hint">Click the Node ID to copy it to clipboard</div>

      <div class="success-actions">
        <button class="button button-secondary" id="syncAgainBtn">Sync Again</button>
        <button class="button button-primary" id="closeSyncSuccessBtn">Done</button>
      </div>
    </div>
  </div>

  <!-- Action Footer -->
  <div class="action-footer">
    <button class="button button-secondary" id="cancelBtn">Cancel</button>
    <button class="button button-primary" id="actionBtn" disabled>Import to Figma</button>
  </div>

  
<script>
"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

  // src/ui/state.ts
  var initialState = {
    files: /* @__PURE__ */ new Map(),
    collections: [],
    currentTab: "import",
    figmaCollections: [],
    selectedExportCollections: /* @__PURE__ */ new Set(),
    selectedSyncCollections: /* @__PURE__ */ new Set()
  };
  var state = __spreadValues({}, initialState);
  var listeners = /* @__PURE__ */ new Set();
  function getState() {
    return state;
  }
  function setState(updates) {
    state = __spreadValues(__spreadValues({}, state), updates);
    notifyListeners();
  }
  function setImportStep(step) {
    setState({ currentImportStep: step });
  }
  function setFileGroups(groups) {
    setState({ fileGroups: groups });
  }
  function setStructureConfig(config) {
    setState({ structureConfig: config });
  }
  function updateLevelConfiguration(levels) {
    const currentConfig = state.structureConfig;
    if (currentConfig) {
      setState({
        structureConfig: __spreadProps(__spreadValues({}, currentConfig), {
          levels
        })
      });
    }
  }
  function notifyListeners() {
    listeners.forEach((listener) => listener(state));
  }

  // src/ui/message-bridge.ts
  function sendMessage(message) {
    parent.postMessage({ pluginMessage: message }, "*");
  }
  function onMessage(handler) {
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (msg) {
        handler(msg);
      }
    };
  }

  // src/ui/components/success-screen.ts
  function showSyncSuccess(nodeId, variableCount) {
    const successScreen = document.getElementById("syncSuccessScreen");
    if (successScreen) {
      successScreen.classList.add("active");
    }
    const nodeIdText = document.querySelector("#syncNodeIdValue .node-id-text");
    if (nodeIdText) {
      nodeIdText.textContent = nodeId;
    }
    const variableCountEl = document.getElementById("syncVariableCount");
    if (variableCountEl) {
      variableCountEl.textContent = variableCount.toLocaleString();
    }
    const timestampEl = document.getElementById("syncTimestamp");
    if (timestampEl) {
      timestampEl.textContent = (/* @__PURE__ */ new Date()).toLocaleTimeString();
    }
    const actionFooter = document.querySelector(".action-footer");
    if (actionFooter) {
      actionFooter.classList.add("hidden");
    }
  }
  function hideSyncSuccess() {
    resetSyncSuccessScreen();
    const actionFooter = document.querySelector(".action-footer");
    if (actionFooter) {
      actionFooter.classList.remove("hidden");
    }
  }
  function resetSyncSuccessScreen() {
    const successScreen = document.getElementById("syncSuccessScreen");
    if (successScreen) {
      successScreen.classList.remove("active");
    }
  }
  function initSyncSuccessScreen() {
    const syncNodeIdValue = document.getElementById("syncNodeIdValue");
    if (syncNodeIdValue) {
      syncNodeIdValue.addEventListener("click", function() {
        const nodeIdEl = this.querySelector(".node-id-text");
        const nodeId = nodeIdEl == null ? void 0 : nodeIdEl.textContent;
        if (nodeId && nodeId !== "--") {
          navigator.clipboard.writeText(nodeId).then(() => {
            const original = nodeId;
            if (nodeIdEl) {
              nodeIdEl.textContent = "Copied!";
              setTimeout(() => {
                nodeIdEl.textContent = original;
              }, 1500);
            }
          });
        }
      });
    }
    const syncAgainBtn = document.getElementById("syncAgainBtn");
    if (syncAgainBtn) {
      syncAgainBtn.addEventListener("click", () => {
        hideSyncSuccess();
      });
    }
    const closeSyncSuccessBtn = document.getElementById("closeSyncSuccessBtn");
    if (closeSyncSuccessBtn) {
      closeSyncSuccessBtn.addEventListener("click", () => {
        parent.postMessage({ pluginMessage: { type: "cancel" } }, "*");
      });
    }
  }

  // src/ui/components/tabs.ts
  function initTabs(options = {}) {
    const tabButtons = document.querySelectorAll(".segmented-control button");
    const tabPanels = document.querySelectorAll(".tab-panel");
    tabButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const tab = btn.dataset.tab;
        if (tab) {
          switchTab(tab, options);
        }
      });
    });
    const state2 = getState();
    updateTabUI(state2.currentTab, tabButtons, tabPanels);
  }
  function switchTab(tab, options = {}) {
    var _a;
    setState({ currentTab: tab });
    const tabButtons = document.querySelectorAll(".segmented-control button");
    const tabPanels = document.querySelectorAll(".tab-panel");
    updateTabUI(tab, tabButtons, tabPanels);
    if (tab !== "sync") {
      resetSyncSuccessScreen();
    }
    updateActionButton();
    if (tab === "export" || tab === "sync") {
      sendMessage({ type: "get-collections" });
    }
    if (tab === "sync") {
      sendMessage({ type: "get-last-sync" });
    }
    (_a = options.onTabChange) == null ? void 0 : _a.call(options, tab);
  }
  function updateTabUI(tab, tabButtons, tabPanels) {
    tabButtons.forEach((btn) => {
      const isActive = btn.dataset.tab === tab;
      btn.classList.toggle("active", isActive);
      btn.setAttribute("aria-selected", String(isActive));
    });
    tabPanels.forEach((panel) => {
      panel.classList.toggle("active", panel.id === `tab-${tab}`);
    });
  }
  function updateActionButton() {
    const state2 = getState();
    const actionBtn = document.getElementById("actionBtn");
    if (!actionBtn)
      return;
    switch (state2.currentTab) {
      case "import":
        actionBtn.textContent = "Import to Figma";
        const hasFiles = state2.files.size > 0;
        if (state2.structureConfig && state2.structureConfig.levels.length > 0) {
          actionBtn.disabled = !hasFiles;
        } else {
          const hasCollections = state2.collections.length > 0;
          const allCollectionsHaveFiles = state2.collections.every((c) => c.fileNames.length > 0);
          actionBtn.disabled = !(hasFiles && hasCollections && allCollectionsHaveFiles);
        }
        break;
      case "export":
        actionBtn.textContent = "Export JSON";
        actionBtn.disabled = state2.selectedExportCollections.size === 0;
        break;
      case "sync":
        actionBtn.textContent = "Sync to Node";
        actionBtn.disabled = state2.selectedSyncCollections.size === 0;
        break;
    }
  }

  // src/ui/utils/format.ts
  function formatFileSize(bytes) {
    if (bytes < 1024) {
      return `${bytes} B`;
    }
    const kb = bytes / 1024;
    if (kb < 1024) {
      return `${kb.toFixed(1)} KB`;
    }
    const mb = kb / 1024;
    return `${mb.toFixed(1)} MB`;
  }
  function formatDate(date) {
    const d = typeof date === "string" ? new Date(date) : date;
    return d.toLocaleDateString();
  }
  function formatTimeAgo(date) {
    const d = typeof date === "string" ? new Date(date) : date;
    const now = /* @__PURE__ */ new Date();
    const diffMs = now.getTime() - d.getTime();
    const diffMins = Math.floor(diffMs / 6e4);
    const diffHours = Math.floor(diffMs / 36e5);
    const diffDays = Math.floor(diffMs / 864e5);
    if (diffMins < 1) {
      return "Just now";
    } else if (diffMins < 60) {
      return `${diffMins} min${diffMins !== 1 ? "s" : ""} ago`;
    } else if (diffHours < 24) {
      return `${diffHours} hour${diffHours !== 1 ? "s" : ""} ago`;
    } else if (diffDays < 7) {
      return `${diffDays} day${diffDays !== 1 ? "s" : ""} ago`;
    } else {
      return formatDate(d);
    }
  }

  // src/ui/components/file-upload.ts
  function initFileUpload(options = {}) {
    const dropZone = document.getElementById("dropZone");
    const fileInput = document.getElementById("fileInput");
    const fileList = document.getElementById("fileList");
    if (!dropZone || !fileInput || !fileList) {
      console.error("File upload: Required elements not found");
      return;
    }
    dropZone.addEventListener("click", () => fileInput.click());
    dropZone.addEventListener("dragover", (e) => {
      e.preventDefault();
      dropZone.classList.add("dragover");
    });
    dropZone.addEventListener("dragleave", () => {
      dropZone.classList.remove("dragover");
    });
    dropZone.addEventListener("drop", (e) => {
      var _a;
      e.preventDefault();
      dropZone.classList.remove("dragover");
      if ((_a = e.dataTransfer) == null ? void 0 : _a.files) {
        handleFiles(e.dataTransfer.files, options);
      }
    });
    fileInput.addEventListener("change", (e) => {
      const target = e.target;
      if (target.files) {
        handleFiles(target.files, options);
      }
    });
    renderFileList(options);
  }
  async function handleFiles(fileList, options) {
    var _a, _b;
    const state2 = getState();
    for (const file of Array.from(fileList)) {
      if (file.type === "application/json" || file.name.endsWith(".json")) {
        try {
          const text = await file.text();
          const data = JSON.parse(text);
          const fileName = file.name.replace(".json", "");
          state2.files.set(fileName, {
            name: fileName,
            content: data,
            size: file.size
          });
          const isBaseline = data && typeof data === "object" && "$metadata" in data && "baseline" in data;
          if (isBaseline) {
            console.log("[FileUpload] Baseline file detected, sending detection request for:", fileName);
            sendMessage({
              type: "detect-import-format",
              fileName,
              jsonData: data
            });
          } else {
            console.log("[FileUpload] Regular token file, will use flexible import for:", fileName);
          }
        } catch (e) {
          const errorMessage = e instanceof Error ? e.message : "Unknown error";
          (_a = options.onError) == null ? void 0 : _a.call(options, file.name, errorMessage);
          showNotification(`Error parsing ${file.name}: ${errorMessage}`, "error");
        }
      }
    }
    setState({ files: state2.files });
    renderFileList(options);
    updateActionButton();
    (_b = options.onFilesChanged) == null ? void 0 : _b.call(options, state2.files);
  }
  function renderFileList(options = {}) {
    const fileListEl = document.getElementById("fileList");
    if (!fileListEl)
      return;
    const state2 = getState();
    fileListEl.innerHTML = "";
    state2.files.forEach((file, name) => {
      const item = document.createElement("div");
      item.className = "file-item";
      item.innerHTML = `
      <div class="file-info">
        <span class="file-name">${escapeHtml(file.name)}</span>
        <span class="file-size">${formatFileSize(file.size)}</span>
      </div>
      <button class="button button-ghost" data-file="${escapeHtml(name)}" aria-label="Remove ${escapeHtml(file.name)}">\u2715</button>
    `;
      fileListEl.appendChild(item);
      const removeBtn = item.querySelector("button");
      removeBtn == null ? void 0 : removeBtn.addEventListener("click", (e) => {
        const fileName = e.target.dataset.file;
        if (fileName) {
          removeFile(fileName, options);
        }
      });
    });
  }
  function removeFile(fileName, options) {
    var _a;
    const state2 = getState();
    state2.files.delete(fileName);
    setState({ files: state2.files });
    renderFileList(options);
    updateActionButton();
    (_a = options.onFilesChanged) == null ? void 0 : _a.call(options, state2.files);
    const renderCollectionsEvent = new CustomEvent("render-collections");
    document.dispatchEvent(renderCollectionsEvent);
  }
  function escapeHtml(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }
  function showNotification(message, type) {
    console[type === "error" ? "error" : "log"](message);
  }

  // src/ui/components/collection-list.ts
  function initCollectionLists(options = {}) {
    const exportSelectAll = document.getElementById("exportSelectAll");
    const exportSelectNone = document.getElementById("exportSelectNone");
    exportSelectAll == null ? void 0 : exportSelectAll.addEventListener("click", () => {
      var _a;
      selectAllExportCollections();
      (_a = options.onSelectionChanged) == null ? void 0 : _a.call(options, getState().selectedExportCollections);
    });
    exportSelectNone == null ? void 0 : exportSelectNone.addEventListener("click", () => {
      var _a;
      selectNoneExportCollections();
      (_a = options.onSelectionChanged) == null ? void 0 : _a.call(options, getState().selectedExportCollections);
    });
    const syncSelectAll = document.getElementById("syncSelectAll");
    const syncSelectNone = document.getElementById("syncSelectNone");
    syncSelectAll == null ? void 0 : syncSelectAll.addEventListener("click", () => {
      var _a;
      selectAllSyncCollections();
      (_a = options.onSelectionChanged) == null ? void 0 : _a.call(options, getState().selectedSyncCollections);
    });
    syncSelectNone == null ? void 0 : syncSelectNone.addEventListener("click", () => {
      var _a;
      selectNoneSyncCollections();
      (_a = options.onSelectionChanged) == null ? void 0 : _a.call(options, getState().selectedSyncCollections);
    });
  }
  function renderExportCollections(options = {}) {
    const container = document.getElementById("exportCollectionList");
    if (!container)
      return;
    const state2 = getState();
    if (state2.figmaCollections.length === 0) {
      container.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">\u{1F4ED}</div>
        <div>No variable collections found</div>
      </div>
    `;
      return;
    }
    container.innerHTML = state2.figmaCollections.map((col) => createCollectionListItem(col, state2.selectedExportCollections.has(col.id))).join("");
    container.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
      cb.addEventListener("change", (e) => {
        var _a;
        const target = e.target;
        const collectionId = target.dataset.id;
        if (!collectionId)
          return;
        if (target.checked) {
          state2.selectedExportCollections.add(collectionId);
        } else {
          state2.selectedExportCollections.delete(collectionId);
        }
        setState({ selectedExportCollections: state2.selectedExportCollections });
        updateActionButton();
        (_a = options.onSelectionChanged) == null ? void 0 : _a.call(options, state2.selectedExportCollections);
      });
    });
  }
  function renderSyncCollections(options = {}) {
    const container = document.getElementById("syncCollectionList");
    if (!container)
      return;
    const state2 = getState();
    if (state2.figmaCollections.length === 0) {
      container.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">\u{1F4ED}</div>
        <div>No variable collections found</div>
      </div>
    `;
      return;
    }
    container.innerHTML = state2.figmaCollections.map((col) => createCollectionListItem(col, state2.selectedSyncCollections.has(col.id))).join("");
    container.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
      cb.addEventListener("change", (e) => {
        var _a;
        const target = e.target;
        const collectionId = target.dataset.id;
        if (!collectionId)
          return;
        if (target.checked) {
          state2.selectedSyncCollections.add(collectionId);
        } else {
          state2.selectedSyncCollections.delete(collectionId);
        }
        setState({ selectedSyncCollections: state2.selectedSyncCollections });
        updateActionButton();
        (_a = options.onSelectionChanged) == null ? void 0 : _a.call(options, state2.selectedSyncCollections);
      });
    });
  }
  function createCollectionListItem(collection, isChecked) {
    const modeText = collection.modeCount !== 1 ? "s" : "";
    return `
    <label class="collection-list-item">
      <input
        type="checkbox"
        data-id="${escapeHtml2(collection.id)}"
        ${isChecked ? "checked" : ""}
        aria-label="Select ${escapeHtml2(collection.name)}"
      >
      <div class="collection-info">
        <div class="collection-name">${escapeHtml2(collection.name)}</div>
        <div class="collection-meta">${collection.variableCount.toLocaleString()} variables \xB7 ${collection.modeCount} mode${modeText}</div>
      </div>
    </label>
  `;
  }
  function selectAllExportCollections() {
    const state2 = getState();
    state2.figmaCollections.forEach((col) => state2.selectedExportCollections.add(col.id));
    setState({ selectedExportCollections: state2.selectedExportCollections });
    renderExportCollections();
    updateActionButton();
  }
  function selectNoneExportCollections() {
    const state2 = getState();
    state2.selectedExportCollections.clear();
    setState({ selectedExportCollections: state2.selectedExportCollections });
    renderExportCollections();
    updateActionButton();
  }
  function selectAllSyncCollections() {
    const state2 = getState();
    state2.figmaCollections.forEach((col) => state2.selectedSyncCollections.add(col.id));
    setState({ selectedSyncCollections: state2.selectedSyncCollections });
    renderSyncCollections();
    updateActionButton();
  }
  function selectNoneSyncCollections() {
    const state2 = getState();
    state2.selectedSyncCollections.clear();
    setState({ selectedSyncCollections: state2.selectedSyncCollections });
    renderSyncCollections();
    updateActionButton();
  }
  function escapeHtml2(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // src/ui/components/export-modal.ts
  function showExportModal(data) {
    const json = JSON.stringify(data, null, 2);
    const metadata = data == null ? void 0 : data.$metadata;
    const version = (metadata == null ? void 0 : metadata.version) || "1.0.0";
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10);
    const filename = `baseline-snapshot-v${version}-${timestamp}.json`;
    const modal = document.createElement("div");
    modal.style.cssText = "position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 16px;";
    const content = document.createElement("div");
    content.style.cssText = "background: var(--figma-color-bg); border-radius: 8px; padding: 16px; max-width: 100%; width: 100%; max-height: 90vh; display: flex; flex-direction: column;";
    content.innerHTML = `
    <div style="font-weight: 600; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
      <span style="color: var(--figma-color-icon-success, #1e8e3e);">\u2713</span>
      Export Complete
    </div>
    <div style="font-size: 11px; color: var(--figma-color-text-secondary); margin-bottom: 12px;">
      Download the JSON file or copy to clipboard.
    </div>
    
    <div style="background: var(--figma-color-bg-secondary); border-radius: 6px; padding: 12px; margin-bottom: 12px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <span style="font-size: 11px; font-weight: 500;">\u{1F4C4} ${filename}</span>
        <span style="font-size: 10px; color: var(--figma-color-text-tertiary);">${formatBytes(json.length)}</span>
      </div>
      <div style="display: flex; gap: 8px;">
        <button class="button button-primary" id="downloadBtn" style="flex: 1;">
          \u2B07 Download JSON
        </button>
        <button class="button button-secondary" id="copyBtn" style="flex: 1;">
          \u{1F4CB} Copy to Clipboard
        </button>
      </div>
    </div>
    
    <div style="font-size: 10px; color: var(--figma-color-text-tertiary); margin-bottom: 8px;">Preview:</div>
    <textarea readonly style="flex: 1; min-height: 200px; font-family: 'SF Mono', Monaco, monospace; font-size: 10px; padding: 8px; border: 1px solid var(--figma-color-border); border-radius: 4px; resize: none; background: var(--figma-color-bg-secondary); color: var(--figma-color-text);">${escapeHtml3(json.slice(0, 5e3))}${json.length > 5e3 ? "\n\n... (truncated preview)" : ""}</textarea>
    
    <div style="display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end;">
      <button class="button button-secondary" id="closeModalBtn">Close</button>
    </div>
  `;
    modal.appendChild(content);
    document.body.appendChild(modal);
    const downloadBtn = content.querySelector("#downloadBtn");
    if (downloadBtn) {
      downloadBtn.addEventListener("click", () => {
        downloadFile(json, filename);
        const originalText = downloadBtn.innerHTML;
        downloadBtn.innerHTML = "\u2713 Downloaded!";
        setTimeout(() => {
          downloadBtn.innerHTML = originalText;
        }, 1500);
      });
    }
    const copyBtn = content.querySelector("#copyBtn");
    if (copyBtn) {
      copyBtn.addEventListener("click", () => {
        copyToClipboard(json);
        const originalText = copyBtn.innerHTML;
        copyBtn.innerHTML = "\u2713 Copied!";
        setTimeout(() => {
          copyBtn.innerHTML = originalText;
        }, 1500);
      });
    }
    const closeModalBtn = content.querySelector("#closeModalBtn");
    if (closeModalBtn) {
      closeModalBtn.addEventListener("click", () => {
        document.body.removeChild(modal);
      });
    }
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        document.body.removeChild(modal);
      }
    });
  }
  function downloadFile(content, filename) {
    const blob = new Blob([content], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
  function copyToClipboard(text) {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text);
    } else {
      const textarea = document.createElement("textarea");
      textarea.value = text;
      textarea.style.position = "fixed";
      textarea.style.opacity = "0";
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand("copy");
      document.body.removeChild(textarea);
    }
  }
  function formatBytes(bytes) {
    if (bytes < 1024)
      return `${bytes} B`;
    if (bytes < 1024 * 1024)
      return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  }
  function escapeHtml3(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // src/ui/components/sync-info.ts
  function showLastSyncInfo(nodeId, variableCount, updatedAt) {
    const container = document.getElementById("lastSyncInfo");
    if (!container)
      return;
    container.style.display = "block";
    const nodeIdEl = document.getElementById("lastSyncNodeId");
    if (nodeIdEl) {
      nodeIdEl.textContent = nodeId;
    }
    const variablesEl = document.getElementById("lastSyncVariables");
    if (variablesEl) {
      variablesEl.textContent = variableCount ? variableCount.toLocaleString() : "--";
    }
    const timeEl = document.getElementById("lastSyncTime");
    if (timeEl && updatedAt) {
      timeEl.textContent = formatTimeAgo(updatedAt);
    }
  }
  function initSyncInfo() {
    const nodeIdEl = document.getElementById("lastSyncNodeId");
    if (nodeIdEl) {
      nodeIdEl.addEventListener("click", function() {
        const nodeId = this.textContent;
        if (nodeId && nodeId !== "--") {
          navigator.clipboard.writeText(nodeId).then(() => {
            const original = nodeId;
            this.textContent = "Copied!";
            setTimeout(() => {
              this.textContent = original;
            }, 1500);
          });
        }
      });
    }
  }

  // src/backend/utils/baseline-detector.ts
  function isVersionCompatible(version) {
    const parts = version.split(".");
    if (parts.length < 1) {
      return {
        compatible: false,
        warning: "Invalid version format"
      };
    }
    const major = parseInt(parts[0], 10);
    if (isNaN(major)) {
      return {
        compatible: false,
        warning: "Invalid version format"
      };
    }
    const currentMajor = 2;
    if (major < currentMajor) {
      return {
        compatible: false,
        warning: `Baseline version ${version} is outdated. Current version is ${currentMajor}.x.x`
      };
    }
    if (major > currentMajor) {
      return {
        compatible: true,
        warning: `Baseline was exported from a newer version (${version}). Some features may not be supported.`
      };
    }
    return { compatible: true };
  }

  // src/ui/utils/message-bridge.ts
  function sendToBackend(message) {
    parent.postMessage({ pluginMessage: message }, "*");
  }

  // src/ui/components/baseline-confirmation.ts
  function renderBaselineConfirmation(options) {
    const container = document.getElementById("baselineConfirmationSection");
    if (!container)
      return;
    container.style.display = "block";
    if (!options.validation.valid) {
      container.innerHTML = renderBrokenReferencesUI(options);
    } else if (hasVersionWarning(options.detection)) {
      container.innerHTML = renderVersionWarningUI(options);
    } else {
      container.innerHTML = renderValidBaselineUI(options);
    }
    attachBaselineEventListeners(options);
  }
  function renderValidBaselineUI(options) {
    const { detection } = options;
    const exportedDate = formatDate2(detection.metadata.exportedAt);
    return `
    <div class="baseline-confirmation valid">
      <div class="baseline-header">
        <span class="status-icon">\u2705</span>
        <div class="baseline-title">
          <div class="filename">Baseline export file detected</div>
          <div class="file-info">Exported: ${exportedDate} \u2022 Version: v${detection.metadata.version}</div>
        </div>
      </div>

      <div class="baseline-content">
        <div class="collections-summary">
          <div class="summary-title">\u{1F4CA} Contains:</div>
          ${detection.collections.map((c) => `
            <div class="collection-item">
              \u2022 ${c.name} (${c.modeCount} mode${c.modeCount > 1 ? "s" : ""}, ${c.tokenCount} tokens)
            </div>
          `).join("")}
        </div>

        <div class="validation-status">
          <div class="status-item valid">\u2713 No broken references</div>
          <div class="status-item valid">\u2713 All aliases valid</div>
        </div>

        <div class="confirmation-question">
          Import as originally exported?
        </div>
      </div>

      <div class="baseline-actions">
        <button id="importBaselineBtn" class="button button-primary">
          \u2713 Yes, Import as-is
        </button>
        <button id="configureManuallyBtn" class="button button-secondary">
          Configure Manually
        </button>
      </div>
    </div>
  `;
  }
  function renderBrokenReferencesUI(options) {
    var _a;
    const { validation } = options;
    return `
    <div class="baseline-confirmation blocked">
      <div class="baseline-header error">
        <span class="status-icon">\u26D4</span>
        <div class="baseline-title">
          <div class="filename">Cannot Import - Broken References</div>
          <div class="file-info">Version: v${((_a = options.detection.metadata) == null ? void 0 : _a.version) || "unknown"}</div>
        </div>
      </div>

      <div class="baseline-content">
        <div class="error-summary">
          \u274C Found ${validation.brokenAliases.length} broken alias reference${validation.brokenAliases.length > 1 ? "s" : ""}:
        </div>

        <div class="broken-aliases-list">
          ${validation.brokenAliases.slice(0, 5).map((alias) => `
            <div class="broken-alias-item">
              <div class="alias-path">\u2022 ${alias.tokenPath}</div>
              <div class="alias-error">\u2192 References: ${alias.aliasReference}</div>
              <div class="alias-error">\u2192 Error: ${alias.error}</div>
            </div>
          `).join("")}
          ${validation.brokenAliases.length > 5 ? `
            <div class="more-errors">
              ... and ${validation.brokenAliases.length - 5} more
            </div>
          ` : ""}
        </div>

        <div class="fix-instructions">
          \u26A0\uFE0F Fix required:
          <ol>
            <li>Restore deleted tokens, OR</li>
            <li>Update aliases to valid references, OR</li>
            <li>Convert aliases to hardcoded values</li>
          </ol>
        </div>
      </div>

      <div class="baseline-actions">
        <button id="closeBaselineBtn" class="button button-secondary">
          Close
        </button>
      </div>
    </div>
  `;
  }
  function renderVersionWarningUI(options) {
    const { detection } = options;
    const pluginVersion = "2.0.0";
    const compatibility = isVersionCompatible(detection.metadata.version);
    return `
    <div class="baseline-confirmation warning">
      <div class="baseline-header warning">
        <span class="status-icon">\u26A0\uFE0F</span>
        <div class="baseline-title">
          <div class="filename">Version Mismatch Warning</div>
          <div class="file-info">
            Baseline: v${detection.metadata.version} \u2022 Plugin: v${pluginVersion}
          </div>
        </div>
      </div>

      <div class="baseline-content">
        <div class="warning-message">
          ${compatibility.warning || "\u26A0\uFE0F This baseline was exported from a different plugin version. Some features may not be supported."}
        </div>

        <div class="collections-summary">
          <div class="summary-title">\u{1F4CA} Contains:</div>
          ${detection.collections.map((c) => `
            <div class="collection-item">
              \u2022 ${c.name} (${c.modeCount} mode${c.modeCount > 1 ? "s" : ""}, ${c.tokenCount} tokens)
            </div>
          `).join("")}
        </div>

        <div class="confirmation-question">
          Continue with import?
        </div>
      </div>

      <div class="baseline-actions">
        <button id="cancelBaselineBtn" class="button button-secondary">
          Cancel
        </button>
        <button id="importAnywayBtn" class="button button-primary">
          Import Anyway
        </button>
      </div>
    </div>
  `;
  }
  function attachBaselineEventListeners(options) {
    const importBtn = document.getElementById("importBaselineBtn");
    const importAnywayBtn = document.getElementById("importAnywayBtn");
    const configureBtn = document.getElementById("configureManuallyBtn");
    const cancelBtn = document.getElementById("cancelBaselineBtn");
    const closeBtn = document.getElementById("closeBaselineBtn");
    if (importBtn || importAnywayBtn) {
      (importBtn || importAnywayBtn).addEventListener("click", async () => {
        await handleImportBaseline(options);
      });
    }
    if (configureBtn || cancelBtn || closeBtn) {
      (configureBtn || cancelBtn || closeBtn).addEventListener("click", () => {
        var _a;
        hideBaselineConfirmation();
        (_a = options.onConfigureManually) == null ? void 0 : _a.call(options);
      });
    }
  }
  async function handleImportBaseline(options) {
    var _a;
    const state2 = getState();
    let baselineFile;
    for (const [name, file] of state2.files.entries()) {
      baselineFile = file;
      break;
    }
    if (!baselineFile) {
      showNotification2("\u274C File not found", "error");
      return;
    }
    try {
      showNotification2("Analyzing changes...");
      sendToBackend({
        type: "preview-baseline-import",
        baseline: baselineFile.content
      });
      hideBaselineConfirmation();
      (_a = options.onImport) == null ? void 0 : _a.call(options);
    } catch (error) {
      showNotification2(`\u274C Import error: ${error.message}`, "error");
    }
  }
  function hideBaselineConfirmation() {
    const container = document.getElementById("baselineConfirmationSection");
    if (container) {
      container.style.display = "none";
    }
  }
  function formatDate2(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric",
      hour: "2-digit",
      minute: "2-digit"
    });
  }
  function hasVersionWarning(detection) {
    if (!detection.metadata)
      return false;
    const compatibility = isVersionCompatible(detection.metadata.version);
    return compatibility.compatible && !!compatibility.warning;
  }
  function showNotification2(message, type = "info") {
    if (type === "error") {
      alert(message);
    } else {
      console.log(`[${type}] ${message}`);
    }
  }

  // src/ui/components/sync-changes-diff.ts
  function renderSyncChangesDiff(versionBump) {
    const container = document.getElementById("syncChangesSection");
    if (!container)
      return;
    container.style.display = "block";
    container.innerHTML = `
    <div class="sync-changes">
      <div class="changes-header">
        <span class="icon">\u{1F4CA}</span>
        <div class="title">Changes Detected</div>
      </div>

      <div class="changes-content">
        ${renderChangeSection("breaking", versionBump.changes, "\u{1F534} Breaking Changes", "MAJOR")}
        ${renderChangeSection("addition", versionBump.changes, "\u{1F7E1} New Additions", "MINOR")}
        ${renderChangeSection("patch", versionBump.changes, "\u{1F7E2} Value Updates", "PATCH")}

        <div class="version-bump-box">
          <div class="bump-title">Version Bump</div>
          <div class="bump-display">
            <span class="version-current">${versionBump.current}</span>
            \u2192
            <span class="version-new">${versionBump.suggested} (${versionBump.changeType.toUpperCase()})</span>
          </div>

          <div class="version-override">
            <label>Override:</label>
            <div class="version-inputs">
              <input type="number" id="versionMajor" value="${versionBump.suggested.split(".")[0]}" min="0" />
              .
              <input type="number" id="versionMinor" value="${versionBump.suggested.split(".")[1]}" min="0" />
              .
              <input type="number" id="versionPatch" value="${versionBump.suggested.split(".")[2]}" min="0" />
            </div>
          </div>
        </div>
      </div>

      <div class="sync-actions">
        <button id="cancelSyncBtn" class="button button-secondary">Cancel</button>
        <button id="syncNowBtn" class="button button-primary">Sync Now (v${versionBump.suggested})</button>
      </div>
    </div>
  `;
    attachSyncEventListeners(versionBump);
  }
  function renderChangeSection(type, allChanges, title, badge) {
    const changes = allChanges.filter((c) => c.type === type);
    if (changes.length === 0)
      return "";
    return `
    <div class="change-section ${type}">
      <div class="section-header">
        ${title} (${changes.length}) \u2192 ${badge}
      </div>
      <div class="section-items">
        ${changes.slice(0, 5).map((change) => `
          <div class="change-item">
            \u2022 ${escapeHtml4(change.description)}
          </div>
        `).join("")}
        ${changes.length > 5 ? `
          <div class="more-changes">
            ... and ${changes.length - 5} more
          </div>
        ` : ""}
      </div>
    </div>
  `;
  }
  function attachSyncEventListeners(versionBump) {
    const syncBtn = document.getElementById("syncNowBtn");
    const cancelBtn = document.getElementById("cancelSyncBtn");
    const majorInput = document.getElementById("versionMajor");
    const minorInput = document.getElementById("versionMinor");
    const patchInput = document.getElementById("versionPatch");
    const updateSyncButton = () => {
      const version = `${majorInput.value}.${minorInput.value}.${patchInput.value}`;
      if (syncBtn) {
        syncBtn.textContent = `Sync Now (v${version})`;
      }
    };
    [majorInput, minorInput, patchInput].forEach((input) => {
      if (input) {
        input.addEventListener("input", updateSyncButton);
      }
    });
    if (syncBtn) {
      syncBtn.addEventListener("click", async () => {
        const newVersion = `${majorInput.value}.${minorInput.value}.${patchInput.value}`;
        await handleSyncNow(newVersion, versionBump);
      });
    }
    if (cancelBtn) {
      cancelBtn.addEventListener("click", () => {
        hideSyncChangesDiff();
      });
    }
  }
  async function handleSyncNow(newVersion, versionBump) {
    try {
      sendMessage({
        type: "sync-with-version",
        version: newVersion,
        changes: versionBump.changes
      });
      hideSyncChangesDiff();
    } catch (error) {
      console.error("Sync failed:", error);
    }
  }
  function hideSyncChangesDiff() {
    const container = document.getElementById("syncChangesSection");
    if (container) {
      container.style.display = "none";
      container.innerHTML = "";
    }
  }
  function escapeHtml4(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // src/ui/components/import-changes-diff.ts
  var pendingBaseline = null;
  function renderImportChangesDiff(versionBump, baseline) {
    pendingBaseline = baseline;
    const container = document.getElementById("importChangesSection");
    if (!container) {
      const mainContent = document.querySelector(".content") || document.body;
      const section = document.createElement("div");
      section.id = "importChangesSection";
      section.className = "import-changes-section";
      mainContent.insertBefore(section, mainContent.firstChild);
      renderImportChangesDiff(versionBump, baseline);
      return;
    }
    container.style.display = "block";
    const hasChanges = versionBump.changes.length > 0;
    const actionText = hasChanges ? "Apply Import" : "Import Anyway";
    container.innerHTML = `
    <div class="sync-changes import-changes">
      <div class="changes-header">
        <span class="icon">\u{1F4E5}</span>
        <div class="title">Import Preview</div>
        <div class="subtitle">Comparing imported baseline with current Figma variables</div>
      </div>

      <div class="changes-content">
        <div class="version-comparison">
          <span class="label">Current Figma:</span>
          <span class="version-badge current">v${versionBump.current}</span>
          <span class="arrow">\u2192</span>
          <span class="label">Importing:</span>
          <span class="version-badge importing">v${versionBump.suggested}</span>
        </div>

        ${hasChanges ? `
          ${renderChangeSection2("breaking", versionBump.changes, "\u{1F534} Breaking Changes", "Will be removed/changed")}
          ${renderChangeSection2("addition", versionBump.changes, "\u{1F7E2} New Additions", "Will be added")}
          ${renderChangeSection2("patch", versionBump.changes, "\u{1F7E1} Value Updates", "Will be updated")}
        ` : `
          <div class="no-changes">
            <span class="icon">\u2713</span>
            <span>No differences detected. The imported baseline matches your current Figma variables.</span>
          </div>
        `}

        <div class="import-summary">
          <div class="summary-item">
            <span class="count">${versionBump.breakingCount}</span>
            <span class="label">Breaking</span>
          </div>
          <div class="summary-item">
            <span class="count">${versionBump.additionCount}</span>
            <span class="label">Additions</span>
          </div>
          <div class="summary-item">
            <span class="count">${versionBump.patchCount}</span>
            <span class="label">Updates</span>
          </div>
        </div>
      </div>

      <div class="sync-actions import-actions">
        <button id="cancelImportBtn" class="button button-secondary">Cancel</button>
        <button id="confirmImportBtn" class="button button-primary">${actionText}</button>
      </div>
    </div>
  `;
    attachImportEventListeners();
  }
  function renderChangeSection2(type, allChanges, title, description) {
    const changes = allChanges.filter((c) => c.type === type);
    if (changes.length === 0)
      return "";
    return `
    <div class="change-section ${type}">
      <div class="section-header">
        ${title} (${changes.length})
        <span class="section-desc">${description}</span>
      </div>
      <div class="section-items">
        ${changes.slice(0, 8).map((change) => `
          <div class="change-item">
            <span class="change-path">${escapeHtml5(change.path)}</span>
            ${renderChangeValue(change)}
          </div>
        `).join("")}
        ${changes.length > 8 ? `
          <div class="more-changes">
            ... and ${changes.length - 8} more ${type} changes
          </div>
        ` : ""}
      </div>
    </div>
  `;
  }
  function renderChangeValue(change) {
    if (change.before !== void 0 && change.after !== void 0) {
      return `
      <div class="change-values">
        <span class="before">${escapeHtml5(formatValue(change.before))}</span>
        <span class="arrow">\u2192</span>
        <span class="after">${escapeHtml5(formatValue(change.after))}</span>
      </div>
    `;
    } else if (change.after !== void 0) {
      return `<div class="change-values"><span class="after new">${escapeHtml5(formatValue(change.after))}</span></div>`;
    } else if (change.before !== void 0) {
      return `<div class="change-values"><span class="before removed">${escapeHtml5(formatValue(change.before))}</span></div>`;
    }
    return "";
  }
  function formatValue(value) {
    if (value === null || value === void 0)
      return "null";
    if (typeof value === "object")
      return JSON.stringify(value);
    return String(value);
  }
  function attachImportEventListeners() {
    const confirmBtn = document.getElementById("confirmImportBtn");
    const cancelBtn = document.getElementById("cancelImportBtn");
    if (confirmBtn) {
      confirmBtn.addEventListener("click", () => {
        if (pendingBaseline) {
          sendToBackend({
            type: "confirm-baseline-import",
            baseline: pendingBaseline
          });
          hideImportChangesDiff();
        }
      });
    }
    if (cancelBtn) {
      cancelBtn.addEventListener("click", () => {
        hideImportChangesDiff();
      });
    }
  }
  function hideImportChangesDiff() {
    pendingBaseline = null;
    const container = document.getElementById("importChangesSection");
    if (container) {
      container.style.display = "none";
      container.innerHTML = "";
    }
  }
  function escapeHtml5(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // src/ui/components/structure-preview.ts
  var collapsedLevels = /* @__PURE__ */ new Set();
  function hideStructurePreview() {
    const container = document.getElementById("structurePreviewSection");
    if (container) {
      container.style.display = "none";
      container.innerHTML = "";
    }
    collapsedLevels.clear();
  }

  // src/ui/utils/level-validation.ts
  function validateLevelRoles(levels) {
    const errors = [];
    const warnings = [];
    if (levels.length === 0) {
      errors.push("No level configurations provided");
      return { valid: false, errors, warnings };
    }
    const hasCollection = levels.some((level) => level.role === "collection");
    if (!hasCollection) {
      errors.push("At least one level must be mapped as Collection");
    }
    const depths = levels.map((level) => level.depth).sort((a, b) => a - b);
    for (let i = 0; i < depths.length; i++) {
      if (depths[i] !== i + 1) {
        errors.push(`Level depths must be sequential starting from 1. Found gap at depth ${i + 1}`);
        break;
      }
    }
    const hasMode = levels.some((level) => level.role === "mode");
    if (!hasMode) {
      warnings.push("No Mode level defined - a default mode will be created for each collection");
    }
    return {
      valid: errors.length === 0,
      errors,
      warnings
    };
  }

  // src/ui/components/level-selector.ts
  function renderLevelSelector(levels, options = {}) {
    let containerId = "levelSelectorContainer";
    let compact = false;
    let onConfigChange;
    if (typeof options === "string") {
      containerId = options;
    } else {
      containerId = options.containerId || "levelSelectorContainer";
      compact = options.compact || false;
      onConfigChange = options.onConfigChange;
    }
    const container = document.getElementById(containerId);
    if (!container) {
      console.error(`[LevelSelector] Container element not found: #${containerId}`);
      return;
    }
    const isDefault = containerId === "levelSelectorContainer";
    const uniqueSuffix = isDefault ? "" : containerId.replace(/^level-selector-/, "");
    const levelsId = uniqueSuffix ? `levelSelectorLevels-${uniqueSuffix}` : "levelSelectorLevels";
    const validationId = uniqueSuffix ? `levelValidation-${uniqueSuffix}` : "levelValidation";
    const initialConfig = levels.map((level) => ({
      depth: level.depth,
      role: "token-path",
      exampleKeys: level.exampleKeys,
      keyCount: level.keyCount
    }));
    const headerHtml = compact ? "" : `
      <div class="level-selector-header">
        <h3 class="section-title">Configure Import Structure</h3>
        <p class="section-description">
          Define how the JSON levels map to Figma collections and modes:
        </p>
      </div>`;
    container.innerHTML = `
    <div class="level-selector${compact ? " level-selector-compact" : ""}">
      ${headerHtml}
      <div class="level-selector-levels" id="${levelsId}">
        ${levels.map((level, index) => renderLevelOption(level, index, initialConfig)).join("")}
      </div>

      <div class="level-selector-validation" id="${validationId}">
        ${renderValidation(initialConfig)}
      </div>
    </div>
  `;
    attachEventListeners(container, levels, initialConfig, validationId, onConfigChange);
    if (!onConfigChange) {
      updateLevelConfiguration(initialConfig);
    } else {
      onConfigChange(initialConfig);
    }
    emitConfigurationChanged(initialConfig);
  }
  function renderLevelOption(level, index, currentConfig) {
    var _a;
    const currentRole = ((_a = currentConfig[index]) == null ? void 0 : _a.role) || "token-path";
    const isLastLevel = index === currentConfig.length - 1;
    const displayKeys = level.exampleKeys.slice(0, 5).join(", ");
    const moreCount = level.keyCount > 5 ? level.keyCount - 5 : 0;
    const keysDisplay = moreCount > 0 ? `${displayKeys}... (+${moreCount} more)` : displayKeys;
    return `
    <div class="level-option" data-depth="${level.depth}">
      <div class="level-option-header">
        <span class="level-label">Level ${level.depth}:</span>
        <span class="level-key-count">${level.keyCount} keys</span>
      </div>

      <div class="level-option-keys">
        ${escapeHtml6(keysDisplay)}
      </div>

      <div class="level-option-radios">
        <label class="radio-label ${isLastLevel ? "disabled" : ""}">
          <input
            type="radio"
            name="level-${level.depth}"
            value="collection"
            ${currentRole === "collection" ? "checked" : ""}
            ${isLastLevel ? "disabled" : ""}
            data-depth="${level.depth}"
          />
          <span>Collection</span>
        </label>

        <label class="radio-label ${isLastLevel ? "disabled" : ""}">
          <input
            type="radio"
            name="level-${level.depth}"
            value="mode"
            ${currentRole === "mode" ? "checked" : ""}
            ${isLastLevel ? "disabled" : ""}
            data-depth="${level.depth}"
          />
          <span>Mode</span>
        </label>

        <label class="radio-label">
          <input
            type="radio"
            name="level-${level.depth}"
            value="token-path"
            ${currentRole === "token-path" ? "checked" : ""}
            data-depth="${level.depth}"
          />
          <span>Token Path</span>
        </label>
      </div>
    </div>
  `;
  }
  function renderValidation(config) {
    const validation = validateLevelRoles(config);
    if (!validation.valid) {
      return `
      <div class="validation-error">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
          <circle cx="8" cy="8" r="7" fill="currentColor" opacity="0.1"/>
          <path d="M8 4v5M8 11h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
        <span>${escapeHtml6(validation.errors[0])}</span>
      </div>
    `;
    }
    if (validation.warnings.length > 0) {
      return `
      <div class="validation-warning">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
          <path d="M8 1l7 12H1L8 1z" fill="currentColor" opacity="0.1"/>
          <path d="M8 6v4M8 11h.01" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
        <span>${escapeHtml6(validation.warnings[0])}</span>
      </div>
    `;
    }
    return "";
  }
  function attachEventListeners(container, levels, initialConfig, validationId = "levelValidation", onConfigChange) {
    let currentConfig = [...initialConfig];
    container.addEventListener("change", (event) => {
      const target = event.target;
      if (target.type === "radio" && target.dataset.depth) {
        const depth = parseInt(target.dataset.depth, 10);
        const newRole = target.value;
        const configIndex = currentConfig.findIndex((c) => c.depth === depth);
        if (configIndex !== -1) {
          currentConfig[configIndex] = __spreadProps(__spreadValues({}, currentConfig[configIndex]), {
            role: newRole
          });
          if (onConfigChange) {
            onConfigChange(currentConfig);
          } else {
            updateLevelConfiguration(currentConfig);
          }
          const validationEl = document.getElementById(validationId);
          if (validationEl) {
            validationEl.innerHTML = renderValidation(currentConfig);
          }
          emitConfigurationChanged(currentConfig);
        }
      }
    });
  }
  function emitConfigurationChanged(config) {
    const event = new CustomEvent("level-configuration-changed", {
      detail: {
        configuration: config,
        validation: validateLevelRoles(config)
      }
    });
    document.dispatchEvent(event);
  }
  function escapeHtml6(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // src/types/level-config.types.ts
  function extractModeNameFromFilename(fileName) {
    const nameWithoutExt = fileName.replace(/\.json$/i, "");
    if (nameWithoutExt.includes("-")) {
      const parts = nameWithoutExt.split("-");
      if (parts.length >= 2) {
        return parts[parts.length - 1];
      }
    }
    if (nameWithoutExt.includes(".")) {
      const parts = nameWithoutExt.split(".");
      if (parts.length >= 2) {
        return parts[parts.length - 1];
      }
    }
    if (nameWithoutExt.includes("_")) {
      const parts = nameWithoutExt.split("_");
      if (parts.length >= 2) {
        return parts[parts.length - 1];
      }
    }
    return nameWithoutExt;
  }
  function suggestCollectionName(fileNames) {
    if (fileNames.length === 0)
      return "Tokens";
    if (fileNames.length === 1) {
      return fileNames[0].replace(/\.json$/i, "").replace(/[-._](light|dark|mobile|desktop)$/i, "");
    }
    const prefix = findCommonPrefix(fileNames.map((f) => f.replace(/\.json$/i, "")));
    return prefix || "Tokens";
  }
  function findCommonPrefix(strings) {
    if (strings.length === 0)
      return "";
    let prefix = strings[0];
    for (let i = 1; i < strings.length; i++) {
      while (!strings[i].startsWith(prefix)) {
        prefix = prefix.slice(0, -1);
        if (prefix === "")
          return "";
      }
    }
    return prefix.replace(/[-._]+$/, "");
  }

  // src/ui/utils/file-grouping-helpers.ts
  function suggestFileGroups(files) {
    const fileNames = Array.from(files.keys());
    if (fileNames.length === 0) {
      return [];
    }
    if (fileNames.length === 1) {
      const fileName = fileNames[0];
      return [
        {
          id: generateGroupId(),
          collectionName: extractCollectionNameFromFilename(fileName),
          fileNames: [fileName],
          modeStrategy: "merged",
          modeNames: {}
        }
      ];
    }
    const prefixMap = /* @__PURE__ */ new Map();
    for (const fileName of fileNames) {
      const prefix = extractFilePrefix(fileName);
      if (!prefixMap.has(prefix)) {
        prefixMap.set(prefix, []);
      }
      prefixMap.get(prefix).push(fileName);
    }
    const groups = [];
    for (const [prefix, groupFileNames] of prefixMap) {
      const collectionName = suggestCollectionName(groupFileNames);
      const modeStrategy = groupFileNames.length > 1 ? "per-file" : "merged";
      const modeNames = {};
      if (modeStrategy === "per-file") {
        for (const fileName of groupFileNames) {
          const modeName = extractModeNameFromFilename(fileName + ".json");
          modeNames[fileName] = modeName;
        }
      }
      groups.push({
        id: generateGroupId(),
        collectionName,
        fileNames: groupFileNames,
        modeStrategy,
        modeNames
      });
    }
    return groups;
  }
  function extractFilePrefix(fileName) {
    if (fileName.includes("-")) {
      const parts = fileName.split("-");
      if (parts.length >= 2) {
        return parts.slice(0, -1).join("-");
      }
    }
    if (fileName.includes(".")) {
      const parts = fileName.split(".");
      if (parts.length >= 2) {
        return parts.slice(0, -1).join(".");
      }
    }
    if (fileName.includes("_")) {
      const parts = fileName.split("_");
      if (parts.length >= 2) {
        return parts.slice(0, -1).join("_");
      }
    }
    return fileName;
  }
  function extractCollectionNameFromFilename(fileName) {
    return fileName.replace(/[-._](light|dark|mobile|desktop|default)$/i, "") || "Tokens";
  }
  var groupIdCounter = 0;
  function generateGroupId() {
    return `group-${Date.now()}-${groupIdCounter++}`;
  }
  function moveFileToGroup(groups, fileName, targetGroupId) {
    const updatedGroups = groups.map((group) => __spreadProps(__spreadValues({}, group), {
      fileNames: group.fileNames.filter((name) => name !== fileName)
    }));
    return updatedGroups.map((group) => {
      if (group.id === targetGroupId) {
        return __spreadProps(__spreadValues({}, group), {
          fileNames: [...group.fileNames, fileName]
        });
      }
      return group;
    });
  }
  function removeEmptyGroups(groups) {
    return groups.filter((group) => group.fileNames.length > 0);
  }
  function createNewGroup() {
    return {
      id: generateGroupId(),
      collectionName: "New Collection",
      fileNames: [],
      modeStrategy: "merged",
      modeNames: {}
    };
  }
  function updateGroupName(groups, groupId, newName) {
    return groups.map((group) => {
      if (group.id === groupId) {
        return __spreadProps(__spreadValues({}, group), {
          collectionName: newName
        });
      }
      return group;
    });
  }
  function updateGroupModeStrategy(groups, groupId, modeStrategy) {
    return groups.map((group) => {
      if (group.id === groupId) {
        const modeNames = {};
        if (modeStrategy === "per-file") {
          for (const fileName of group.fileNames) {
            const modeName = extractModeNameFromFilename(fileName + ".json");
            modeNames[fileName] = modeName;
          }
        }
        return __spreadProps(__spreadValues({}, group), {
          modeStrategy,
          modeNames
        });
      }
      return group;
    });
  }
  function updateModeName(groups, groupId, fileName, modeName) {
    return groups.map((group) => {
      if (group.id === groupId && group.modeNames) {
        const updatedModeNames = __spreadProps(__spreadValues({}, group.modeNames), { [fileName]: modeName });
        return __spreadProps(__spreadValues({}, group), {
          modeNames: updatedModeNames
        });
      }
      return group;
    });
  }

  // src/ui/components/file-grouping.ts
  var currentDraggedFile = null;
  var uiReadyTimestamp = 0;
  var analyzedFirstLevelKeys = /* @__PURE__ */ new Map();
  function renderFileGrouping() {
    const container = document.getElementById("fileGroupingContainer");
    if (!container) {
      console.error("[FileGrouping] Container element not found");
      return;
    }
    const state2 = getState();
    if (state2.files.size < 2) {
      container.style.display = "none";
      return;
    }
    container.style.display = "block";
    if (!state2.fileGroups || state2.fileGroups.length === 0) {
      const suggestedGroups = suggestFileGroups(state2.files);
      setFileGroups(suggestedGroups);
    }
    uiReadyTimestamp = Date.now();
    console.log("[FileGrouping] UI ready at:", uiReadyTimestamp);
    renderGroupingUI(container);
  }
  function hideFileGrouping() {
    const container = document.getElementById("fileGroupingContainer");
    if (container) {
      container.style.display = "none";
    }
  }
  function renderGroupingUI(container) {
    const state2 = getState();
    const groups = state2.fileGroups || [];
    container.innerHTML = `
    <div class="file-grouping">
      <div class="section-title">2. Configure Collections</div>
      <div class="section-description">
        Organize files into collections and configure how modes are handled.
      </div>

      <div class="groups-container" id="groupsContainer">
        ${groups.map((group) => renderGroupCard(group)).join("")}
      </div>

      <button class="button-add" id="createGroupBtn">
        + Create New Collection
      </button>

      <div class="grouping-actions">
        <button class="button button-primary button-full" id="importAllBtn">
          Import All Collections
        </button>
      </div>
    </div>
  `;
    analyzeAllFilesFirstLevel();
    attachGroupingEventListeners();
  }
  function renderGroupCard(group) {
    const state2 = getState();
    const isSingleFile = group.fileNames.length === 1;
    return `
    <div class="group-card" data-group-id="${escapeHtml7(group.id)}">
      <div class="group-header">
        <div class="group-icon">\u{1F4E6}</div>
        <input
          type="text"
          class="group-name-input"
          value="${escapeHtml7(group.collectionName)}"
          data-group-id="${escapeHtml7(group.id)}"
          placeholder="Collection name"
        />
      </div>

      <div class="group-files" data-group-id="${escapeHtml7(group.id)}">
        ${group.fileNames.map((fileName) => renderFileCard(fileName, group.id)).join("")}
      </div>

      ${isSingleFile ? renderSingleFileModeOptions(group) : renderMultiFileModeOptions(group)}
    </div>
  `;
  }
  function renderFileCard(fileName, groupId) {
    const state2 = getState();
    const file = state2.files.get(fileName);
    if (!file) {
      return "";
    }
    return `
    <div
      class="file-card"
      draggable="true"
      data-file-name="${escapeHtml7(fileName)}"
      data-group-id="${escapeHtml7(groupId)}"
    >
      <div class="file-card-icon">\u{1F4C4}</div>
      <div class="file-card-info">
        <div class="file-card-name">${escapeHtml7(fileName)}.json</div>
        <div class="file-card-size">${formatFileSize2(file.size)}</div>
      </div>
      <div class="file-card-drag-handle">\u22EE\u22EE</div>
    </div>
  `;
  }
  function renderSingleFileModeOptions(group) {
    const fileName = group.fileNames[0];
    const firstLevelKeys = analyzedFirstLevelKeys.get(fileName) || [];
    const isPerFile = group.modeStrategy === "per-file";
    const keysPreview = firstLevelKeys.length > 0 ? firstLevelKeys.slice(0, 5).join(", ") + (firstLevelKeys.length > 5 ? "..." : "") : "Analyzing...";
    return `
    <div class="mode-options">
      <div class="mode-options-title">How should modes be determined?</div>

      <label class="mode-option ${isPerFile ? "selected" : ""}">
        <input
          type="radio"
          name="mode-strategy-${escapeHtml7(group.id)}"
          value="per-file"
          data-group-id="${escapeHtml7(group.id)}"
          ${isPerFile ? "checked" : ""}
        />
        <span class="radio-indicator"></span>
        <div class="mode-option-content">
          <div class="mode-option-label">Modes: First level represents modes</div>
          <div class="mode-option-description">Keys: ${escapeHtml7(keysPreview)}</div>
        </div>
      </label>

      <label class="mode-option ${!isPerFile ? "selected" : ""}">
        <input
          type="radio"
          name="mode-strategy-${escapeHtml7(group.id)}"
          value="merged"
          data-group-id="${escapeHtml7(group.id)}"
          ${!isPerFile ? "checked" : ""}
        />
        <span class="radio-indicator"></span>
        <div class="mode-option-content">
          <div class="mode-option-label">No modes: File has one default mode</div>
          <div class="mode-option-description">All tokens imported into "Mode 1"</div>
        </div>
      </label>
    </div>
  `;
  }
  function renderMultiFileModeOptions(group) {
    const isPerFile = group.modeStrategy === "per-file";
    return `
    <div class="mode-options">
      <div class="mode-options-title">How should these files be combined?</div>

      <label class="mode-option ${isPerFile ? "selected" : ""}">
        <input
          type="radio"
          name="mode-strategy-${escapeHtml7(group.id)}"
          value="per-file"
          data-group-id="${escapeHtml7(group.id)}"
          ${isPerFile ? "checked" : ""}
        />
        <span class="radio-indicator"></span>
        <div class="mode-option-content">
          <div class="mode-option-label">Each file = 1 mode</div>
          <div class="mode-option-description">Creates ${group.fileNames.length} modes in this collection</div>
        </div>
      </label>

      ${isPerFile ? renderModeNamesList(group) : ""}

      <label class="mode-option ${!isPerFile ? "selected" : ""}">
        <input
          type="radio"
          name="mode-strategy-${escapeHtml7(group.id)}"
          value="merged"
          data-group-id="${escapeHtml7(group.id)}"
          ${!isPerFile ? "checked" : ""}
        />
        <span class="radio-indicator"></span>
        <div class="mode-option-content">
          <div class="mode-option-label">Merge into 1 mode</div>
          <div class="mode-option-description">All tokens combined into "Mode 1"</div>
        </div>
      </label>
    </div>
  `;
  }
  function renderModeNamesList(group) {
    const modeNames = group.modeNames || {};
    return `
    <div class="mode-names-list">
      <div class="mode-names-label">Mode names (editable):</div>
      ${group.fileNames.map((fileName) => {
      const modeName = typeof modeNames === "object" && !("get" in modeNames) ? modeNames[fileName] || extractModeNameFromFilename2(fileName) : fileName;
      return `
            <div class="mode-name-item">
              <span class="mode-name-file">${escapeHtml7(fileName)}.json</span>
              <span class="mode-name-arrow">\u2192</span>
              <input
                type="text"
                class="mode-name-input"
                value="${escapeHtml7(modeName)}"
                data-group-id="${escapeHtml7(group.id)}"
                data-file-name="${escapeHtml7(fileName)}"
                placeholder="Mode name"
              />
            </div>
          `;
    }).join("")}
    </div>
  `;
  }
  function extractModeNameFromFilename2(fileName) {
    const parts = fileName.split("-");
    if (parts.length > 1) {
      return parts[parts.length - 1];
    }
    return fileName;
  }
  function attachGroupingEventListeners() {
    console.log("[FileGrouping] attachGroupingEventListeners called");
    console.trace("[FileGrouping] Trace:");
    document.querySelectorAll(".group-name-input").forEach((input) => {
      input.addEventListener("change", handleGroupNameChange);
    });
    document.querySelectorAll('input[type="radio"][name^="mode-strategy"]').forEach((radio) => {
      radio.addEventListener("change", handleModeStrategyChange);
    });
    document.querySelectorAll(".mode-name-input").forEach((input) => {
      input.addEventListener("change", handleModeNameChange);
    });
    document.querySelectorAll(".file-card").forEach((card) => {
      card.addEventListener("dragstart", handleDragStart);
      card.addEventListener("dragend", handleDragEnd);
    });
    document.querySelectorAll(".group-files").forEach((zone) => {
      zone.addEventListener("dragover", handleDragOver);
      zone.addEventListener("dragleave", handleDragLeave);
      zone.addEventListener("drop", handleDrop);
    });
    const createBtn = document.getElementById("createGroupBtn");
    createBtn == null ? void 0 : createBtn.addEventListener("click", handleCreateNewGroup);
    const importBtn = document.getElementById("importAllBtn");
    console.log("[FileGrouping] Attaching click listener to importAllBtn:", importBtn);
    importBtn == null ? void 0 : importBtn.addEventListener("click", handleImportAll);
  }
  function handleGroupNameChange(event) {
    const input = event.target;
    const groupId = input.dataset.groupId;
    const newName = input.value.trim();
    if (!groupId || !newName)
      return;
    const state2 = getState();
    const updatedGroups = updateGroupName(state2.fileGroups || [], groupId, newName);
    setFileGroups(updatedGroups);
  }
  function handleModeStrategyChange(event) {
    const radio = event.target;
    const groupId = radio.dataset.groupId;
    const strategy = radio.value;
    if (!groupId)
      return;
    const state2 = getState();
    const updatedGroups = updateGroupModeStrategy(state2.fileGroups || [], groupId, strategy);
    setFileGroups(updatedGroups);
    renderFileGrouping();
  }
  function handleModeNameChange(event) {
    const input = event.target;
    const groupId = input.dataset.groupId;
    const fileName = input.dataset.fileName;
    const modeName = input.value.trim();
    if (!groupId || !fileName || !modeName)
      return;
    const state2 = getState();
    const updatedGroups = updateModeName(state2.fileGroups || [], groupId, fileName, modeName);
    setFileGroups(updatedGroups);
  }
  function handleDragStart(event) {
    const card = event.currentTarget;
    const fileName = card.dataset.fileName;
    if (!fileName)
      return;
    currentDraggedFile = fileName;
    card.classList.add("dragging");
    if (event.dataTransfer) {
      event.dataTransfer.effectAllowed = "move";
      event.dataTransfer.setData("text/plain", fileName);
    }
  }
  function handleDragEnd(event) {
    const card = event.currentTarget;
    card.classList.remove("dragging");
    currentDraggedFile = null;
    document.querySelectorAll(".group-files").forEach((zone) => {
      zone.classList.remove("drop-zone-active");
    });
  }
  function handleDragOver(event) {
    var _a;
    event.preventDefault();
    const zone = event.currentTarget;
    const targetGroupId = zone.dataset.groupId;
    if (!targetGroupId || !currentDraggedFile)
      return;
    const state2 = getState();
    const currentGroup = (_a = state2.fileGroups) == null ? void 0 : _a.find((g) => g.fileNames.includes(currentDraggedFile));
    if ((currentGroup == null ? void 0 : currentGroup.id) === targetGroupId) {
      return;
    }
    zone.classList.add("drop-zone-active");
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = "move";
    }
  }
  function handleDragLeave(event) {
    const zone = event.currentTarget;
    zone.classList.remove("drop-zone-active");
  }
  function handleDrop(event) {
    console.log("[FileGrouping] handleDrop called, event:", event, "currentDraggedFile:", currentDraggedFile);
    event.preventDefault();
    const zone = event.currentTarget;
    const targetGroupId = zone.dataset.groupId;
    zone.classList.remove("drop-zone-active");
    if (!targetGroupId || !currentDraggedFile) {
      console.warn("[FileGrouping] handleDrop called but no file is being dragged - IGNORING");
      return;
    }
    const state2 = getState();
    let updatedGroups = moveFileToGroup(state2.fileGroups || [], currentDraggedFile, targetGroupId);
    updatedGroups = removeEmptyGroups(updatedGroups);
    setFileGroups(updatedGroups);
    renderFileGrouping();
  }
  function handleCreateNewGroup() {
    const state2 = getState();
    const newGroup = createNewGroup();
    const updatedGroups = [...state2.fileGroups || [], newGroup];
    setFileGroups(updatedGroups);
    renderFileGrouping();
  }
  function analyzeAllFilesFirstLevel() {
    const state2 = getState();
    state2.files.forEach((fileInfo, fileName) => {
      if (analyzedFirstLevelKeys.has(fileName))
        return;
      try {
        const data = fileInfo.content;
        if (typeof data === "object" && data !== null) {
          const keys = Object.keys(data).filter((k) => !k.startsWith("$"));
          analyzedFirstLevelKeys.set(fileName, keys);
        }
      } catch (e) {
        console.error("[FileGrouping] Failed to analyze", fileName, e);
      }
    });
    const container = document.getElementById("groupsContainer");
    if (container) {
      const groups = state2.fileGroups || [];
      container.innerHTML = groups.map((group) => renderGroupCard(group)).join("");
      attachGroupingEventListeners();
    }
  }
  function handleImportAll(event) {
    const timeSinceRender = Date.now() - uiReadyTimestamp;
    console.log("[FileGrouping] handleImportAll called, event:", event, "timeSinceRender:", timeSinceRender + "ms");
    if (timeSinceRender < 500) {
      console.warn("[FileGrouping] handleImportAll called too soon after render (", timeSinceRender, "ms) - BLOCKING AUTO-TRIGGER!");
      return;
    }
    if (!event || !(event instanceof MouseEvent)) {
      console.warn("[FileGrouping] handleImportAll called without user click - IGNORING!");
      return;
    }
    const state2 = getState();
    const groups = state2.fileGroups || [];
    const levelsByGroup = {};
    groups.forEach((group) => {
      const isSingleFile = group.fileNames.length === 1;
      const firstLevelKeys = isSingleFile ? analyzedFirstLevelKeys.get(group.fileNames[0]) || [] : [];
      if (isSingleFile && group.modeStrategy === "per-file" && firstLevelKeys.length > 0) {
        levelsByGroup[group.id] = [
          { depth: 1, role: "mode" },
          { depth: 2, role: "token-path" }
        ];
      } else {
        levelsByGroup[group.id] = [
          { depth: 1, role: "token-path" }
        ];
      }
    });
    const filesData = {};
    groups.forEach((group) => {
      group.fileNames.forEach((fileName) => {
        const fileInfo = state2.files.get(fileName);
        if (fileInfo) {
          filesData[fileName] = fileInfo.content;
        }
      });
    });
    console.log("[FileGrouping] Sending import with", Object.keys(filesData).length, "files");
    console.log("[FileGrouping] Groups:", groups.map((g) => ({
      name: g.collectionName,
      strategy: g.modeStrategy,
      files: g.fileNames.length
    })));
    sendMessage({
      type: "import-with-manual-config",
      config: {
        multiFile: {
          groups,
          levelsByGroup,
          filesData
        }
      }
    });
  }
  function formatFileSize2(bytes) {
    if (bytes < 1024)
      return `${bytes} B`;
    if (bytes < 1024 * 1024)
      return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  }
  function escapeHtml7(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // src/ui/components/live-preview.ts
  var previewContainer = null;
  function renderLivePreview(preview) {
    if (!previewContainer) {
      previewContainer = document.getElementById("live-preview");
      if (!previewContainer) {
        console.error("Preview container element not found");
        return;
      }
    }
    previewContainer.innerHTML = "";
    previewContainer.style.display = "block";
    const header = document.createElement("div");
    header.className = "preview-header";
    header.innerHTML = `
    <h3>Preview</h3>
    <p class="preview-description">Based on your selections above:</p>
  `;
    previewContainer.appendChild(header);
    const tree = document.createElement("div");
    tree.className = "preview-tree";
    for (const collection of preview.collections) {
      const collectionEl = renderCollection(collection);
      tree.appendChild(collectionEl);
    }
    previewContainer.appendChild(tree);
    const summary = document.createElement("div");
    summary.className = "preview-summary";
    summary.innerHTML = `
    <div class="summary-line"></div>
    <div class="summary-counts">
      <span>Total: ${preview.totalCollections} collection${preview.totalCollections !== 1 ? "s" : ""}, ${preview.totalModes} mode${preview.totalModes !== 1 ? "s" : ""}, ${preview.totalVariables} variable${preview.totalVariables !== 1 ? "s" : ""}</span>
    </div>
  `;
    previewContainer.appendChild(summary);
  }
  function renderCollection(collection) {
    const collectionEl = document.createElement("div");
    collectionEl.className = "preview-collection";
    const header = document.createElement("div");
    header.className = "collection-header";
    header.innerHTML = `
    <span class="expand-icon">\u25BC</span>
    <span class="collection-icon">\u{1F4E6}</span>
    <span class="collection-name">${escapeHtml8(collection.name)}</span>
    <span class="collection-count">(Collection)</span>
  `;
    const modesContainer = document.createElement("div");
    modesContainer.className = "modes-container";
    for (const mode of collection.modes) {
      const modeEl = renderMode(mode);
      modesContainer.appendChild(modeEl);
    }
    let isExpanded = true;
    header.addEventListener("click", () => {
      isExpanded = !isExpanded;
      modesContainer.style.display = isExpanded ? "block" : "none";
      const icon = header.querySelector(".expand-icon");
      if (icon) {
        icon.textContent = isExpanded ? "\u25BC" : "\u25B6";
      }
    });
    collectionEl.appendChild(header);
    collectionEl.appendChild(modesContainer);
    return collectionEl;
  }
  function renderMode(mode) {
    const modeEl = document.createElement("div");
    modeEl.className = "preview-mode";
    const isDefaultMode = mode.name === "Mode 1";
    const header = document.createElement("div");
    header.className = "mode-header";
    let modeIcon = "\u{1F3A8}";
    if (mode.name.toLowerCase().includes("mobile")) {
      modeIcon = "\u{1F4F1}";
    } else if (mode.name.toLowerCase().includes("desktop") || mode.name.toLowerCase().includes("web")) {
      modeIcon = "\u{1F5A5}";
    } else if (isDefaultMode) {
      modeIcon = "\u2699\uFE0F";
    }
    header.innerHTML = `
    <span class="mode-indent">\u251C\u2500</span>
    <span class="mode-icon">${modeIcon}</span>
    <span class="mode-name">${escapeHtml8(mode.name)}</span>
    ${isDefaultMode ? '<span class="default-badge">default mode</span>' : ""}
  `;
    modeEl.appendChild(header);
    const varsEl = document.createElement("div");
    varsEl.className = "mode-variables";
    if (mode.sampleVariables.length > 0) {
      const samplesText = mode.sampleVariables.map((v) => escapeHtml8(v)).join(", ");
      const hasMore = mode.variableCount > mode.sampleVariables.length;
      const moreText = hasMore ? "..." : "";
      varsEl.innerHTML = `
      <span class="var-indent">\u2502   \u2514\u2500</span>
      <span class="var-samples">${samplesText}${moreText}</span>
      <div class="var-count">${mode.variableCount} variable${mode.variableCount !== 1 ? "s" : ""}</div>
    `;
    } else {
      varsEl.innerHTML = `
      <span class="var-indent">\u2502   \u2514\u2500</span>
      <span class="var-count">${mode.variableCount} variable${mode.variableCount !== 1 ? "s" : ""}</span>
    `;
    }
    modeEl.appendChild(varsEl);
    return modeEl;
  }
  function hideLivePreview() {
    if (previewContainer) {
      previewContainer.style.display = "none";
      previewContainer.innerHTML = "";
    }
  }
  function escapeHtml8(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // src/ui/components/multi-collection-config.ts
  var analysisStates = /* @__PURE__ */ new Map();
  var currentAnalyzingIndex = 0;
  function extractModeNameFromFilename3(filename) {
    const nameWithoutExt = filename.replace(/\.json$/i, "");
    if (nameWithoutExt.includes("-")) {
      const parts = nameWithoutExt.split("-");
      if (parts.length >= 2)
        return parts[parts.length - 1];
    }
    if (nameWithoutExt.includes(".")) {
      const parts = nameWithoutExt.split(".");
      if (parts.length >= 2)
        return parts[parts.length - 1];
    }
    if (nameWithoutExt.includes("_")) {
      const parts = nameWithoutExt.split("_");
      if (parts.length >= 2)
        return parts[parts.length - 1];
    }
    return nameWithoutExt;
  }
  function renderMultiCollectionConfig() {
    const container = document.getElementById("multiCollectionConfigSection");
    if (!container) {
      console.error("[MultiCollectionConfig] Container not found");
      return;
    }
    const state2 = getState();
    const groups = state2.fileGroups || [];
    if (groups.length === 0) {
      console.error("[MultiCollectionConfig] No file groups found");
      return;
    }
    console.log("[MultiCollectionConfig] Rendering config for", groups.length, "collections");
    analysisStates.clear();
    groups.forEach((group) => {
      const modeNames = {};
      group.fileNames.forEach((fileName) => {
        modeNames[fileName] = extractModeNameFromFilename3(fileName);
      });
      analysisStates.set(group.id, {
        groupId: group.id,
        collectionName: group.collectionName,
        analyzed: false,
        modeStrategy: group.fileNames.length > 1 ? "per-file" : "merged",
        modeNames
      });
    });
    container.style.display = "block";
    renderUI(container, groups);
    currentAnalyzingIndex = 0;
    analyzeNextCollection();
  }
  function renderUI(container, groups) {
    container.innerHTML = `
    <div class="multi-collection-config">
      <div class="section-title">3. Configure Each Collection</div>
      <div class="section-description">
        Define how JSON levels map to Figma collections and modes for each collection.
      </div>

      <div id="collectionCards">
        ${groups.map((group) => renderCollectionCard(group)).join("")}
      </div>

      <div class="collection-actions">
        <button class="button button-primary button-full" id="importAllBtn" disabled>
          Import All Collections
        </button>
      </div>
    </div>
  `;
    const importBtn = document.getElementById("importAllBtn");
    importBtn == null ? void 0 : importBtn.addEventListener("click", handleImportAll2);
    attachModeStrategyListeners();
  }
  function renderCollectionCard(group) {
    const analysisState = analysisStates.get(group.id);
    const hasMultipleFiles = group.fileNames.length > 1;
    const modeStrategy = (analysisState == null ? void 0 : analysisState.modeStrategy) || "per-file";
    const fileCount = group.fileNames.length;
    let modeStrategySectionHtml = "";
    if (hasMultipleFiles) {
      const modeNamesHtml = modeStrategy === "per-file" ? renderModeNamesList2(group.id, group.fileNames, (analysisState == null ? void 0 : analysisState.modeNames) || {}) : "";
      modeStrategySectionHtml = `
      <div class="mode-strategy-section">
        <div class="mode-strategy-label">How should these ${fileCount} files be combined?</div>
        <div class="mode-strategy-options">
          <label class="mode-strategy-option ${modeStrategy === "per-file" ? "selected" : ""}">
            <input type="radio" name="mode-strategy-${escapeHtml9(group.id)}" 
                   value="per-file" ${modeStrategy === "per-file" ? "checked" : ""}
                   data-group-id="${escapeHtml9(group.id)}">
            <span class="radio-indicator"></span>
            <div class="option-content">
              <div class="option-title">Each file = 1 mode</div>
              <div class="option-description">Creates ${fileCount} modes in this collection</div>
            </div>
          </label>
          <label class="mode-strategy-option ${modeStrategy === "merged" ? "selected" : ""}">
            <input type="radio" name="mode-strategy-${escapeHtml9(group.id)}" 
                   value="merged" ${modeStrategy === "merged" ? "checked" : ""}
                   data-group-id="${escapeHtml9(group.id)}">
            <span class="radio-indicator"></span>
            <div class="option-content">
              <div class="option-title">Merge into 1 mode</div>
              <div class="option-description">All tokens combined into "Mode 1"</div>
            </div>
          </label>
        </div>
        ${modeNamesHtml}
      </div>
    `;
    }
    const structureLabel = hasMultipleFiles ? "Structure inside each file:" : "Token structure:";
    let structureContentHtml = "";
    if (!(analysisState == null ? void 0 : analysisState.analyzed)) {
      structureContentHtml = `<div class="analyzing"><span class="spinner"></span> Analyzing structure...</div>`;
    } else if (hasMultipleFiles && modeStrategy === "per-file") {
      structureContentHtml = renderSimplifiedStructure(group.id, analysisState.levels || []);
    } else {
      structureContentHtml = `<div id="level-selector-${escapeHtml9(group.id)}"></div>`;
    }
    const structureSectionHtml = `
    <div class="structure-section">
      <div class="structure-label">${structureLabel}</div>
      <div class="structure-content">
        ${structureContentHtml}
      </div>
    </div>
  `;
    const fileListShort = group.fileNames.length <= 2 ? group.fileNames.map((f) => `${f}.json`).join(", ") : `${group.fileNames[0]}.json + ${group.fileNames.length - 1} more`;
    return `
    <div class="collection-card" id="collection-${escapeHtml9(group.id)}">
      <div class="collection-header">
        <div class="collection-icon">\u{1F4E6}</div>
        <div class="collection-info">
          <div class="collection-name">${escapeHtml9(group.collectionName)}</div>
          <div class="collection-files">${fileCount} file${fileCount > 1 ? "s" : ""}: ${escapeHtml9(fileListShort)}</div>
        </div>
        <div class="collection-badge">${hasMultipleFiles ? `${fileCount} files` : "1 file"}</div>
      </div>
      <div class="collection-body" id="collection-body-${escapeHtml9(group.id)}">
        ${modeStrategySectionHtml}
        ${structureSectionHtml}
      </div>
    </div>
  `;
  }
  function renderModeNamesList2(groupId, fileNames, modeNames) {
    return `
    <div class="mode-names-list">
      <div class="mode-names-label">Mode names (editable):</div>
      ${fileNames.map((fileName) => `
        <div class="mode-name-row">
          <span class="mode-name-file">${escapeHtml9(fileName)}.json</span>
          <span class="mode-name-arrow">\u2192</span>
          <input type="text" class="mode-name-input" 
                 value="${escapeHtml9(modeNames[fileName] || extractModeNameFromFilename3(fileName))}"
                 data-group-id="${escapeHtml9(groupId)}"
                 data-file-name="${escapeHtml9(fileName)}"
                 placeholder="Mode name">
        </div>
      `).join("")}
    </div>
  `;
  }
  function renderSimplifiedStructure(groupId, levels) {
    if (levels.length === 0) {
      return '<div class="no-structure">No structure detected</div>';
    }
    return `
    <div class="simplified-structure" id="simplified-structure-${escapeHtml9(groupId)}">
      ${levels.map((level) => {
      const displayKeys = (level.exampleKeys || []).slice(0, 5).join(", ");
      const moreCount = (level.keyCount || 0) > 5 ? (level.keyCount || 0) - 5 : 0;
      const keysDisplay = moreCount > 0 ? `${displayKeys}... (+${moreCount} more)` : displayKeys;
      return `
          <div class="structure-level">
            <div class="structure-level-header">
              <span class="structure-level-label">Level ${level.depth}:</span>
              <span class="structure-level-count">${level.keyCount || 0} keys</span>
            </div>
            <div class="structure-level-keys">${escapeHtml9(keysDisplay)}</div>
            <div class="structure-level-role">
              <span class="role-indicator">\u2192</span>
              <span class="role-label">Token Path</span>
            </div>
          </div>
        `;
    }).join("")}
      <div class="structure-info">
        <span class="info-icon">\u{1F4A1}</span>
        <span class="info-text">Mode is determined by the file (each file = 1 mode)</span>
      </div>
    </div>
  `;
  }
  function attachModeStrategyListeners() {
    document.querySelectorAll('input[type="radio"][name^="mode-strategy-"]').forEach((radio) => {
      radio.addEventListener("change", (e) => {
        const target = e.target;
        const groupId = target.dataset.groupId;
        const strategy = target.value;
        if (groupId) {
          handleModeStrategyChange2(groupId, strategy);
        }
      });
    });
    document.querySelectorAll(".mode-name-input").forEach((input) => {
      input.addEventListener("change", (e) => {
        const target = e.target;
        const groupId = target.dataset.groupId;
        const fileName = target.dataset.fileName;
        const newName = target.value;
        if (groupId && fileName) {
          handleModeNameChange2(groupId, fileName, newName);
        }
      });
    });
  }
  function handleModeStrategyChange2(groupId, strategy) {
    console.log("[MultiCollectionConfig] Mode strategy changed:", groupId, strategy);
    const analysisState = analysisStates.get(groupId);
    if (analysisState) {
      analysisState.modeStrategy = strategy;
    }
    const state2 = getState();
    const groups = state2.fileGroups || [];
    const group = groups.find((g) => g.id === groupId);
    if (group) {
      group.modeStrategy = strategy;
      setState({ fileGroups: groups });
    }
    reRenderCollectionCard(groupId);
  }
  function handleModeNameChange2(groupId, fileName, newName) {
    console.log("[MultiCollectionConfig] Mode name changed:", groupId, fileName, "->", newName);
    const analysisState = analysisStates.get(groupId);
    if (analysisState) {
      analysisState.modeNames[fileName] = newName;
    }
  }
  function reRenderCollectionCard(groupId) {
    const state2 = getState();
    const groups = state2.fileGroups || [];
    const group = groups.find((g) => g.id === groupId);
    if (!group)
      return;
    const cardElement = document.getElementById(`collection-${groupId}`);
    if (cardElement) {
      cardElement.outerHTML = renderCollectionCard(group);
      const analysisState = analysisStates.get(groupId);
      const hasMultipleFiles = group.fileNames.length > 1;
      const modeStrategy = (analysisState == null ? void 0 : analysisState.modeStrategy) || "per-file";
      if ((analysisState == null ? void 0 : analysisState.analyzed) && analysisState.levels && !(hasMultipleFiles && modeStrategy === "per-file")) {
        renderLevelSelector(
          analysisState.levels.map((level) => ({
            depth: level.depth,
            exampleKeys: level.exampleKeys || [],
            keyCount: level.keyCount || 0
          })),
          {
            containerId: `level-selector-${groupId}`,
            compact: true,
            onConfigChange: (config) => {
              const state3 = analysisStates.get(groupId);
              if (state3) {
                state3.levels = config;
              }
            }
          }
        );
      }
      attachModeStrategyListeners();
    }
  }
  function analyzeNextCollection() {
    const state2 = getState();
    const groups = state2.fileGroups || [];
    if (currentAnalyzingIndex >= groups.length) {
      console.log("[MultiCollectionConfig] All collections analyzed");
      enableImportButton();
      return;
    }
    const group = groups[currentAnalyzingIndex];
    const firstFileName = group.fileNames[0];
    const file = state2.files.get(firstFileName);
    if (!file) {
      console.error("[MultiCollectionConfig] File not found:", firstFileName);
      currentAnalyzingIndex++;
      analyzeNextCollection();
      return;
    }
    console.log("[MultiCollectionConfig] Analyzing collection:", group.collectionName, "file:", firstFileName);
    sendMessage({
      type: "analyze-structure",
      fileName: firstFileName,
      jsonData: file.content,
      metadata: { groupId: group.id }
      // Pass groupId so we know which collection this is for
    });
  }
  function handleCollectionStructureAnalyzed(msg) {
    var _a;
    const groupId = (_a = msg.metadata) == null ? void 0 : _a.groupId;
    if (!groupId) {
      console.error("[MultiCollectionConfig] No groupId in structure analysis response");
      return;
    }
    console.log("[MultiCollectionConfig] Structure analyzed for collection:", groupId);
    const analysisState = analysisStates.get(groupId);
    if (analysisState) {
      analysisState.analyzed = true;
      analysisState.levels = msg.levels;
    }
    reRenderCollectionCard(groupId);
    currentAnalyzingIndex++;
    analyzeNextCollection();
  }
  function enableImportButton() {
    const importBtn = document.getElementById("importAllBtn");
    if (importBtn) {
      importBtn.disabled = false;
      console.log("[MultiCollectionConfig] Import button enabled");
    }
  }
  function handleImportAll2() {
    console.log("[MultiCollectionConfig] Import all collections clicked");
    const state2 = getState();
    const groups = state2.fileGroups || [];
    const levelsByGroup = {};
    const updatedGroups = groups.map((group) => {
      const analysisState = analysisStates.get(group.id);
      if (analysisState == null ? void 0 : analysisState.levels) {
        levelsByGroup[group.id] = analysisState.levels;
      }
      return __spreadProps(__spreadValues({}, group), {
        modeStrategy: (analysisState == null ? void 0 : analysisState.modeStrategy) || "per-file",
        modeNames: (analysisState == null ? void 0 : analysisState.modeNames) || {}
      });
    });
    const filesData = {};
    groups.forEach((group) => {
      group.fileNames.forEach((fileName) => {
        const fileInfo = state2.files.get(fileName);
        if (fileInfo) {
          filesData[fileName] = fileInfo.content;
        }
      });
    });
    console.log("[MultiCollectionConfig] Sending import with", Object.keys(filesData).length, "files");
    console.log("[MultiCollectionConfig] Groups with mode strategies:", updatedGroups.map((g) => ({
      name: g.collectionName,
      strategy: g.modeStrategy,
      files: g.fileNames.length
    })));
    sendMessage({
      type: "import-with-manual-config",
      config: {
        multiFile: {
          groups: updatedGroups,
          levelsByGroup,
          filesData
        }
      }
    });
  }
  function escapeHtml9(text) {
    const div = document.createElement("div");
    div.textContent = text;
    return div.innerHTML;
  }

  // src/ui/index.ts
  function initializeUI() {
    initTabs();
    initFileUpload({
      onFilesChanged: () => {
        handleFilesChanged();
      },
      onError: (fileName, error) => {
        showNotification3(`Error parsing ${fileName}: ${error}`, "error");
      }
    });
    initCollectionLists({
      onSelectionChanged: () => {
        updateActionButton();
      }
    });
    document.addEventListener("collections-loaded", () => {
      const state2 = getState();
      if (state2.currentTab === "export") {
        renderExportCollections();
      } else if (state2.currentTab === "sync") {
        renderSyncCollections();
      }
    });
    initSyncSuccessScreen();
    initSyncInfo();
    initSyncCheckChanges();
    initActionButton();
    initCancelButton();
    setupMessageHandler();
    setupFlexibleImportListeners();
    updateActionButton();
  }
  function handleFilesChanged() {
    const state2 = getState();
    updateActionButton();
    if (state2.files.size > 0) {
      const hasNonBaselineFiles = Array.from(state2.files.values()).some((f) => {
        const data = f.content;
        return !(data && typeof data === "object" && "$metadata" in data && "baseline" in data);
      });
      if (hasNonBaselineFiles) {
        console.log("[UI] Files ready - initiating flexible import");
        initiateFlexibleImport();
      }
    }
  }
  function initSyncCheckChanges() {
    const checkBtn = document.getElementById("checkChangesBtn");
    if (!checkBtn)
      return;
    checkBtn.addEventListener("click", () => {
      sendMessage({ type: "check-sync-changes" });
    });
  }
  function initActionButton() {
    const actionBtn = document.getElementById("actionBtn");
    if (!actionBtn)
      return;
    actionBtn.addEventListener("click", () => {
      const state2 = getState();
      switch (state2.currentTab) {
        case "import":
          handleImportAction();
          break;
        case "export":
          sendMessage({
            type: "export-baseline",
            collectionIds: Array.from(state2.selectedExportCollections)
          });
          break;
        case "sync":
          sendMessage({
            type: "sync-to-node",
            collectionIds: Array.from(state2.selectedSyncCollections)
          });
          break;
      }
    });
  }
  function handleImportAction() {
    handleFlexibleImport();
  }
  function handleFlexibleImport() {
    const state2 = getState();
    if (!state2.structureConfig) {
      showNotification3("No configuration found. Please configure level mapping first.", "error");
      return;
    }
    const config = {};
    if (state2.files.size === 1 && !state2.fileGroups) {
      const fileName = Array.from(state2.files.keys())[0];
      const file = state2.files.get(fileName);
      if (file) {
        config.singleFile = {
          fileName,
          data: file.content,
          levels: state2.structureConfig.levels
        };
      }
    }
    if (state2.fileGroups && state2.fileGroups.length > 0) {
      const levelsByGroup = /* @__PURE__ */ new Map();
      state2.fileGroups.forEach((group) => {
        levelsByGroup.set(group.id, state2.structureConfig.levels);
      });
      config.multiFile = {
        groups: state2.fileGroups,
        levelsByGroup
      };
    }
    sendMessage({
      type: "import-with-manual-config",
      config
    });
  }
  function initCancelButton() {
    const cancelBtn = document.getElementById("cancelBtn");
    if (!cancelBtn)
      return;
    cancelBtn.addEventListener("click", () => {
      sendMessage({ type: "cancel" });
    });
  }
  function setupFlexibleImportListeners() {
    document.addEventListener("level-configuration-changed", (event) => {
      handleLevelConfigurationChanged(event.detail);
    });
    document.addEventListener("file-grouping-complete", () => {
      handleFileGroupingComplete();
    });
  }
  function handleLevelConfigurationChanged(detail) {
    const state2 = getState();
    const actionBtn = document.getElementById("actionBtn");
    if (actionBtn) {
      actionBtn.disabled = !detail.validation.valid;
      actionBtn.textContent = "Import to Figma";
    }
    if (detail.validation.valid && state2.files.size > 0) {
      const fileName = Array.from(state2.files.keys())[0];
      const file = state2.files.get(fileName);
      if (file) {
        sendMessage({
          type: "generate-preview",
          fileName,
          jsonData: file.content,
          levels: detail.configuration
        });
      }
    }
  }
  function handleFileGroupingComplete() {
    console.log("[UI] handleFileGroupingComplete called!");
    console.trace("[UI] Stack trace:");
    const state2 = getState();
    hideFileGrouping();
    if (state2.fileGroups && state2.fileGroups.length > 0) {
      console.log("[UI] Starting multi-collection configuration for", state2.fileGroups.length, "collection(s)");
      setImportStep("configure");
      renderMultiCollectionConfig();
    }
  }
  function setupMessageHandler() {
    onMessage((msg) => {
      switch (msg.type) {
        case "last-sync-loaded":
          if (msg.exists && msg.nodeId && msg.variableCount !== void 0 && msg.updatedAt) {
            showLastSyncInfo(msg.nodeId, msg.variableCount, msg.updatedAt);
          }
          break;
        case "collections-loaded":
          handleCollectionsLoaded(msg.collections);
          break;
        case "import-complete":
          showNotification3(msg.message, "success");
          hideBaselineConfirmation();
          hideFlexibleImportUI();
          break;
        case "import-error":
          showNotification3("Error: " + msg.message, "error");
          break;
        case "export-complete":
          showExportModal(msg.data);
          break;
        case "export-error":
          showNotification3("Export Error: " + msg.message, "error");
          break;
        case "sync-complete":
          showSyncSuccess(msg.nodeId, msg.variableCount);
          hideSyncChangesDiff();
          break;
        case "sync-error":
          showNotification3("Sync Error: " + msg.message, "error");
          break;
        case "import-format-detected":
          handleImportFormatDetected(msg);
          break;
        case "structure-analyzed":
          handleStructureAnalyzed(msg);
          break;
        case "preview-generated":
          handlePreviewGenerated(msg);
          break;
        case "sync-changes-detected":
          renderSyncChangesDiff(msg.versionBump);
          break;
        case "import-changes-detected":
          renderImportChangesDiff(msg.versionBump, msg.baseline);
          break;
      }
    });
  }
  function handleStructureAnalyzed(msg) {
    var _a;
    console.log("[UI] Structure analyzed - showing level selector", msg.levels.length, "levels");
    const state2 = getState();
    if (state2.fileGroups && state2.fileGroups.length > 1 && ((_a = msg.metadata) == null ? void 0 : _a.groupId)) {
      console.log("[UI] Routing to multi-collection handler for groupId:", msg.metadata.groupId);
      handleCollectionStructureAnalyzed(msg);
      return;
    }
    setStructureConfig({
      fileName: msg.fileName,
      levels: msg.levels
    });
    const structureSection = document.getElementById("structurePreviewSection");
    if (structureSection) {
      console.log("[UI] Showing structure preview section");
      structureSection.style.display = "block";
    } else {
      console.error("[UI] structurePreviewSection not found!");
    }
    const levelSection = document.getElementById("levelSelectorSection");
    if (levelSection) {
      console.log("[UI] Showing level selector section");
      levelSection.style.display = "block";
    } else {
      console.error("[UI] levelSelectorSection not found!");
    }
    console.log("[UI] Rendering level selector");
    renderLevelSelector(
      msg.levels.map((level) => ({
        depth: level.depth,
        exampleKeys: level.exampleKeys || [],
        keyCount: level.keyCount || 0
      }))
    );
  }
  function handlePreviewGenerated(msg) {
    const previewSection = document.getElementById("livePreviewSection");
    if (previewSection) {
      previewSection.style.display = "block";
    }
    renderLivePreview(msg.preview);
    const actionBtn = document.getElementById("actionBtn");
    if (actionBtn) {
      actionBtn.disabled = false;
      actionBtn.textContent = "Import to Figma";
    }
  }
  function hideFlexibleImportUI() {
    hideStructurePreview();
    hideFileGrouping();
    hideLivePreview();
    const levelSection = document.getElementById("levelSelectorSection");
    if (levelSection) {
      levelSection.style.display = "none";
    }
  }
  function handleImportFormatDetected(msg) {
    console.log("[UI] Detection results received:", {
      fileName: msg.fileName,
      isBaseline: msg.baselineDetection.isBaseline,
      validation: msg.validation
    });
    setState({
      baselineDetection: msg.baselineDetection,
      validation: msg.validation
    });
    if (msg.baselineDetection.isBaseline) {
      console.log("[UI] Showing baseline confirmation UI");
      renderBaselineConfirmation({
        detection: msg.baselineDetection,
        validation: msg.validation,
        onConfigureManually: () => {
          hideBaselineConfirmation();
          initiateFlexibleImport();
        }
      });
    }
  }
  function initiateFlexibleImport() {
    const state2 = getState();
    console.log("[UI] initiateFlexibleImport - files.size:", state2.files.size);
    console.log("[UI] Files:", Array.from(state2.files.keys()));
    if (state2.files.size > 1) {
      console.log("[UI] Multiple files detected - showing file grouping UI");
      setImportStep("group");
      const groupingSection = document.getElementById("fileGroupingSection");
      if (groupingSection) {
        console.log("[UI] fileGroupingSection found, displaying...");
        groupingSection.style.display = "block";
      } else {
        console.error("[UI] fileGroupingSection NOT FOUND!");
      }
      console.log("[UI] Calling renderFileGrouping()...");
      renderFileGrouping();
      console.log("[UI] renderFileGrouping() completed");
    } else if (state2.files.size === 1) {
      console.log("[UI] Single file detected - going to structure analysis");
      setImportStep("configure");
      const fileName = Array.from(state2.files.keys())[0];
      const file = state2.files.get(fileName);
      if (file) {
        console.log("[UI] initiateFlexibleImport (single file) - sending analyze-structure for:", fileName);
        sendMessage({
          type: "analyze-structure",
          fileName,
          jsonData: file.content
        });
      } else {
        console.error("[UI] File not found for analysis:", fileName);
      }
    }
  }
  function handleCollectionsLoaded(collections) {
    const state2 = getState();
    const selectedExport = /* @__PURE__ */ new Set();
    const selectedSync = /* @__PURE__ */ new Set();
    collections.forEach((col) => {
      selectedExport.add(col.id);
      selectedSync.add(col.id);
    });
    setState({
      figmaCollections: collections,
      selectedExportCollections: selectedExport,
      selectedSyncCollections: selectedSync
    });
    const renderEvent = new CustomEvent("collections-loaded");
    document.dispatchEvent(renderEvent);
    updateActionButton();
  }
  function showNotification3(message, type = "info") {
    if (type === "error") {
      console.error(message);
    } else {
      console.log(message);
    }
    alert(message);
  }
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initializeUI);
  } else {
    initializeUI();
  }
})();
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL3VpL3N0YXRlLnRzIiwgIi4uL3NyYy91aS9tZXNzYWdlLWJyaWRnZS50cyIsICIuLi9zcmMvdWkvY29tcG9uZW50cy9zdWNjZXNzLXNjcmVlbi50cyIsICIuLi9zcmMvdWkvY29tcG9uZW50cy90YWJzLnRzIiwgIi4uL3NyYy91aS91dGlscy9mb3JtYXQudHMiLCAiLi4vc3JjL3VpL2NvbXBvbmVudHMvZmlsZS11cGxvYWQudHMiLCAiLi4vc3JjL3VpL2NvbXBvbmVudHMvY29sbGVjdGlvbi1saXN0LnRzIiwgIi4uL3NyYy91aS9jb21wb25lbnRzL2V4cG9ydC1tb2RhbC50cyIsICIuLi9zcmMvdWkvY29tcG9uZW50cy9zeW5jLWluZm8udHMiLCAiLi4vc3JjL2JhY2tlbmQvdXRpbHMvYmFzZWxpbmUtZGV0ZWN0b3IudHMiLCAiLi4vc3JjL3VpL3V0aWxzL21lc3NhZ2UtYnJpZGdlLnRzIiwgIi4uL3NyYy91aS9jb21wb25lbnRzL2Jhc2VsaW5lLWNvbmZpcm1hdGlvbi50cyIsICIuLi9zcmMvdWkvY29tcG9uZW50cy9zeW5jLWNoYW5nZXMtZGlmZi50cyIsICIuLi9zcmMvdWkvY29tcG9uZW50cy9pbXBvcnQtY2hhbmdlcy1kaWZmLnRzIiwgIi4uL3NyYy91aS9jb21wb25lbnRzL3N0cnVjdHVyZS1wcmV2aWV3LnRzIiwgIi4uL3NyYy91aS91dGlscy9sZXZlbC12YWxpZGF0aW9uLnRzIiwgIi4uL3NyYy91aS9jb21wb25lbnRzL2xldmVsLXNlbGVjdG9yLnRzIiwgIi4uL3NyYy90eXBlcy9sZXZlbC1jb25maWcudHlwZXMudHMiLCAiLi4vc3JjL3VpL3V0aWxzL2ZpbGUtZ3JvdXBpbmctaGVscGVycy50cyIsICIuLi9zcmMvdWkvY29tcG9uZW50cy9maWxlLWdyb3VwaW5nLnRzIiwgIi4uL3NyYy91aS9jb21wb25lbnRzL2xpdmUtcHJldmlldy50cyIsICIuLi9zcmMvdWkvY29tcG9uZW50cy9tdWx0aS1jb2xsZWN0aW9uLWNvbmZpZy50cyIsICIuLi9zcmMvdWkvaW5kZXgudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8qKlxuICogVUkgU3RhdGUgTWFuYWdlbWVudFxuICogVHlwZS1zYWZlIHN0YXRlIGNvbnRhaW5lciB3aXRoIG9ic2VydmVyIHBhdHRlcm4gZm9yIHJlYWN0aXZlIHVwZGF0ZXNcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IENvbGxlY3Rpb25TdW1tYXJ5IH0gZnJvbSAnLi4vdHlwZXMvY29sbGVjdGlvbi50eXBlcy5qcyc7XG5pbXBvcnQgdHlwZSB7IEJhc2VsaW5lRGV0ZWN0aW9uUmVzdWx0IH0gZnJvbSAnLi4vYmFja2VuZC91dGlscy9iYXNlbGluZS1kZXRlY3Rvci5qcyc7XG5pbXBvcnQgdHlwZSB7IFZhbGlkYXRpb25SZXN1bHQgfSBmcm9tICcuLi9iYWNrZW5kL3V0aWxzL2Jhc2VsaW5lLXZhbGlkYXRvci5qcyc7XG5pbXBvcnQgdHlwZSB7IFZlcnNpb25CdW1wIH0gZnJvbSAnLi4vYmFja2VuZC91dGlscy92ZXJzaW9uLW1hbmFnZXIuanMnO1xuaW1wb3J0IHR5cGUgeyBMZXZlbENvbmZpZ3VyYXRpb24sIEZpbGVHcm91cCwgQ29sbGVjdGlvbkNvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi90eXBlcy9sZXZlbC1jb25maWcudHlwZXMuanMnO1xuXG4vKipcbiAqIFVwbG9hZGVkIGZpbGUgcmVwcmVzZW50YXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVcGxvYWRlZEZpbGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHVua25vd247XG4gIHNpemU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBDb2xsZWN0aW9uIGNvbmZpZ3VyYXRpb24gZm9yIGltcG9ydFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbGxlY3Rpb25Db25maWcge1xuICBuYW1lOiBzdHJpbmc7XG4gIGlzTW9kZUNvbGxlY3Rpb246IGJvb2xlYW47XG4gIGZpbGVOYW1lczogc3RyaW5nW107XG59XG5cbi8qKlxuICogSW1wb3J0IHN0ZXAgaW4gdGhlIGZsZXhpYmxlIGltcG9ydCBmbG93XG4gKi9cbmV4cG9ydCB0eXBlIEltcG9ydFN0ZXAgPSAndXBsb2FkJyB8ICdncm91cCcgfCAnY29uZmlndXJlJyB8ICdwcmV2aWV3JztcblxuLyoqXG4gKiBTdHJ1Y3R1cmUgY29uZmlndXJhdGlvbiBzdGF0ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFN0cnVjdHVyZUNvbmZpZ1N0YXRlIHtcbiAgLyoqXG4gICAqIEZpbGUgbmFtZSBiZWluZyBjb25maWd1cmVkIChmb3Igc2luZ2xlLWZpbGUgaW1wb3J0cylcbiAgICovXG4gIGZpbGVOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBHcm91cCBJRCBiZWluZyBjb25maWd1cmVkIChmb3IgbXVsdGktZmlsZSBpbXBvcnRzKVxuICAgKi9cbiAgZ3JvdXBJZD86IHN0cmluZztcblxuICAvKipcbiAgICogTGV2ZWwgY29uZmlndXJhdGlvbnNcbiAgICovXG4gIGxldmVsczogTGV2ZWxDb25maWd1cmF0aW9uW107XG59XG5cbi8qKlxuICogQXBwbGljYXRpb24gc3RhdGUgc2hhcGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcHBTdGF0ZSB7XG4gIC8vIEZpbGUgbWFuYWdlbWVudFxuICBmaWxlczogTWFwPHN0cmluZywgVXBsb2FkZWRGaWxlPjtcbiAgY29sbGVjdGlvbnM6IENvbGxlY3Rpb25Db25maWdbXTtcbiAgY3VycmVudFRhYjogJ2ltcG9ydCcgfCAnZXhwb3J0JyB8ICdzeW5jJztcblxuICAvLyBGaWdtYSBjb2xsZWN0aW9uc1xuICBmaWdtYUNvbGxlY3Rpb25zOiBDb2xsZWN0aW9uU3VtbWFyeVtdO1xuICBzZWxlY3RlZEV4cG9ydENvbGxlY3Rpb25zOiBTZXQ8c3RyaW5nPjtcbiAgc2VsZWN0ZWRTeW5jQ29sbGVjdGlvbnM6IFNldDxzdHJpbmc+O1xuXG4gIC8vIE5FVzogRmxleGlibGUgaW1wb3J0IGZsb3cgc3RhdGVcbiAgY3VycmVudEltcG9ydFN0ZXA/OiBJbXBvcnRTdGVwO1xuICBmaWxlR3JvdXBzPzogRmlsZUdyb3VwW107XG4gIHN0cnVjdHVyZUNvbmZpZz86IFN0cnVjdHVyZUNvbmZpZ1N0YXRlO1xuICBjb2xsZWN0aW9uQ29uZmlndXJhdGlvbnM/OiBDb2xsZWN0aW9uQ29uZmlndXJhdGlvbltdO1xuXG4gIC8vIEJhc2VsaW5lIGRldGVjdGlvbiAoa2VwdCBmb3IgYmFzZWxpbmUgaW1wb3J0KVxuICBiYXNlbGluZURldGVjdGlvbj86IEJhc2VsaW5lRGV0ZWN0aW9uUmVzdWx0O1xuICB2YWxpZGF0aW9uPzogVmFsaWRhdGlvblJlc3VsdDtcbiAgdmVyc2lvbkJ1bXA/OiBWZXJzaW9uQnVtcDtcbn1cblxuLyoqXG4gKiBTdGF0ZSBjaGFuZ2UgbGlzdGVuZXIgY2FsbGJhY2tcbiAqL1xuZXhwb3J0IHR5cGUgU3RhdGVMaXN0ZW5lciA9IChzdGF0ZTogQXBwU3RhdGUpID0+IHZvaWQ7XG5cbi8qKlxuICogSW5pdGlhbCBzdGF0ZVxuICovXG5jb25zdCBpbml0aWFsU3RhdGU6IEFwcFN0YXRlID0ge1xuICBmaWxlczogbmV3IE1hcCgpLFxuICBjb2xsZWN0aW9uczogW10sXG4gIGN1cnJlbnRUYWI6ICdpbXBvcnQnLFxuICBmaWdtYUNvbGxlY3Rpb25zOiBbXSxcbiAgc2VsZWN0ZWRFeHBvcnRDb2xsZWN0aW9uczogbmV3IFNldCgpLFxuICBzZWxlY3RlZFN5bmNDb2xsZWN0aW9uczogbmV3IFNldCgpLFxufTtcblxuLyoqXG4gKiBDdXJyZW50IGFwcGxpY2F0aW9uIHN0YXRlXG4gKi9cbmxldCBzdGF0ZTogQXBwU3RhdGUgPSB7IC4uLmluaXRpYWxTdGF0ZSB9O1xuXG4vKipcbiAqIFJlZ2lzdGVyZWQgc3RhdGUgY2hhbmdlIGxpc3RlbmVyc1xuICovXG5jb25zdCBsaXN0ZW5lcnM6IFNldDxTdGF0ZUxpc3RlbmVyPiA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBHZXQgY3VycmVudCBzdGF0ZSAocmVhZC1vbmx5KVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGUoKTogUmVhZG9ubHk8QXBwU3RhdGU+IHtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBzdGF0ZSBhbmQgbm90aWZ5IGxpc3RlbmVyc1xuICogQHBhcmFtIHVwZGF0ZXMgLSBQYXJ0aWFsIHN0YXRlIHVwZGF0ZXMgdG8gYXBwbHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFN0YXRlKHVwZGF0ZXM6IFBhcnRpYWw8QXBwU3RhdGU+KTogdm9pZCB7XG4gIHN0YXRlID0geyAuLi5zdGF0ZSwgLi4udXBkYXRlcyB9O1xuICBub3RpZnlMaXN0ZW5lcnMoKTtcbn1cblxuLyoqXG4gKiBSZXNldCBzdGF0ZSB0byBpbml0aWFsIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRTdGF0ZSgpOiB2b2lkIHtcbiAgc3RhdGUgPSB7XG4gICAgZmlsZXM6IG5ldyBNYXAoKSxcbiAgICBjb2xsZWN0aW9uczogW10sXG4gICAgY3VycmVudFRhYjogJ2ltcG9ydCcsXG4gICAgZmlnbWFDb2xsZWN0aW9uczogW10sXG4gICAgc2VsZWN0ZWRFeHBvcnRDb2xsZWN0aW9uczogbmV3IFNldCgpLFxuICAgIHNlbGVjdGVkU3luY0NvbGxlY3Rpb25zOiBuZXcgU2V0KCksXG4gIH07XG4gIG5vdGlmeUxpc3RlbmVycygpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBpbXBvcnQgc3RlcFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SW1wb3J0U3RlcChzdGVwOiBJbXBvcnRTdGVwKTogdm9pZCB7XG4gIHNldFN0YXRlKHsgY3VycmVudEltcG9ydFN0ZXA6IHN0ZXAgfSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGZpbGUgZ3JvdXBzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRGaWxlR3JvdXBzKGdyb3VwczogRmlsZUdyb3VwW10pOiB2b2lkIHtcbiAgc2V0U3RhdGUoeyBmaWxlR3JvdXBzOiBncm91cHMgfSk7XG59XG5cbi8qKlxuICogVXBkYXRlIHN0cnVjdHVyZSBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRTdHJ1Y3R1cmVDb25maWcoY29uZmlnOiBTdHJ1Y3R1cmVDb25maWdTdGF0ZSk6IHZvaWQge1xuICBzZXRTdGF0ZSh7IHN0cnVjdHVyZUNvbmZpZzogY29uZmlnIH0pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBsZXZlbCBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVMZXZlbENvbmZpZ3VyYXRpb24obGV2ZWxzOiBMZXZlbENvbmZpZ3VyYXRpb25bXSk6IHZvaWQge1xuICBjb25zdCBjdXJyZW50Q29uZmlnID0gc3RhdGUuc3RydWN0dXJlQ29uZmlnO1xuICBpZiAoY3VycmVudENvbmZpZykge1xuICAgIHNldFN0YXRlKHtcbiAgICAgIHN0cnVjdHVyZUNvbmZpZzoge1xuICAgICAgICAuLi5jdXJyZW50Q29uZmlnLFxuICAgICAgICBsZXZlbHMsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIHN0YXRlIGNoYW5nZXNcbiAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIHRvIGludm9rZSBvbiBzdGF0ZSBjaGFuZ2VzXG4gKiBAcmV0dXJucyBVbnN1YnNjcmliZSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyOiBTdGF0ZUxpc3RlbmVyKTogKCkgPT4gdm9pZCB7XG4gIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG59XG5cbi8qKlxuICogTm90aWZ5IGFsbCBsaXN0ZW5lcnMgb2Ygc3RhdGUgY2hhbmdlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycygpOiB2b2lkIHtcbiAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihzdGF0ZSkpO1xufVxuIiwgIi8qKlxuICogTWVzc2FnZSBCcmlkZ2VcbiAqXG4gKiBUeXBlLXNhZmUgbWVzc2FnZSBwYXNzaW5nIGJldHdlZW4gVUkgYW5kIHBsdWdpbiBiYWNrZW5kLlxuICogUHJvdmlkZXMgYSBjbGVhbiBBUEkgZm9yIHNlbmRpbmcgYW5kIHJlY2VpdmluZyBtZXNzYWdlcy5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFVJTWVzc2FnZSwgUGx1Z2luTWVzc2FnZSB9IGZyb20gJy4uL3R5cGVzL21lc3NhZ2UudHlwZXMuanMnO1xuXG4vKipcbiAqIE1lc3NhZ2UgaGFuZGxlciBjYWxsYmFjayB0eXBlXG4gKi9cbmV4cG9ydCB0eXBlIE1lc3NhZ2VIYW5kbGVyID0gKG1lc3NhZ2U6IFBsdWdpbk1lc3NhZ2UpID0+IHZvaWQ7XG5cbi8qKlxuICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHBsdWdpbiBiYWNrZW5kXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlbmRNZXNzYWdlKG1lc3NhZ2U6IFVJTWVzc2FnZSk6IHZvaWQge1xuICBwYXJlbnQucG9zdE1lc3NhZ2UoeyBwbHVnaW5NZXNzYWdlOiBtZXNzYWdlIH0sICcqJyk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBtZXNzYWdlIGhhbmRsZXIgZm9yIGJhY2tlbmQgbWVzc2FnZXNcbiAqIEBwYXJhbSBoYW5kbGVyIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gaGFuZGxlIG1lc3NhZ2VzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbk1lc3NhZ2UoaGFuZGxlcjogTWVzc2FnZUhhbmRsZXIpOiB2b2lkIHtcbiAgd2luZG93Lm9ubWVzc2FnZSA9IChldmVudDogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgY29uc3QgbXNnID0gZXZlbnQuZGF0YS5wbHVnaW5NZXNzYWdlIGFzIFBsdWdpbk1lc3NhZ2UgfCB1bmRlZmluZWQ7XG4gICAgaWYgKG1zZykge1xuICAgICAgaGFuZGxlcihtc2cpO1xuICAgIH1cbiAgfTtcbn1cbiIsICIvKipcbiAqIFN1Y2Nlc3MgU2NyZWVuIENvbXBvbmVudFxuICpcbiAqIE1hbmFnZXMgdGhlIHN5bmMgc3VjY2VzcyBzY3JlZW4gZGlzcGxheSB3aXRoIG5vZGUgSUQgY29weWluZyBmdW5jdGlvbmFsaXR5LlxuICogU2hvd3MgYWZ0ZXIgc3VjY2Vzc2Z1bCBzeW5jIHRvIG5vZGUgb3BlcmF0aW9uLlxuICovXG5cbi8qKlxuICogU2hvd3MgdGhlIHN5bmMgc3VjY2VzcyBzY3JlZW4gd2l0aCBzeW5jIGRldGFpbHNcbiAqIEBwYXJhbSBub2RlSWQgLSBUaGUgcmVnaXN0cnkgbm9kZSBJRFxuICogQHBhcmFtIHZhcmlhYmxlQ291bnQgLSBOdW1iZXIgb2YgdmFyaWFibGVzIHN5bmNlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvd1N5bmNTdWNjZXNzKG5vZGVJZDogc3RyaW5nLCB2YXJpYWJsZUNvdW50OiBudW1iZXIpOiB2b2lkIHtcbiAgLy8gSGlkZSB0aGUgcmVndWxhciBzeW5jIGNvbnRlbnQgYW5kIHNob3cgc3VjY2VzcyBzY3JlZW5cbiAgY29uc3Qgc3VjY2Vzc1NjcmVlbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzeW5jU3VjY2Vzc1NjcmVlbicpO1xuXG4gIGlmIChzdWNjZXNzU2NyZWVuKSB7XG4gICAgc3VjY2Vzc1NjcmVlbi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB2YWx1ZXNcbiAgY29uc3Qgbm9kZUlkVGV4dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzeW5jTm9kZUlkVmFsdWUgLm5vZGUtaWQtdGV4dCcpO1xuICBpZiAobm9kZUlkVGV4dCkge1xuICAgIG5vZGVJZFRleHQudGV4dENvbnRlbnQgPSBub2RlSWQ7XG4gIH1cblxuICBjb25zdCB2YXJpYWJsZUNvdW50RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3luY1ZhcmlhYmxlQ291bnQnKTtcbiAgaWYgKHZhcmlhYmxlQ291bnRFbCkge1xuICAgIHZhcmlhYmxlQ291bnRFbC50ZXh0Q29udGVudCA9IHZhcmlhYmxlQ291bnQudG9Mb2NhbGVTdHJpbmcoKTtcbiAgfVxuXG4gIGNvbnN0IHRpbWVzdGFtcEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNUaW1lc3RhbXAnKTtcbiAgaWYgKHRpbWVzdGFtcEVsKSB7XG4gICAgdGltZXN0YW1wRWwudGV4dENvbnRlbnQgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlVGltZVN0cmluZygpO1xuICB9XG5cbiAgLy8gSGlkZSB0aGUgYWN0aW9uIGZvb3RlciB3aGVuIHNob3dpbmcgc3VjY2Vzc1xuICBjb25zdCBhY3Rpb25Gb290ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYWN0aW9uLWZvb3RlcicpO1xuICBpZiAoYWN0aW9uRm9vdGVyKSB7XG4gICAgYWN0aW9uRm9vdGVyLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICB9XG59XG5cbi8qKlxuICogSGlkZXMgdGhlIHN5bmMgc3VjY2VzcyBzY3JlZW4gYW5kIHJldHVybnMgdG8gbm9ybWFsIHN5bmMgdmlld1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGlkZVN5bmNTdWNjZXNzKCk6IHZvaWQge1xuICByZXNldFN5bmNTdWNjZXNzU2NyZWVuKCk7XG4gIC8vIFNob3cgdGhlIGFjdGlvbiBmb290ZXIgYWdhaW5cbiAgY29uc3QgYWN0aW9uRm9vdGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFjdGlvbi1mb290ZXInKTtcbiAgaWYgKGFjdGlvbkZvb3Rlcikge1xuICAgIGFjdGlvbkZvb3Rlci5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB0aGUgc3luYyBzdWNjZXNzIHNjcmVlbiB0byBoaWRkZW4gc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0U3luY1N1Y2Nlc3NTY3JlZW4oKTogdm9pZCB7XG4gIGNvbnN0IHN1Y2Nlc3NTY3JlZW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3luY1N1Y2Nlc3NTY3JlZW4nKTtcblxuICBpZiAoc3VjY2Vzc1NjcmVlbikge1xuICAgIHN1Y2Nlc3NTY3JlZW4uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIHN5bmMgc3VjY2VzcyBzY3JlZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRTeW5jU3VjY2Vzc1NjcmVlbigpOiB2b2lkIHtcbiAgLy8gQ29weSBub2RlIElEIHRvIGNsaXBib2FyZFxuICBjb25zdCBzeW5jTm9kZUlkVmFsdWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3luY05vZGVJZFZhbHVlJyk7XG4gIGlmIChzeW5jTm9kZUlkVmFsdWUpIHtcbiAgICBzeW5jTm9kZUlkVmFsdWUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IG5vZGVJZEVsID0gdGhpcy5xdWVyeVNlbGVjdG9yKCcubm9kZS1pZC10ZXh0Jyk7XG4gICAgICBjb25zdCBub2RlSWQgPSBub2RlSWRFbD8udGV4dENvbnRlbnQ7XG5cbiAgICAgIGlmIChub2RlSWQgJiYgbm9kZUlkICE9PSAnLS0nKSB7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KG5vZGVJZCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBub2RlSWQ7XG4gICAgICAgICAgaWYgKG5vZGVJZEVsKSB7XG4gICAgICAgICAgICBub2RlSWRFbC50ZXh0Q29udGVudCA9ICdDb3BpZWQhJztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBub2RlSWRFbC50ZXh0Q29udGVudCA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgfSwgMTUwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFN5bmMgYWdhaW4gYnV0dG9uXG4gIGNvbnN0IHN5bmNBZ2FpbkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzeW5jQWdhaW5CdG4nKTtcbiAgaWYgKHN5bmNBZ2FpbkJ0bikge1xuICAgIHN5bmNBZ2FpbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGhpZGVTeW5jU3VjY2VzcygpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2xvc2UgYnV0dG9uXG4gIGNvbnN0IGNsb3NlU3luY1N1Y2Nlc3NCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xvc2VTeW5jU3VjY2Vzc0J0bicpO1xuICBpZiAoY2xvc2VTeW5jU3VjY2Vzc0J0bikge1xuICAgIGNsb3NlU3luY1N1Y2Nlc3NCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBwYXJlbnQucG9zdE1lc3NhZ2UoeyBwbHVnaW5NZXNzYWdlOiB7IHR5cGU6ICdjYW5jZWwnIH0gfSwgJyonKTtcbiAgICB9KTtcbiAgfVxufVxuIiwgIi8qKlxuICogVGFiIE5hdmlnYXRpb24gQ29tcG9uZW50XG4gKiBNYW5hZ2VzIHRhYiBzd2l0Y2hpbmcgbG9naWMgYW5kIHN0YXRlIHN5bmNocm9uaXphdGlvblxuICovXG5cbmltcG9ydCB0eXBlIHsgQXBwU3RhdGUgfSBmcm9tICcuLi9zdGF0ZSc7XG5pbXBvcnQgeyBnZXRTdGF0ZSwgc2V0U3RhdGUgfSBmcm9tICcuLi9zdGF0ZSc7XG5pbXBvcnQgeyBzZW5kTWVzc2FnZSB9IGZyb20gJy4uL21lc3NhZ2UtYnJpZGdlJztcbmltcG9ydCB7IHJlc2V0U3luY1N1Y2Nlc3NTY3JlZW4gfSBmcm9tICcuL3N1Y2Nlc3Mtc2NyZWVuLmpzJztcblxuZXhwb3J0IHR5cGUgVGFiVHlwZSA9ICdpbXBvcnQnIHwgJ2V4cG9ydCcgfCAnc3luYyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFiT3B0aW9ucyB7XG4gIG9uVGFiQ2hhbmdlPzogKHRhYjogVGFiVHlwZSkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRhYiBuYXZpZ2F0aW9uIGNvbXBvbmVudFxuICogSGFuZGxlcyB0YWIgc3dpdGNoaW5nLCBidXR0b24gc3RhdGVzLCBhbmQgcGFuZWwgdmlzaWJpbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdFRhYnMob3B0aW9uczogVGFiT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gIGNvbnN0IHRhYkJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxCdXR0b25FbGVtZW50PignLnNlZ21lbnRlZC1jb250cm9sIGJ1dHRvbicpO1xuICBjb25zdCB0YWJQYW5lbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxFbGVtZW50PignLnRhYi1wYW5lbCcpO1xuXG4gIHRhYkJ1dHRvbnMuZm9yRWFjaChidG4gPT4ge1xuICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGNvbnN0IHRhYiA9IGJ0bi5kYXRhc2V0LnRhYiBhcyBUYWJUeXBlO1xuICAgICAgaWYgKHRhYikge1xuICAgICAgICBzd2l0Y2hUYWIodGFiLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gU2V0IGluaXRpYWwgdGFiIHN0YXRlXG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgdXBkYXRlVGFiVUkoc3RhdGUuY3VycmVudFRhYiwgdGFiQnV0dG9ucywgdGFiUGFuZWxzKTtcbn1cblxuLyoqXG4gKiBTd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdGFiXG4gKiBVcGRhdGVzIFVJIHN0YXRlLCB0cmlnZ2VycyBjYWxsYmFja3MsIGFuZCBsb2FkcyB0YWItc3BlY2lmaWMgZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3dpdGNoVGFiKHRhYjogVGFiVHlwZSwgb3B0aW9uczogVGFiT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gIHNldFN0YXRlKHsgY3VycmVudFRhYjogdGFiIH0pO1xuXG4gIGNvbnN0IHRhYkJ1dHRvbnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxCdXR0b25FbGVtZW50PignLnNlZ21lbnRlZC1jb250cm9sIGJ1dHRvbicpO1xuICBjb25zdCB0YWJQYW5lbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsPEhUTUxFbGVtZW50PignLnRhYi1wYW5lbCcpO1xuXG4gIHVwZGF0ZVRhYlVJKHRhYiwgdGFiQnV0dG9ucywgdGFiUGFuZWxzKTtcblxuICAvLyBSZXNldCBzeW5jIHN1Y2Nlc3Mgc2NyZWVuIGlmIHN3aXRjaGluZyBhd2F5IGZyb20gc3luYyB0YWJcbiAgaWYgKHRhYiAhPT0gJ3N5bmMnKSB7XG4gICAgcmVzZXRTeW5jU3VjY2Vzc1NjcmVlbigpO1xuICB9XG5cbiAgLy8gVXBkYXRlIGFjdGlvbiBidXR0b24gc3RhdGVcbiAgdXBkYXRlQWN0aW9uQnV0dG9uKCk7XG5cbiAgLy8gTG9hZCBjb2xsZWN0aW9ucyBmb3IgZXhwb3J0L3N5bmMgdGFic1xuICBpZiAodGFiID09PSAnZXhwb3J0JyB8fCB0YWIgPT09ICdzeW5jJykge1xuICAgIHNlbmRNZXNzYWdlKHsgdHlwZTogJ2dldC1jb2xsZWN0aW9ucycgfSk7XG4gIH1cblxuICAvLyBMb2FkIGxhc3Qgc3luYyBpbmZvIGZvciBzeW5jIHRhYlxuICBpZiAodGFiID09PSAnc3luYycpIHtcbiAgICBzZW5kTWVzc2FnZSh7IHR5cGU6ICdnZXQtbGFzdC1zeW5jJyB9KTtcbiAgfVxuXG4gIC8vIFRyaWdnZXIgY2FsbGJhY2tcbiAgb3B0aW9ucy5vblRhYkNoYW5nZT8uKHRhYik7XG59XG5cbi8qKlxuICogVXBkYXRlIHRhYiBidXR0b24gYW5kIHBhbmVsIHZpc2liaWxpdHlcbiAqL1xuZnVuY3Rpb24gdXBkYXRlVGFiVUkoXG4gIHRhYjogVGFiVHlwZSxcbiAgdGFiQnV0dG9uczogTm9kZUxpc3RPZjxIVE1MQnV0dG9uRWxlbWVudD4sXG4gIHRhYlBhbmVsczogTm9kZUxpc3RPZjxIVE1MRWxlbWVudD5cbik6IHZvaWQge1xuICB0YWJCdXR0b25zLmZvckVhY2goYnRuID0+IHtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGJ0bi5kYXRhc2V0LnRhYiA9PT0gdGFiO1xuICAgIGJ0bi5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnLCBpc0FjdGl2ZSk7XG4gICAgYnRuLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIFN0cmluZyhpc0FjdGl2ZSkpO1xuICB9KTtcblxuICB0YWJQYW5lbHMuZm9yRWFjaChwYW5lbCA9PiB7XG4gICAgcGFuZWwuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJywgcGFuZWwuaWQgPT09IGB0YWItJHt0YWJ9YCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhY3Rpb24gYnV0dG9uIHRleHQgYW5kIHN0YXRlIGJhc2VkIG9uIGN1cnJlbnQgdGFiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVBY3Rpb25CdXR0b24oKTogdm9pZCB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgY29uc3QgYWN0aW9uQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjdGlvbkJ0bicpIGFzIEhUTUxCdXR0b25FbGVtZW50IHwgbnVsbDtcblxuICBpZiAoIWFjdGlvbkJ0bikgcmV0dXJuO1xuXG4gIHN3aXRjaCAoc3RhdGUuY3VycmVudFRhYikge1xuICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICBhY3Rpb25CdG4udGV4dENvbnRlbnQgPSAnSW1wb3J0IHRvIEZpZ21hJztcbiAgICAgIGNvbnN0IGhhc0ZpbGVzID0gc3RhdGUuZmlsZXMuc2l6ZSA+IDA7XG5cbiAgICAgIC8vIENoZWNrIGlmIHVzaW5nIGZsZXhpYmxlIGltcG9ydCAobmV3IHN5c3RlbSlcbiAgICAgIGlmIChzdGF0ZS5zdHJ1Y3R1cmVDb25maWcgJiYgc3RhdGUuc3RydWN0dXJlQ29uZmlnLmxldmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIEZsZXhpYmxlIGltcG9ydDogZW5hYmxlIGlmIHN0cnVjdHVyZSBpcyBjb25maWd1cmVkXG4gICAgICAgIGFjdGlvbkJ0bi5kaXNhYmxlZCA9ICFoYXNGaWxlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIExlZ2FjeSBpbXBvcnQ6IGVuYWJsZSBpZiBjb2xsZWN0aW9ucyBhcmUgY29uZmlndXJlZFxuICAgICAgICBjb25zdCBoYXNDb2xsZWN0aW9ucyA9IHN0YXRlLmNvbGxlY3Rpb25zLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IGFsbENvbGxlY3Rpb25zSGF2ZUZpbGVzID0gc3RhdGUuY29sbGVjdGlvbnMuZXZlcnkoYyA9PiBjLmZpbGVOYW1lcy5sZW5ndGggPiAwKTtcbiAgICAgICAgYWN0aW9uQnRuLmRpc2FibGVkID0gIShoYXNGaWxlcyAmJiBoYXNDb2xsZWN0aW9ucyAmJiBhbGxDb2xsZWN0aW9uc0hhdmVGaWxlcyk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICBhY3Rpb25CdG4udGV4dENvbnRlbnQgPSAnRXhwb3J0IEpTT04nO1xuICAgICAgYWN0aW9uQnRuLmRpc2FibGVkID0gc3RhdGUuc2VsZWN0ZWRFeHBvcnRDb2xsZWN0aW9ucy5zaXplID09PSAwO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzeW5jJzpcbiAgICAgIGFjdGlvbkJ0bi50ZXh0Q29udGVudCA9ICdTeW5jIHRvIE5vZGUnO1xuICAgICAgYWN0aW9uQnRuLmRpc2FibGVkID0gc3RhdGUuc2VsZWN0ZWRTeW5jQ29sbGVjdGlvbnMuc2l6ZSA9PT0gMDtcbiAgICAgIGJyZWFrO1xuICB9XG59XG4iLCAiLyoqXG4gKiBGb3JtYXR0aW5nIFV0aWxpdGllc1xuICpcbiAqIEhlbHBlciBmdW5jdGlvbnMgZm9yIGZvcm1hdHRpbmcgZGF0YSBmb3IgZGlzcGxheSBpbiB0aGUgVUkuXG4gKi9cblxuLyoqXG4gKiBGb3JtYXQgYSBmaWxlIHNpemUgaW4gYnl0ZXMgdG8gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmdcbiAqIEBwYXJhbSBieXRlcyAtIEZpbGUgc2l6ZSBpbiBieXRlc1xuICogQHJldHVybnMgRm9ybWF0dGVkIHN0cmluZyAoZS5nLiwgXCIxLjUgS0JcIiwgXCIyLjMgTUJcIilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEZpbGVTaXplKGJ5dGVzOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoYnl0ZXMgPCAxMDI0KSB7XG4gICAgcmV0dXJuIGAke2J5dGVzfSBCYDtcbiAgfVxuICBjb25zdCBrYiA9IGJ5dGVzIC8gMTAyNDtcbiAgaWYgKGtiIDwgMTAyNCkge1xuICAgIHJldHVybiBgJHtrYi50b0ZpeGVkKDEpfSBLQmA7XG4gIH1cbiAgY29uc3QgbWIgPSBrYiAvIDEwMjQ7XG4gIHJldHVybiBgJHttYi50b0ZpeGVkKDEpfSBNQmA7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgZGF0ZSB0byBhIGxvY2FsaXplZCBzdHJpbmdcbiAqIEBwYXJhbSBkYXRlIC0gRGF0ZSBvYmplY3Qgb3IgSVNPIHN0cmluZ1xuICogQHJldHVybnMgRm9ybWF0dGVkIGRhdGUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlKGRhdGU6IERhdGUgfCBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBkID0gdHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnID8gbmV3IERhdGUoZGF0ZSkgOiBkYXRlO1xuICByZXR1cm4gZC50b0xvY2FsZURhdGVTdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSB0aW1lc3RhbXAgdG8gcmVsYXRpdmUgdGltZSAoZS5nLiwgXCIyIG1pbnMgYWdvXCIsIFwiMyBob3VycyBhZ29cIilcbiAqIEBwYXJhbSBkYXRlIC0gRGF0ZSBvYmplY3Qgb3IgSVNPIHN0cmluZ1xuICogQHJldHVybnMgUmVsYXRpdmUgdGltZSBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFRpbWVBZ28oZGF0ZTogRGF0ZSB8IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGQgPSB0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycgPyBuZXcgRGF0ZShkYXRlKSA6IGRhdGU7XG4gIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gIGNvbnN0IGRpZmZNcyA9IG5vdy5nZXRUaW1lKCkgLSBkLmdldFRpbWUoKTtcbiAgY29uc3QgZGlmZk1pbnMgPSBNYXRoLmZsb29yKGRpZmZNcyAvIDYwMDAwKTtcbiAgY29uc3QgZGlmZkhvdXJzID0gTWF0aC5mbG9vcihkaWZmTXMgLyAzNjAwMDAwKTtcbiAgY29uc3QgZGlmZkRheXMgPSBNYXRoLmZsb29yKGRpZmZNcyAvIDg2NDAwMDAwKTtcblxuICBpZiAoZGlmZk1pbnMgPCAxKSB7XG4gICAgcmV0dXJuICdKdXN0IG5vdyc7XG4gIH0gZWxzZSBpZiAoZGlmZk1pbnMgPCA2MCkge1xuICAgIHJldHVybiBgJHtkaWZmTWluc30gbWluJHtkaWZmTWlucyAhPT0gMSA/ICdzJyA6ICcnfSBhZ29gO1xuICB9IGVsc2UgaWYgKGRpZmZIb3VycyA8IDI0KSB7XG4gICAgcmV0dXJuIGAke2RpZmZIb3Vyc30gaG91ciR7ZGlmZkhvdXJzICE9PSAxID8gJ3MnIDogJyd9IGFnb2A7XG4gIH0gZWxzZSBpZiAoZGlmZkRheXMgPCA3KSB7XG4gICAgcmV0dXJuIGAke2RpZmZEYXlzfSBkYXkke2RpZmZEYXlzICE9PSAxID8gJ3MnIDogJyd9IGFnb2A7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1hdERhdGUoZCk7XG4gIH1cbn1cbiIsICIvKipcbiAqIEZpbGUgVXBsb2FkIENvbXBvbmVudFxuICogSGFuZGxlcyBmaWxlIGRyYWctYW5kLWRyb3AsIHBhcnNpbmcsIGFuZCBkaXNwbGF5XG4gKi9cblxuaW1wb3J0IHsgZ2V0U3RhdGUsIHNldFN0YXRlIH0gZnJvbSAnLi4vc3RhdGUnO1xuaW1wb3J0IHsgdXBkYXRlQWN0aW9uQnV0dG9uIH0gZnJvbSAnLi90YWJzJztcbmltcG9ydCB7IGZvcm1hdEZpbGVTaXplIH0gZnJvbSAnLi4vdXRpbHMvZm9ybWF0JztcbmltcG9ydCB7IHNlbmRNZXNzYWdlIH0gZnJvbSAnLi4vbWVzc2FnZS1icmlkZ2UnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVEYXRhIHtcbiAgbmFtZTogc3RyaW5nO1xuICBjb250ZW50OiB1bmtub3duO1xuICBzaXplOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZVVwbG9hZE9wdGlvbnMge1xuICBvbkZpbGVzQ2hhbmdlZD86IChmaWxlczogTWFwPHN0cmluZywgRmlsZURhdGE+KSA9PiB2b2lkO1xuICBvbkVycm9yPzogKGZpbGVOYW1lOiBzdHJpbmcsIGVycm9yOiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBmaWxlIHVwbG9hZCBjb21wb25lbnRcbiAqIFNldHMgdXAgZHJhZy1hbmQtZHJvcCB6b25lLCBmaWxlIGlucHV0LCBhbmQgZXZlbnQgaGFuZGxlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRGaWxlVXBsb2FkKG9wdGlvbnM6IEZpbGVVcGxvYWRPcHRpb25zID0ge30pOiB2b2lkIHtcbiAgY29uc3QgZHJvcFpvbmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHJvcFpvbmUnKTtcbiAgY29uc3QgZmlsZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGVJbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gIGNvbnN0IGZpbGVMaXN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGVMaXN0Jyk7XG5cbiAgaWYgKCFkcm9wWm9uZSB8fCAhZmlsZUlucHV0IHx8ICFmaWxlTGlzdCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZpbGUgdXBsb2FkOiBSZXF1aXJlZCBlbGVtZW50cyBub3QgZm91bmQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDbGljayB0byBvcGVuIGZpbGUgcGlja2VyXG4gIGRyb3Bab25lLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gZmlsZUlucHV0LmNsaWNrKCkpO1xuXG4gIC8vIERyYWcgYW5kIGRyb3AgaGFuZGxlcnNcbiAgZHJvcFpvbmUuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCAoZSkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBkcm9wWm9uZS5jbGFzc0xpc3QuYWRkKCdkcmFnb3ZlcicpO1xuICB9KTtcblxuICBkcm9wWm9uZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCAoKSA9PiB7XG4gICAgZHJvcFpvbmUuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZ292ZXInKTtcbiAgfSk7XG5cbiAgZHJvcFpvbmUuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRyb3Bab25lLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdvdmVyJyk7XG4gICAgaWYgKGUuZGF0YVRyYW5zZmVyPy5maWxlcykge1xuICAgICAgaGFuZGxlRmlsZXMoZS5kYXRhVHJhbnNmZXIuZmlsZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRmlsZSBpbnB1dCBjaGFuZ2UgaGFuZGxlclxuICBmaWxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgIGlmICh0YXJnZXQuZmlsZXMpIHtcbiAgICAgIGhhbmRsZUZpbGVzKHRhcmdldC5maWxlcywgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbml0aWFsIHJlbmRlclxuICByZW5kZXJGaWxlTGlzdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgdXBsb2FkZWQgZmlsZXMgLSBwYXJzZSBKU09OIGFuZCB1cGRhdGUgc3RhdGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlRmlsZXMoZmlsZUxpc3Q6IEZpbGVMaXN0LCBvcHRpb25zOiBGaWxlVXBsb2FkT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG5cbiAgZm9yIChjb25zdCBmaWxlIG9mIEFycmF5LmZyb20oZmlsZUxpc3QpKSB7XG4gICAgaWYgKGZpbGUudHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nIHx8IGZpbGUubmFtZS5lbmRzV2l0aCgnLmpzb24nKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IGZpbGUudGV4dCgpO1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSBmaWxlLm5hbWUucmVwbGFjZSgnLmpzb24nLCAnJyk7XG5cbiAgICAgICAgc3RhdGUuZmlsZXMuc2V0KGZpbGVOYW1lLCB7XG4gICAgICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgY29udGVudDogZGF0YSxcbiAgICAgICAgICBzaXplOiBmaWxlLnNpemVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZmlsZSBpcyBiYXNlbGluZSBmb3JtYXRcbiAgICAgICAgY29uc3QgaXNCYXNlbGluZSA9IGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmICckbWV0YWRhdGEnIGluIGRhdGEgJiYgJ2Jhc2VsaW5lJyBpbiBkYXRhO1xuXG4gICAgICAgIGlmIChpc0Jhc2VsaW5lKSB7XG4gICAgICAgICAgLy8gT25seSBkZXRlY3QgZm9ybWF0IGZvciBiYXNlbGluZSBmaWxlc1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbRmlsZVVwbG9hZF0gQmFzZWxpbmUgZmlsZSBkZXRlY3RlZCwgc2VuZGluZyBkZXRlY3Rpb24gcmVxdWVzdCBmb3I6JywgZmlsZU5hbWUpO1xuICAgICAgICAgIHNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6ICdkZXRlY3QtaW1wb3J0LWZvcm1hdCcsXG4gICAgICAgICAgICBmaWxlTmFtZSxcbiAgICAgICAgICAgIGpzb25EYXRhOiBkYXRhXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tGaWxlVXBsb2FkXSBSZWd1bGFyIHRva2VuIGZpbGUsIHdpbGwgdXNlIGZsZXhpYmxlIGltcG9ydCBmb3I6JywgZmlsZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InO1xuICAgICAgICBvcHRpb25zLm9uRXJyb3I/LihmaWxlLm5hbWUsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHNob3dOb3RpZmljYXRpb24oYEVycm9yIHBhcnNpbmcgJHtmaWxlLm5hbWV9OiAke2Vycm9yTWVzc2FnZX1gLCAnZXJyb3InKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzZXRTdGF0ZSh7IGZpbGVzOiBzdGF0ZS5maWxlcyB9KTtcbiAgcmVuZGVyRmlsZUxpc3Qob3B0aW9ucyk7XG4gIHVwZGF0ZUFjdGlvbkJ1dHRvbigpO1xuICBvcHRpb25zLm9uRmlsZXNDaGFuZ2VkPy4oc3RhdGUuZmlsZXMpO1xufVxuXG4vKipcbiAqIFJlbmRlciB0aGUgbGlzdCBvZiB1cGxvYWRlZCBmaWxlcyB3aXRoIHJlbW92ZSBidXR0b25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJGaWxlTGlzdChvcHRpb25zOiBGaWxlVXBsb2FkT3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gIGNvbnN0IGZpbGVMaXN0RWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZUxpc3QnKTtcbiAgaWYgKCFmaWxlTGlzdEVsKSByZXR1cm47XG5cbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBmaWxlTGlzdEVsLmlubmVySFRNTCA9ICcnO1xuXG4gIHN0YXRlLmZpbGVzLmZvckVhY2goKGZpbGUsIG5hbWUpID0+IHtcbiAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaXRlbS5jbGFzc05hbWUgPSAnZmlsZS1pdGVtJztcblxuICAgIGl0ZW0uaW5uZXJIVE1MID0gYFxuICAgICAgPGRpdiBjbGFzcz1cImZpbGUtaW5mb1wiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImZpbGUtbmFtZVwiPiR7ZXNjYXBlSHRtbChmaWxlLm5hbWUpfTwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJmaWxlLXNpemVcIj4ke2Zvcm1hdEZpbGVTaXplKGZpbGUuc2l6ZSl9PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1naG9zdFwiIGRhdGEtZmlsZT1cIiR7ZXNjYXBlSHRtbChuYW1lKX1cIiBhcmlhLWxhYmVsPVwiUmVtb3ZlICR7ZXNjYXBlSHRtbChmaWxlLm5hbWUpfVwiPlx1MjcxNTwvYnV0dG9uPlxuICAgIGA7XG5cbiAgICBmaWxlTGlzdEVsLmFwcGVuZENoaWxkKGl0ZW0pO1xuXG4gICAgLy8gQXR0YWNoIHJlbW92ZSBoYW5kbGVyXG4gICAgY29uc3QgcmVtb3ZlQnRuID0gaXRlbS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICByZW1vdmVCdG4/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IGZpbGVOYW1lID0gKGUudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5kYXRhc2V0LmZpbGU7XG4gICAgICBpZiAoZmlsZU5hbWUpIHtcbiAgICAgICAgcmVtb3ZlRmlsZShmaWxlTmFtZSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGZpbGUgZnJvbSB0aGUgdXBsb2FkZWQgZmlsZXMgbGlzdFxuICovXG5mdW5jdGlvbiByZW1vdmVGaWxlKGZpbGVOYW1lOiBzdHJpbmcsIG9wdGlvbnM6IEZpbGVVcGxvYWRPcHRpb25zKTogdm9pZCB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgc3RhdGUuZmlsZXMuZGVsZXRlKGZpbGVOYW1lKTtcblxuICBzZXRTdGF0ZSh7IGZpbGVzOiBzdGF0ZS5maWxlcyB9KTtcbiAgcmVuZGVyRmlsZUxpc3Qob3B0aW9ucyk7XG4gIHVwZGF0ZUFjdGlvbkJ1dHRvbigpO1xuICBvcHRpb25zLm9uRmlsZXNDaGFuZ2VkPy4oc3RhdGUuZmlsZXMpO1xuXG4gIC8vIFJlLXJlbmRlciBjb2xsZWN0aW9ucyB0byB1cGRhdGUgZmlsZSBhc3NpZ25tZW50c1xuICBjb25zdCByZW5kZXJDb2xsZWN0aW9uc0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdyZW5kZXItY29sbGVjdGlvbnMnKTtcbiAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChyZW5kZXJDb2xsZWN0aW9uc0V2ZW50KTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgSFRNTCBlc2NhcGUgdG8gcHJldmVudCBYU1NcbiAqL1xuZnVuY3Rpb24gZXNjYXBlSHRtbCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUw7XG59XG5cbi8qKlxuICogU2hvdyBub3RpZmljYXRpb24gKHBsYWNlaG9sZGVyIC0gc2hvdWxkIGJlIGltcGxlbWVudGVkIGVsc2V3aGVyZSlcbiAqL1xuZnVuY3Rpb24gc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlOiBzdHJpbmcsIHR5cGU6ICdlcnJvcicgfCAnc3VjY2VzcycgfCAnaW5mbycpOiB2b2lkIHtcbiAgY29uc29sZVt0eXBlID09PSAnZXJyb3InID8gJ2Vycm9yJyA6ICdsb2cnXShtZXNzYWdlKTtcbiAgLy8gVE9ETzogSW1wbGVtZW50IHByb3BlciBub3RpZmljYXRpb24gVUlcbn1cbiIsICIvKipcbiAqIENvbGxlY3Rpb24gTGlzdCBDb21wb25lbnRcbiAqIFJlbmRlcnMgY29sbGVjdGlvbiBsaXN0cyBmb3IgZXhwb3J0IGFuZCBzeW5jIHRhYnMgd2l0aCBzZWxlY3Rpb24gbWFuYWdlbWVudFxuICovXG5cbmltcG9ydCB7IGdldFN0YXRlLCBzZXRTdGF0ZSB9IGZyb20gJy4uL3N0YXRlJztcbmltcG9ydCB7IHVwZGF0ZUFjdGlvbkJ1dHRvbiB9IGZyb20gJy4vdGFicyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlnbWFDb2xsZWN0aW9uIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICB2YXJpYWJsZUNvdW50OiBudW1iZXI7XG4gIG1vZGVDb3VudDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbGxlY3Rpb25MaXN0T3B0aW9ucyB7XG4gIG9uU2VsZWN0aW9uQ2hhbmdlZD86IChzZWxlY3RlZElkczogU2V0PHN0cmluZz4pID0+IHZvaWQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBjb2xsZWN0aW9uIGxpc3QgY29tcG9uZW50cyBmb3IgZXhwb3J0IGFuZCBzeW5jIHRhYnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRDb2xsZWN0aW9uTGlzdHMob3B0aW9uczogQ29sbGVjdGlvbkxpc3RPcHRpb25zID0ge30pOiB2b2lkIHtcbiAgLy8gRXhwb3J0IHRhYiBzZWxlY3QgYWxsL25vbmVcbiAgY29uc3QgZXhwb3J0U2VsZWN0QWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4cG9ydFNlbGVjdEFsbCcpO1xuICBjb25zdCBleHBvcnRTZWxlY3ROb25lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4cG9ydFNlbGVjdE5vbmUnKTtcblxuICBleHBvcnRTZWxlY3RBbGw/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIHNlbGVjdEFsbEV4cG9ydENvbGxlY3Rpb25zKCk7XG4gICAgb3B0aW9ucy5vblNlbGVjdGlvbkNoYW5nZWQ/LihnZXRTdGF0ZSgpLnNlbGVjdGVkRXhwb3J0Q29sbGVjdGlvbnMpO1xuICB9KTtcblxuICBleHBvcnRTZWxlY3ROb25lPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBzZWxlY3ROb25lRXhwb3J0Q29sbGVjdGlvbnMoKTtcbiAgICBvcHRpb25zLm9uU2VsZWN0aW9uQ2hhbmdlZD8uKGdldFN0YXRlKCkuc2VsZWN0ZWRFeHBvcnRDb2xsZWN0aW9ucyk7XG4gIH0pO1xuXG4gIC8vIFN5bmMgdGFiIHNlbGVjdCBhbGwvbm9uZVxuICBjb25zdCBzeW5jU2VsZWN0QWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNTZWxlY3RBbGwnKTtcbiAgY29uc3Qgc3luY1NlbGVjdE5vbmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3luY1NlbGVjdE5vbmUnKTtcblxuICBzeW5jU2VsZWN0QWxsPy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBzZWxlY3RBbGxTeW5jQ29sbGVjdGlvbnMoKTtcbiAgICBvcHRpb25zLm9uU2VsZWN0aW9uQ2hhbmdlZD8uKGdldFN0YXRlKCkuc2VsZWN0ZWRTeW5jQ29sbGVjdGlvbnMpO1xuICB9KTtcblxuICBzeW5jU2VsZWN0Tm9uZT8uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgc2VsZWN0Tm9uZVN5bmNDb2xsZWN0aW9ucygpO1xuICAgIG9wdGlvbnMub25TZWxlY3Rpb25DaGFuZ2VkPy4oZ2V0U3RhdGUoKS5zZWxlY3RlZFN5bmNDb2xsZWN0aW9ucyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlbmRlciBjb2xsZWN0aW9uIGxpc3QgZm9yIGV4cG9ydCB0YWJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckV4cG9ydENvbGxlY3Rpb25zKG9wdGlvbnM6IENvbGxlY3Rpb25MaXN0T3B0aW9ucyA9IHt9KTogdm9pZCB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleHBvcnRDb2xsZWN0aW9uTGlzdCcpO1xuICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RhdGUuZmlnbWFDb2xsZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gYFxuICAgICAgPGRpdiBjbGFzcz1cImVtcHR5LXN0YXRlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJlbXB0eS1zdGF0ZS1pY29uXCI+XHVEODNEXHVEQ0VEPC9kaXY+XG4gICAgICAgIDxkaXY+Tm8gdmFyaWFibGUgY29sbGVjdGlvbnMgZm91bmQ8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29udGFpbmVyLmlubmVySFRNTCA9IHN0YXRlLmZpZ21hQ29sbGVjdGlvbnNcbiAgICAubWFwKGNvbCA9PiBjcmVhdGVDb2xsZWN0aW9uTGlzdEl0ZW0oY29sLCBzdGF0ZS5zZWxlY3RlZEV4cG9ydENvbGxlY3Rpb25zLmhhcyhjb2wuaWQpKSlcbiAgICAuam9pbignJyk7XG5cbiAgLy8gQXR0YWNoIGNoZWNrYm94IGV2ZW50IGxpc3RlbmVyc1xuICBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykuZm9yRWFjaChjYiA9PiB7XG4gICAgY2IuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSB0YXJnZXQuZGF0YXNldC5pZDtcblxuICAgICAgaWYgKCFjb2xsZWN0aW9uSWQpIHJldHVybjtcblxuICAgICAgaWYgKHRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgIHN0YXRlLnNlbGVjdGVkRXhwb3J0Q29sbGVjdGlvbnMuYWRkKGNvbGxlY3Rpb25JZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5zZWxlY3RlZEV4cG9ydENvbGxlY3Rpb25zLmRlbGV0ZShjb2xsZWN0aW9uSWQpO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7IHNlbGVjdGVkRXhwb3J0Q29sbGVjdGlvbnM6IHN0YXRlLnNlbGVjdGVkRXhwb3J0Q29sbGVjdGlvbnMgfSk7XG4gICAgICB1cGRhdGVBY3Rpb25CdXR0b24oKTtcbiAgICAgIG9wdGlvbnMub25TZWxlY3Rpb25DaGFuZ2VkPy4oc3RhdGUuc2VsZWN0ZWRFeHBvcnRDb2xsZWN0aW9ucyk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlbmRlciBjb2xsZWN0aW9uIGxpc3QgZm9yIHN5bmMgdGFiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTeW5jQ29sbGVjdGlvbnMob3B0aW9uczogQ29sbGVjdGlvbkxpc3RPcHRpb25zID0ge30pOiB2b2lkIHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNDb2xsZWN0aW9uTGlzdCcpO1xuICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RhdGUuZmlnbWFDb2xsZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gYFxuICAgICAgPGRpdiBjbGFzcz1cImVtcHR5LXN0YXRlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJlbXB0eS1zdGF0ZS1pY29uXCI+XHVEODNEXHVEQ0VEPC9kaXY+XG4gICAgICAgIDxkaXY+Tm8gdmFyaWFibGUgY29sbGVjdGlvbnMgZm91bmQ8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29udGFpbmVyLmlubmVySFRNTCA9IHN0YXRlLmZpZ21hQ29sbGVjdGlvbnNcbiAgICAubWFwKGNvbCA9PiBjcmVhdGVDb2xsZWN0aW9uTGlzdEl0ZW0oY29sLCBzdGF0ZS5zZWxlY3RlZFN5bmNDb2xsZWN0aW9ucy5oYXMoY29sLmlkKSkpXG4gICAgLmpvaW4oJycpO1xuXG4gIC8vIEF0dGFjaCBjaGVja2JveCBldmVudCBsaXN0ZW5lcnNcbiAgY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpLmZvckVhY2goY2IgPT4ge1xuICAgIGNiLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gdGFyZ2V0LmRhdGFzZXQuaWQ7XG5cbiAgICAgIGlmICghY29sbGVjdGlvbklkKSByZXR1cm47XG5cbiAgICAgIGlmICh0YXJnZXQuY2hlY2tlZCkge1xuICAgICAgICBzdGF0ZS5zZWxlY3RlZFN5bmNDb2xsZWN0aW9ucy5hZGQoY29sbGVjdGlvbklkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnNlbGVjdGVkU3luY0NvbGxlY3Rpb25zLmRlbGV0ZShjb2xsZWN0aW9uSWQpO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7IHNlbGVjdGVkU3luY0NvbGxlY3Rpb25zOiBzdGF0ZS5zZWxlY3RlZFN5bmNDb2xsZWN0aW9ucyB9KTtcbiAgICAgIHVwZGF0ZUFjdGlvbkJ1dHRvbigpO1xuICAgICAgb3B0aW9ucy5vblNlbGVjdGlvbkNoYW5nZWQ/LihzdGF0ZS5zZWxlY3RlZFN5bmNDb2xsZWN0aW9ucyk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZSBIVE1MIGZvciBhIGNvbGxlY3Rpb24gbGlzdCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb25MaXN0SXRlbShjb2xsZWN0aW9uOiBGaWdtYUNvbGxlY3Rpb24sIGlzQ2hlY2tlZDogYm9vbGVhbik6IHN0cmluZyB7XG4gIGNvbnN0IG1vZGVUZXh0ID0gY29sbGVjdGlvbi5tb2RlQ291bnQgIT09IDEgPyAncycgOiAnJztcblxuICByZXR1cm4gYFxuICAgIDxsYWJlbCBjbGFzcz1cImNvbGxlY3Rpb24tbGlzdC1pdGVtXCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgZGF0YS1pZD1cIiR7ZXNjYXBlSHRtbChjb2xsZWN0aW9uLmlkKX1cIlxuICAgICAgICAke2lzQ2hlY2tlZCA/ICdjaGVja2VkJyA6ICcnfVxuICAgICAgICBhcmlhLWxhYmVsPVwiU2VsZWN0ICR7ZXNjYXBlSHRtbChjb2xsZWN0aW9uLm5hbWUpfVwiXG4gICAgICA+XG4gICAgICA8ZGl2IGNsYXNzPVwiY29sbGVjdGlvbi1pbmZvXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2xsZWN0aW9uLW5hbWVcIj4ke2VzY2FwZUh0bWwoY29sbGVjdGlvbi5uYW1lKX08L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbGxlY3Rpb24tbWV0YVwiPiR7Y29sbGVjdGlvbi52YXJpYWJsZUNvdW50LnRvTG9jYWxlU3RyaW5nKCl9IHZhcmlhYmxlcyBcdTAwQjcgJHtjb2xsZWN0aW9uLm1vZGVDb3VudH0gbW9kZSR7bW9kZVRleHR9PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2xhYmVsPlxuICBgO1xufVxuXG4vKipcbiAqIFNlbGVjdCBhbGwgY29sbGVjdGlvbnMgaW4gZXhwb3J0IHRhYlxuICovXG5mdW5jdGlvbiBzZWxlY3RBbGxFeHBvcnRDb2xsZWN0aW9ucygpOiB2b2lkIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBzdGF0ZS5maWdtYUNvbGxlY3Rpb25zLmZvckVhY2goY29sID0+IHN0YXRlLnNlbGVjdGVkRXhwb3J0Q29sbGVjdGlvbnMuYWRkKGNvbC5pZCkpO1xuICBzZXRTdGF0ZSh7IHNlbGVjdGVkRXhwb3J0Q29sbGVjdGlvbnM6IHN0YXRlLnNlbGVjdGVkRXhwb3J0Q29sbGVjdGlvbnMgfSk7XG4gIHJlbmRlckV4cG9ydENvbGxlY3Rpb25zKCk7XG4gIHVwZGF0ZUFjdGlvbkJ1dHRvbigpO1xufVxuXG4vKipcbiAqIERlc2VsZWN0IGFsbCBjb2xsZWN0aW9ucyBpbiBleHBvcnQgdGFiXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdE5vbmVFeHBvcnRDb2xsZWN0aW9ucygpOiB2b2lkIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBzdGF0ZS5zZWxlY3RlZEV4cG9ydENvbGxlY3Rpb25zLmNsZWFyKCk7XG4gIHNldFN0YXRlKHsgc2VsZWN0ZWRFeHBvcnRDb2xsZWN0aW9uczogc3RhdGUuc2VsZWN0ZWRFeHBvcnRDb2xsZWN0aW9ucyB9KTtcbiAgcmVuZGVyRXhwb3J0Q29sbGVjdGlvbnMoKTtcbiAgdXBkYXRlQWN0aW9uQnV0dG9uKCk7XG59XG5cbi8qKlxuICogU2VsZWN0IGFsbCBjb2xsZWN0aW9ucyBpbiBzeW5jIHRhYlxuICovXG5mdW5jdGlvbiBzZWxlY3RBbGxTeW5jQ29sbGVjdGlvbnMoKTogdm9pZCB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgc3RhdGUuZmlnbWFDb2xsZWN0aW9ucy5mb3JFYWNoKGNvbCA9PiBzdGF0ZS5zZWxlY3RlZFN5bmNDb2xsZWN0aW9ucy5hZGQoY29sLmlkKSk7XG4gIHNldFN0YXRlKHsgc2VsZWN0ZWRTeW5jQ29sbGVjdGlvbnM6IHN0YXRlLnNlbGVjdGVkU3luY0NvbGxlY3Rpb25zIH0pO1xuICByZW5kZXJTeW5jQ29sbGVjdGlvbnMoKTtcbiAgdXBkYXRlQWN0aW9uQnV0dG9uKCk7XG59XG5cbi8qKlxuICogRGVzZWxlY3QgYWxsIGNvbGxlY3Rpb25zIGluIHN5bmMgdGFiXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdE5vbmVTeW5jQ29sbGVjdGlvbnMoKTogdm9pZCB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgc3RhdGUuc2VsZWN0ZWRTeW5jQ29sbGVjdGlvbnMuY2xlYXIoKTtcbiAgc2V0U3RhdGUoeyBzZWxlY3RlZFN5bmNDb2xsZWN0aW9uczogc3RhdGUuc2VsZWN0ZWRTeW5jQ29sbGVjdGlvbnMgfSk7XG4gIHJlbmRlclN5bmNDb2xsZWN0aW9ucygpO1xuICB1cGRhdGVBY3Rpb25CdXR0b24oKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgSFRNTCBlc2NhcGUgdG8gcHJldmVudCBYU1NcbiAqL1xuZnVuY3Rpb24gZXNjYXBlSHRtbCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUw7XG59XG4iLCAiLyoqXG4gKiBFeHBvcnQgTW9kYWwgQ29tcG9uZW50XG4gKlxuICogRGlzcGxheXMgYSBtb2RhbCB3aXRoIGV4cG9ydGVkIEpTT04gZGF0YSBhbmQgZG93bmxvYWQvY29weSBmdW5jdGlvbmFsaXR5LlxuICogVXNlZCBmb3IgZXhwb3J0aW5nIGJhc2VsaW5lIHNuYXBzaG90cy5cbiAqL1xuXG4vKipcbiAqIFNob3dzIHRoZSBleHBvcnQgbW9kYWwgd2l0aCBKU09OIGRhdGFcbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gZXhwb3J0IGFzIEpTT05cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3dFeHBvcnRNb2RhbChkYXRhOiB1bmtub3duKTogdm9pZCB7XG4gIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhLCBudWxsLCAyKTtcbiAgXG4gIC8vIEdldCBmaWxlbmFtZSBmcm9tIG1ldGFkYXRhIGlmIGF2YWlsYWJsZVxuICBjb25zdCBtZXRhZGF0YSA9IChkYXRhIGFzIGFueSk/LiRtZXRhZGF0YTtcbiAgY29uc3QgdmVyc2lvbiA9IG1ldGFkYXRhPy52ZXJzaW9uIHx8ICcxLjAuMCc7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCAxMCk7XG4gIGNvbnN0IGZpbGVuYW1lID0gYGJhc2VsaW5lLXNuYXBzaG90LXYke3ZlcnNpb259LSR7dGltZXN0YW1wfS5qc29uYDtcblxuICAvLyBDcmVhdGUgbW9kYWwgb3ZlcmxheVxuICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBtb2RhbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBmaXhlZDsgdG9wOiAwOyBsZWZ0OiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuNyk7IGRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyOyB6LWluZGV4OiAxMDAwOyBwYWRkaW5nOiAxNnB4Oyc7XG5cbiAgLy8gQ3JlYXRlIG1vZGFsIGNvbnRlbnRcbiAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250ZW50LnN0eWxlLmNzc1RleHQgPSAnYmFja2dyb3VuZDogdmFyKC0tZmlnbWEtY29sb3ItYmcpOyBib3JkZXItcmFkaXVzOiA4cHg7IHBhZGRpbmc6IDE2cHg7IG1heC13aWR0aDogMTAwJTsgd2lkdGg6IDEwMCU7IG1heC1oZWlnaHQ6IDkwdmg7IGRpc3BsYXk6IGZsZXg7IGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47JztcblxuICBjb250ZW50LmlubmVySFRNTCA9IGBcbiAgICA8ZGl2IHN0eWxlPVwiZm9udC13ZWlnaHQ6IDYwMDsgbWFyZ2luLWJvdHRvbTogOHB4OyBkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyBnYXA6IDhweDtcIj5cbiAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLWljb24tc3VjY2VzcywgIzFlOGUzZSk7XCI+XHUyNzEzPC9zcGFuPlxuICAgICAgRXhwb3J0IENvbXBsZXRlXG4gICAgPC9kaXY+XG4gICAgPGRpdiBzdHlsZT1cImZvbnQtc2l6ZTogMTFweDsgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLXRleHQtc2Vjb25kYXJ5KTsgbWFyZ2luLWJvdHRvbTogMTJweDtcIj5cbiAgICAgIERvd25sb2FkIHRoZSBKU09OIGZpbGUgb3IgY29weSB0byBjbGlwYm9hcmQuXG4gICAgPC9kaXY+XG4gICAgXG4gICAgPGRpdiBzdHlsZT1cImJhY2tncm91bmQ6IHZhcigtLWZpZ21hLWNvbG9yLWJnLXNlY29uZGFyeSk7IGJvcmRlci1yYWRpdXM6IDZweDsgcGFkZGluZzogMTJweDsgbWFyZ2luLWJvdHRvbTogMTJweDtcIj5cbiAgICAgIDxkaXYgc3R5bGU9XCJkaXNwbGF5OiBmbGV4OyBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47IGFsaWduLWl0ZW1zOiBjZW50ZXI7IG1hcmdpbi1ib3R0b206IDhweDtcIj5cbiAgICAgICAgPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDExcHg7IGZvbnQtd2VpZ2h0OiA1MDA7XCI+XHVEODNEXHVEQ0M0ICR7ZmlsZW5hbWV9PC9zcGFuPlxuICAgICAgICA8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTBweDsgY29sb3I6IHZhcigtLWZpZ21hLWNvbG9yLXRleHQtdGVydGlhcnkpO1wiPiR7Zm9ybWF0Qnl0ZXMoanNvbi5sZW5ndGgpfTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBzdHlsZT1cImRpc3BsYXk6IGZsZXg7IGdhcDogOHB4O1wiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1wcmltYXJ5XCIgaWQ9XCJkb3dubG9hZEJ0blwiIHN0eWxlPVwiZmxleDogMTtcIj5cbiAgICAgICAgICBcdTJCMDcgRG93bmxvYWQgSlNPTlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBidXR0b24tc2Vjb25kYXJ5XCIgaWQ9XCJjb3B5QnRuXCIgc3R5bGU9XCJmbGV4OiAxO1wiPlxuICAgICAgICAgIFx1RDgzRFx1RENDQiBDb3B5IHRvIENsaXBib2FyZFxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgc3R5bGU9XCJmb250LXNpemU6IDEwcHg7IGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci10ZXh0LXRlcnRpYXJ5KTsgbWFyZ2luLWJvdHRvbTogOHB4O1wiPlByZXZpZXc6PC9kaXY+XG4gICAgPHRleHRhcmVhIHJlYWRvbmx5IHN0eWxlPVwiZmxleDogMTsgbWluLWhlaWdodDogMjAwcHg7IGZvbnQtZmFtaWx5OiAnU0YgTW9ubycsIE1vbmFjbywgbW9ub3NwYWNlOyBmb250LXNpemU6IDEwcHg7IHBhZGRpbmc6IDhweDsgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tZmlnbWEtY29sb3ItYm9yZGVyKTsgYm9yZGVyLXJhZGl1czogNHB4OyByZXNpemU6IG5vbmU7IGJhY2tncm91bmQ6IHZhcigtLWZpZ21hLWNvbG9yLWJnLXNlY29uZGFyeSk7IGNvbG9yOiB2YXIoLS1maWdtYS1jb2xvci10ZXh0KTtcIj4ke2VzY2FwZUh0bWwoanNvbi5zbGljZSgwLCA1MDAwKSl9JHtqc29uLmxlbmd0aCA+IDUwMDAgPyAnXFxuXFxuLi4uICh0cnVuY2F0ZWQgcHJldmlldyknIDogJyd9PC90ZXh0YXJlYT5cbiAgICBcbiAgICA8ZGl2IHN0eWxlPVwiZGlzcGxheTogZmxleDsgZ2FwOiA4cHg7IG1hcmdpbi10b3A6IDEycHg7IGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XCI+XG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1zZWNvbmRhcnlcIiBpZD1cImNsb3NlTW9kYWxCdG5cIj5DbG9zZTwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICBgO1xuXG4gIG1vZGFsLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1vZGFsKTtcblxuICAvLyBEb3dubG9hZCBidXR0b24gaGFuZGxlclxuICBjb25zdCBkb3dubG9hZEJ0biA9IGNvbnRlbnQucXVlcnlTZWxlY3RvcignI2Rvd25sb2FkQnRuJyk7XG4gIGlmIChkb3dubG9hZEJ0bikge1xuICAgIGRvd25sb2FkQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgZG93bmxvYWRGaWxlKGpzb24sIGZpbGVuYW1lKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsVGV4dCA9IGRvd25sb2FkQnRuLmlubmVySFRNTDtcbiAgICAgIGRvd25sb2FkQnRuLmlubmVySFRNTCA9ICdcdTI3MTMgRG93bmxvYWRlZCEnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRvd25sb2FkQnRuLmlubmVySFRNTCA9IG9yaWdpbmFsVGV4dDtcbiAgICAgIH0sIDE1MDApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ29weSBidXR0b24gaGFuZGxlclxuICBjb25zdCBjb3B5QnRuID0gY29udGVudC5xdWVyeVNlbGVjdG9yKCcjY29weUJ0bicpO1xuICBpZiAoY29weUJ0bikge1xuICAgIGNvcHlCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICBjb3B5VG9DbGlwYm9hcmQoanNvbik7XG4gICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSBjb3B5QnRuLmlubmVySFRNTDtcbiAgICAgIGNvcHlCdG4uaW5uZXJIVE1MID0gJ1x1MjcxMyBDb3BpZWQhJztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb3B5QnRuLmlubmVySFRNTCA9IG9yaWdpbmFsVGV4dDtcbiAgICAgIH0sIDE1MDApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2xvc2UgYnV0dG9uIGhhbmRsZXJcbiAgY29uc3QgY2xvc2VNb2RhbEJ0biA9IGNvbnRlbnQucXVlcnlTZWxlY3RvcignI2Nsb3NlTW9kYWxCdG4nKTtcbiAgaWYgKGNsb3NlTW9kYWxCdG4pIHtcbiAgICBjbG9zZU1vZGFsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChtb2RhbCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDbGljayBvdXRzaWRlIHRvIGNsb3NlXG4gIG1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICBpZiAoZS50YXJnZXQgPT09IG1vZGFsKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG1vZGFsKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIERvd25sb2FkIGEgc3RyaW5nIGFzIGEgZmlsZVxuICovXG5mdW5jdGlvbiBkb3dubG9hZEZpbGUoY29udGVudDogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbY29udGVudF0sIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nIH0pO1xuICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICBjb25zdCBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhLmhyZWYgPSB1cmw7XG4gIGEuZG93bmxvYWQgPSBmaWxlbmFtZTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgYS5jbGljaygpO1xuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGEpO1xuICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCk7XG59XG5cbi8qKlxuICogQ29weSB0ZXh0IHRvIGNsaXBib2FyZFxuICovXG5mdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQodGV4dDogc3RyaW5nKTogdm9pZCB7XG4gIGlmIChuYXZpZ2F0b3IuY2xpcGJvYXJkICYmIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KSB7XG4gICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2sgZm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgY29uc3QgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHRleHRhcmVhLnZhbHVlID0gdGV4dDtcbiAgICB0ZXh0YXJlYS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGV4dGFyZWEuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRleHRhcmVhKTtcbiAgICB0ZXh0YXJlYS5zZWxlY3QoKTtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGV4dGFyZWEpO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IGJ5dGVzIHRvIGh1bWFuIHJlYWRhYmxlXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEJ5dGVzKGJ5dGVzOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoYnl0ZXMgPCAxMDI0KSByZXR1cm4gYCR7Ynl0ZXN9IEJgO1xuICBpZiAoYnl0ZXMgPCAxMDI0ICogMTAyNCkgcmV0dXJuIGAkeyhieXRlcyAvIDEwMjQpLnRvRml4ZWQoMSl9IEtCYDtcbiAgcmV0dXJuIGAkeyhieXRlcyAvICgxMDI0ICogMTAyNCkpLnRvRml4ZWQoMSl9IE1CYDtcbn1cblxuLyoqXG4gKiBFc2NhcGUgSFRNTCB0byBwcmV2ZW50IFhTU1xuICovXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICByZXR1cm4gZGl2LmlubmVySFRNTDtcbn1cbiIsICIvKipcbiAqIFN5bmMgSW5mbyBDb21wb25lbnRcbiAqXG4gKiBEaXNwbGF5cyBsYXN0IHN5bmMgaW5mb3JtYXRpb24gaW5jbHVkaW5nIG5vZGUgSUQsIHZhcmlhYmxlIGNvdW50LCBhbmQgdGltZXN0YW1wLlxuICovXG5cbmltcG9ydCB7IGZvcm1hdFRpbWVBZ28gfSBmcm9tICcuLi91dGlscy9mb3JtYXQnO1xuXG4vKipcbiAqIFNob3dzIHRoZSBsYXN0IHN5bmMgaW5mbyBpbiB0aGUgc3luYyB0YWJcbiAqIEBwYXJhbSBub2RlSWQgLSBUaGUgcmVnaXN0cnkgbm9kZSBJRFxuICogQHBhcmFtIHZhcmlhYmxlQ291bnQgLSBOdW1iZXIgb2YgdmFyaWFibGVzIHN5bmNlZFxuICogQHBhcmFtIHVwZGF0ZWRBdCAtIElTTyB0aW1lc3RhbXAgb2YgbGFzdCBzeW5jXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG93TGFzdFN5bmNJbmZvKG5vZGVJZDogc3RyaW5nLCB2YXJpYWJsZUNvdW50OiBudW1iZXIsIHVwZGF0ZWRBdDogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYXN0U3luY0luZm8nKTtcbiAgaWYgKCFjb250YWluZXIpIHJldHVybjtcblxuICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgY29uc3Qgbm9kZUlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGFzdFN5bmNOb2RlSWQnKTtcbiAgaWYgKG5vZGVJZEVsKSB7XG4gICAgbm9kZUlkRWwudGV4dENvbnRlbnQgPSBub2RlSWQ7XG4gIH1cblxuICBjb25zdCB2YXJpYWJsZXNFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYXN0U3luY1ZhcmlhYmxlcycpO1xuICBpZiAodmFyaWFibGVzRWwpIHtcbiAgICB2YXJpYWJsZXNFbC50ZXh0Q29udGVudCA9IHZhcmlhYmxlQ291bnQgPyB2YXJpYWJsZUNvdW50LnRvTG9jYWxlU3RyaW5nKCkgOiAnLS0nO1xuICB9XG5cbiAgY29uc3QgdGltZUVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xhc3RTeW5jVGltZScpO1xuICBpZiAodGltZUVsICYmIHVwZGF0ZWRBdCkge1xuICAgIHRpbWVFbC50ZXh0Q29udGVudCA9IGZvcm1hdFRpbWVBZ28odXBkYXRlZEF0KTtcbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgc3luYyBpbmZvIGNvbXBvbmVudCB3aXRoIGNsaWNrLXRvLWNvcHkgZnVuY3Rpb25hbGl0eVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdFN5bmNJbmZvKCk6IHZvaWQge1xuICBjb25zdCBub2RlSWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsYXN0U3luY05vZGVJZCcpO1xuICBpZiAobm9kZUlkRWwpIHtcbiAgICBub2RlSWRFbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3Qgbm9kZUlkID0gdGhpcy50ZXh0Q29udGVudDtcbiAgICAgIGlmIChub2RlSWQgJiYgbm9kZUlkICE9PSAnLS0nKSB7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KG5vZGVJZCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBub2RlSWQ7XG4gICAgICAgICAgdGhpcy50ZXh0Q29udGVudCA9ICdDb3BpZWQhJztcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBvcmlnaW5hbDtcbiAgICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsICIvKipcbiAqIEJhc2VsaW5lIGZvcm1hdCBkZXRlY3Rpb24gdXRpbGl0aWVzXG4gKlxuICogRGV0ZWN0cyBpZiBpbXBvcnRlZCBKU09OIGlzIGluIGJhc2VsaW5lIGV4cG9ydCBmb3JtYXQgYW5kIGV4dHJhY3RzIG1ldGFkYXRhXG4gKiBmb3Igcm91bmQtdHJpcCBpbXBvcnQvZXhwb3J0IGZ1bmN0aW9uYWxpdHkuXG4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBCYXNlbGluZU1ldGFkYXRhIHtcbiAgdmVyc2lvbjogc3RyaW5nO1xuICBleHBvcnRlZEF0OiBzdHJpbmc7XG4gIHBsdWdpblZlcnNpb246IHN0cmluZztcbiAgZmlsZUtleT86IHN0cmluZztcbiAgZmlsZU5hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGVjdGlvblN1bW1hcnkge1xuICBuYW1lOiBzdHJpbmc7XG4gIG1vZGVDb3VudDogbnVtYmVyO1xuICB0b2tlbkNvdW50OiBudW1iZXI7XG4gIG1vZGVzOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXNlbGluZURldGVjdGlvblJlc3VsdCB7XG4gIGlzQmFzZWxpbmU6IGJvb2xlYW47XG4gIG1ldGFkYXRhPzogQmFzZWxpbmVNZXRhZGF0YTtcbiAgY29sbGVjdGlvbnM/OiBDb2xsZWN0aW9uU3VtbWFyeVtdO1xuICB0b3RhbFRva2Vucz86IG51bWJlcjtcbiAgdG90YWxDb2xsZWN0aW9ucz86IG51bWJlcjtcbiAgdG90YWxNb2Rlcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWZXJzaW9uQ29tcGF0aWJpbGl0eVJlc3VsdCB7XG4gIGNvbXBhdGlibGU6IGJvb2xlYW47XG4gIHdhcm5pbmc/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogRGV0ZWN0IGlmIGEgSlNPTiBmaWxlIGlzIGluIGJhc2VsaW5lIGV4cG9ydCBmb3JtYXRcbiAqXG4gKiBWYWxpZGF0ZXMgc3RydWN0dXJlIGFuZCBleHRyYWN0cyBjb2xsZWN0aW9uIHN1bW1hcmllcyBmb3IgcHJldmlld1xuICpcbiAqIEBwYXJhbSBqc29uIC0gUGFyc2VkIEpTT04gb2JqZWN0IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyBEZXRlY3Rpb24gcmVzdWx0IHdpdGggbWV0YWRhdGEgYW5kIGNvbGxlY3Rpb24gaW5mb1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0QmFzZWxpbmVGb3JtYXQoanNvbjogYW55KTogQmFzZWxpbmVEZXRlY3Rpb25SZXN1bHQge1xuICAvLyBUeXBlIGd1YXJkOiBtdXN0IGJlIGFuIG9iamVjdFxuICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24gIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoanNvbikpIHtcbiAgICByZXR1cm4geyBpc0Jhc2VsaW5lOiBmYWxzZSB9O1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHJlcXVpcmVkIHRvcC1sZXZlbCBmaWVsZHNcbiAgaWYgKCFqc29uLiRtZXRhZGF0YSB8fCAhanNvbi5iYXNlbGluZSkge1xuICAgIHJldHVybiB7IGlzQmFzZWxpbmU6IGZhbHNlIH07XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBtZXRhZGF0YSBzdHJ1Y3R1cmVcbiAgY29uc3QgbWV0YWRhdGEgPSBqc29uLiRtZXRhZGF0YTtcbiAgaWYgKCFtZXRhZGF0YSB8fCB0eXBlb2YgbWV0YWRhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHsgaXNCYXNlbGluZTogZmFsc2UgfTtcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIHJlcXVpcmVkIG1ldGFkYXRhIGZpZWxkc1xuICBpZiAoIW1ldGFkYXRhLnZlcnNpb24gfHwgIW1ldGFkYXRhLmV4cG9ydGVkQXQpIHtcbiAgICByZXR1cm4geyBpc0Jhc2VsaW5lOiBmYWxzZSB9O1xuICB9XG5cbiAgLy8gVmFsaWRhdGUgYmFzZWxpbmUgaXMgYW4gb2JqZWN0XG4gIGlmICghanNvbi5iYXNlbGluZSB8fCB0eXBlb2YganNvbi5iYXNlbGluZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShqc29uLmJhc2VsaW5lKSkge1xuICAgIHJldHVybiB7IGlzQmFzZWxpbmU6IGZhbHNlIH07XG4gIH1cblxuICAvLyBFeHRyYWN0IGNvbGxlY3Rpb24gc3VtbWFyaWVzIGZyb20gYmFzZWxpbmVcbiAgY29uc3QgY29sbGVjdGlvbnMgPSBleHRyYWN0Q29sbGVjdGlvblN1bW1hcmllcyhqc29uLmJhc2VsaW5lKTtcblxuICAvLyBDYWxjdWxhdGUgdG90YWwgdW5pcXVlIG1vZGVzIGFjcm9zcyBhbGwgY29sbGVjdGlvbnNcbiAgY29uc3QgYWxsTW9kZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29sbGVjdGlvbnMuZm9yRWFjaChjb2wgPT4gY29sLm1vZGVzLmZvckVhY2gobW9kZSA9PiBhbGxNb2Rlcy5hZGQobW9kZSkpKTtcblxuICByZXR1cm4ge1xuICAgIGlzQmFzZWxpbmU6IHRydWUsXG4gICAgbWV0YWRhdGE6IHtcbiAgICAgIHZlcnNpb246IG1ldGFkYXRhLnZlcnNpb24sXG4gICAgICBleHBvcnRlZEF0OiBtZXRhZGF0YS5leHBvcnRlZEF0LFxuICAgICAgcGx1Z2luVmVyc2lvbjogbWV0YWRhdGEucGx1Z2luVmVyc2lvbiB8fCAndW5rbm93bicsXG4gICAgICBmaWxlS2V5OiBtZXRhZGF0YS5maWxlS2V5IHx8IHVuZGVmaW5lZCxcbiAgICAgIGZpbGVOYW1lOiBtZXRhZGF0YS5maWxlTmFtZSB8fCB1bmRlZmluZWRcbiAgICB9LFxuICAgIGNvbGxlY3Rpb25zLFxuICAgIHRvdGFsVG9rZW5zOiBPYmplY3Qua2V5cyhqc29uLmJhc2VsaW5lKS5sZW5ndGgsXG4gICAgdG90YWxDb2xsZWN0aW9uczogY29sbGVjdGlvbnMubGVuZ3RoLFxuICAgIHRvdGFsTW9kZXM6IGFsbE1vZGVzLnNpemVcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGNvbGxlY3Rpb24gc3VtbWFyaWVzIGZyb20gYmFzZWxpbmUgZGF0YVxuICpcbiAqIEdyb3VwcyB0b2tlbnMgYnkgY29sbGVjdGlvbiBhbmQgY291bnRzIG1vZGVzL3Rva2VucyBwZXIgY29sbGVjdGlvblxuICpcbiAqIEBwYXJhbSBiYXNlbGluZSAtIEJhc2VsaW5lIHRva2VuIGRhdGEgb2JqZWN0XG4gKiBAcmV0dXJucyBBcnJheSBvZiBjb2xsZWN0aW9uIHN1bW1hcmllc1xuICovXG5mdW5jdGlvbiBleHRyYWN0Q29sbGVjdGlvblN1bW1hcmllcyhiYXNlbGluZTogYW55KTogQ29sbGVjdGlvblN1bW1hcnlbXSB7XG4gIGNvbnN0IGNvbGxlY3Rpb25NYXAgPSBuZXcgTWFwPHN0cmluZywge1xuICAgIG1vZGVzOiBTZXQ8c3RyaW5nPjtcbiAgICB0b2tlbkNvdW50OiBudW1iZXI7XG4gIH0+KCk7XG5cbiAgLy8gR3JvdXAgYnkgY29sbGVjdGlvbiBuYW1lXG4gIGZvciAoY29uc3QgW2tleSwgdG9rZW5dIG9mIE9iamVjdC5lbnRyaWVzKGJhc2VsaW5lKSkge1xuICAgIC8vIFNraXAgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKCF0b2tlbiB8fCB0eXBlb2YgdG9rZW4gIT09ICdvYmplY3QnKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbkRhdGEgPSB0b2tlbiBhcyBhbnk7XG4gICAgY29uc3QgY29sbGVjdGlvbk5hbWUgPSB0b2tlbkRhdGEuY29sbGVjdGlvbjtcbiAgICBjb25zdCBtb2RlTmFtZSA9IHRva2VuRGF0YS5tb2RlO1xuXG4gICAgLy8gU2tpcCB0b2tlbnMgd2l0aG91dCByZXF1aXJlZCBmaWVsZHNcbiAgICBpZiAoIWNvbGxlY3Rpb25OYW1lIHx8ICFtb2RlTmFtZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBjb2xsZWN0aW9uIGlmIG5vdCBleGlzdHNcbiAgICBpZiAoIWNvbGxlY3Rpb25NYXAuaGFzKGNvbGxlY3Rpb25OYW1lKSkge1xuICAgICAgY29sbGVjdGlvbk1hcC5zZXQoY29sbGVjdGlvbk5hbWUsIHtcbiAgICAgICAgbW9kZXM6IG5ldyBTZXQoKSxcbiAgICAgICAgdG9rZW5Db3VudDogMFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25NYXAuZ2V0KGNvbGxlY3Rpb25OYW1lKSE7XG4gICAgY29sbGVjdGlvbi5tb2Rlcy5hZGQobW9kZU5hbWUpO1xuICAgIGNvbGxlY3Rpb24udG9rZW5Db3VudCsrO1xuICB9XG5cbiAgLy8gQ29udmVydCB0byBhcnJheSBhbmQgc29ydCBieSBuYW1lIGZvciBjb25zaXN0ZW5jeVxuICByZXR1cm4gQXJyYXkuZnJvbShjb2xsZWN0aW9uTWFwLmVudHJpZXMoKSlcbiAgICAubWFwKChbbmFtZSwgZGF0YV0pID0+ICh7XG4gICAgICBuYW1lLFxuICAgICAgbW9kZUNvdW50OiBkYXRhLm1vZGVzLnNpemUsXG4gICAgICB0b2tlbkNvdW50OiBkYXRhLnRva2VuQ291bnQsXG4gICAgICBtb2RlczogQXJyYXkuZnJvbShkYXRhLm1vZGVzKS5zb3J0KClcbiAgICB9KSlcbiAgICAuc29ydCgoYSwgYikgPT4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKSk7XG59XG5cbi8qKlxuICogVmFsaWRhdGUgYmFzZWxpbmUgZm9ybWF0IHZlcnNpb24gY29tcGF0aWJpbGl0eVxuICpcbiAqIENoZWNrcyBpZiB0aGUgYmFzZWxpbmUgdmVyc2lvbiBpcyBjb21wYXRpYmxlIHdpdGggY3VycmVudCBwbHVnaW4gdmVyc2lvbi5cbiAqIE1ham9yIHZlcnNpb24gbXVzdCBtYXRjaCAodjIueC54KSwgbWlub3IvcGF0Y2ggZGlmZmVyZW5jZXMgYXJlIGFjY2VwdGFibGUuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBWZXJzaW9uIHN0cmluZyBmcm9tIGJhc2VsaW5lIG1ldGFkYXRhIChlLmcuLCBcIjIuMC4wXCIpXG4gKiBAcmV0dXJucyBDb21wYXRpYmlsaXR5IHJlc3VsdCB3aXRoIG9wdGlvbmFsIHdhcm5pbmcgbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWZXJzaW9uQ29tcGF0aWJsZSh2ZXJzaW9uOiBzdHJpbmcpOiBWZXJzaW9uQ29tcGF0aWJpbGl0eVJlc3VsdCB7XG4gIC8vIFBhcnNlIHZlcnNpb24gc3RyaW5nXG4gIGNvbnN0IHBhcnRzID0gdmVyc2lvbi5zcGxpdCgnLicpO1xuICBpZiAocGFydHMubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXRpYmxlOiBmYWxzZSxcbiAgICAgIHdhcm5pbmc6ICdJbnZhbGlkIHZlcnNpb24gZm9ybWF0J1xuICAgIH07XG4gIH1cblxuICBjb25zdCBtYWpvciA9IHBhcnNlSW50KHBhcnRzWzBdLCAxMCk7XG4gIGlmIChpc05hTihtYWpvcikpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGF0aWJsZTogZmFsc2UsXG4gICAgICB3YXJuaW5nOiAnSW52YWxpZCB2ZXJzaW9uIGZvcm1hdCdcbiAgICB9O1xuICB9XG5cbiAgY29uc3QgY3VycmVudE1ham9yID0gMjtcblxuICAvLyBSZWplY3Qgb2xkZXIgbWFqb3IgdmVyc2lvbnNcbiAgaWYgKG1ham9yIDwgY3VycmVudE1ham9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhdGlibGU6IGZhbHNlLFxuICAgICAgd2FybmluZzogYEJhc2VsaW5lIHZlcnNpb24gJHt2ZXJzaW9ufSBpcyBvdXRkYXRlZC4gQ3VycmVudCB2ZXJzaW9uIGlzICR7Y3VycmVudE1ham9yfS54LnhgXG4gICAgfTtcbiAgfVxuXG4gIC8vIFdhcm4gYWJvdXQgbmV3ZXIgbWFqb3IgdmVyc2lvbnMgYnV0IGFsbG93IGltcG9ydFxuICBpZiAobWFqb3IgPiBjdXJyZW50TWFqb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGF0aWJsZTogdHJ1ZSxcbiAgICAgIHdhcm5pbmc6IGBCYXNlbGluZSB3YXMgZXhwb3J0ZWQgZnJvbSBhIG5ld2VyIHZlcnNpb24gKCR7dmVyc2lvbn0pLiBTb21lIGZlYXR1cmVzIG1heSBub3QgYmUgc3VwcG9ydGVkLmBcbiAgICB9O1xuICB9XG5cbiAgLy8gU2FtZSBtYWpvciB2ZXJzaW9uIC0gZnVsbHkgY29tcGF0aWJsZVxuICByZXR1cm4geyBjb21wYXRpYmxlOiB0cnVlIH07XG59XG4iLCAiLyoqXG4gKiBNZXNzYWdlIEJyaWRnZVxuICogVHlwZS1zYWZlIGNvbW11bmljYXRpb24gbGF5ZXIgYmV0d2VlbiBVSSBhbmQgcGx1Z2luIGJhY2tlbmRcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFVJTWVzc2FnZSwgUGx1Z2luTWVzc2FnZSB9IGZyb20gJy4uLy4uL3R5cGVzL21lc3NhZ2UudHlwZXMuanMnO1xuXG4vKipcbiAqIE1lc3NhZ2UgaGFuZGxlciBjYWxsYmFja1xuICovXG5leHBvcnQgdHlwZSBNZXNzYWdlSGFuZGxlciA9IChtZXNzYWdlOiBQbHVnaW5NZXNzYWdlKSA9PiB2b2lkO1xuXG4vKipcbiAqIFJlZ2lzdGVyZWQgbWVzc2FnZSBoYW5kbGVyc1xuICovXG5jb25zdCBoYW5kbGVyczogU2V0PE1lc3NhZ2VIYW5kbGVyPiA9IG5ldyBTZXQoKTtcblxuLyoqXG4gKiBTZW5kIGEgbWVzc2FnZSB0byB0aGUgcGx1Z2luIGJhY2tlbmRcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVHlwZWQgbWVzc2FnZSB0byBzZW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kVG9CYWNrZW5kKG1lc3NhZ2U6IFVJTWVzc2FnZSk6IHZvaWQge1xuICBwYXJlbnQucG9zdE1lc3NhZ2UoeyBwbHVnaW5NZXNzYWdlOiBtZXNzYWdlIH0sICcqJyk7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciBtZXNzYWdlcyBmcm9tIHRoZSBiYWNrZW5kXG4gKiBAcGFyYW0gaGFuZGxlciAtIENhbGxiYWNrIHRvIGludm9rZSB3aGVuIG1lc3NhZ2VzIGFyZSByZWNlaXZlZFxuICogQHJldHVybnMgVW5zdWJzY3JpYmUgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uQmFja2VuZE1lc3NhZ2UoaGFuZGxlcjogTWVzc2FnZUhhbmRsZXIpOiAoKSA9PiB2b2lkIHtcbiAgaGFuZGxlcnMuYWRkKGhhbmRsZXIpO1xuICByZXR1cm4gKCkgPT4gaGFuZGxlcnMuZGVsZXRlKGhhbmRsZXIpO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemUgbWVzc2FnZSBicmlkZ2UgKHNldHMgdXAgZ2xvYmFsIG1lc3NhZ2UgbGlzdGVuZXIpXG4gKiBDYWxsIHRoaXMgb25jZSB3aGVuIHRoZSBVSSBsb2Fkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdE1lc3NhZ2VCcmlkZ2UoKTogdm9pZCB7XG4gIHdpbmRvdy5vbm1lc3NhZ2UgPSAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgIGNvbnN0IG1zZyA9IGV2ZW50LmRhdGEucGx1Z2luTWVzc2FnZTtcbiAgICBpZiAoIW1zZykgcmV0dXJuO1xuXG4gICAgLy8gTm90aWZ5IGFsbCByZWdpc3RlcmVkIGhhbmRsZXJzXG4gICAgaGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4gaGFuZGxlcihtc2cgYXMgUGx1Z2luTWVzc2FnZSkpO1xuICB9O1xufVxuXG4vKipcbiAqIFR5cGUgZ3VhcmRzIGZvciBzcGVjaWZpYyBtZXNzYWdlIHR5cGVzXG4gKi9cbmV4cG9ydCBjb25zdCBpc01lc3NhZ2UgPSB7XG4gIGNvbGxlY3Rpb25zTG9hZGVkOiAobXNnOiBQbHVnaW5NZXNzYWdlKTogbXNnIGlzIEV4dHJhY3Q8UGx1Z2luTWVzc2FnZSwgeyB0eXBlOiAnY29sbGVjdGlvbnMtbG9hZGVkJyB9PiA9PlxuICAgIG1zZy50eXBlID09PSAnY29sbGVjdGlvbnMtbG9hZGVkJyxcblxuICBsYXN0U3luY0xvYWRlZDogKG1zZzogUGx1Z2luTWVzc2FnZSk6IG1zZyBpcyBFeHRyYWN0PFBsdWdpbk1lc3NhZ2UsIHsgdHlwZTogJ2xhc3Qtc3luYy1sb2FkZWQnIH0+ID0+XG4gICAgbXNnLnR5cGUgPT09ICdsYXN0LXN5bmMtbG9hZGVkJyxcblxuICBpbXBvcnRDb21wbGV0ZTogKG1zZzogUGx1Z2luTWVzc2FnZSk6IG1zZyBpcyBFeHRyYWN0PFBsdWdpbk1lc3NhZ2UsIHsgdHlwZTogJ2ltcG9ydC1jb21wbGV0ZScgfT4gPT5cbiAgICBtc2cudHlwZSA9PT0gJ2ltcG9ydC1jb21wbGV0ZScsXG5cbiAgaW1wb3J0RXJyb3I6IChtc2c6IFBsdWdpbk1lc3NhZ2UpOiBtc2cgaXMgRXh0cmFjdDxQbHVnaW5NZXNzYWdlLCB7IHR5cGU6ICdpbXBvcnQtZXJyb3InIH0+ID0+XG4gICAgbXNnLnR5cGUgPT09ICdpbXBvcnQtZXJyb3InLFxuXG4gIGV4cG9ydENvbXBsZXRlOiAobXNnOiBQbHVnaW5NZXNzYWdlKTogbXNnIGlzIEV4dHJhY3Q8UGx1Z2luTWVzc2FnZSwgeyB0eXBlOiAnZXhwb3J0LWNvbXBsZXRlJyB9PiA9PlxuICAgIG1zZy50eXBlID09PSAnZXhwb3J0LWNvbXBsZXRlJyxcblxuICBleHBvcnRFcnJvcjogKG1zZzogUGx1Z2luTWVzc2FnZSk6IG1zZyBpcyBFeHRyYWN0PFBsdWdpbk1lc3NhZ2UsIHsgdHlwZTogJ2V4cG9ydC1lcnJvcicgfT4gPT5cbiAgICBtc2cudHlwZSA9PT0gJ2V4cG9ydC1lcnJvcicsXG5cbiAgc3luY0NvbXBsZXRlOiAobXNnOiBQbHVnaW5NZXNzYWdlKTogbXNnIGlzIEV4dHJhY3Q8UGx1Z2luTWVzc2FnZSwgeyB0eXBlOiAnc3luYy1jb21wbGV0ZScgfT4gPT5cbiAgICBtc2cudHlwZSA9PT0gJ3N5bmMtY29tcGxldGUnLFxuXG4gIHN5bmNFcnJvcjogKG1zZzogUGx1Z2luTWVzc2FnZSk6IG1zZyBpcyBFeHRyYWN0PFBsdWdpbk1lc3NhZ2UsIHsgdHlwZTogJ3N5bmMtZXJyb3InIH0+ID0+XG4gICAgbXNnLnR5cGUgPT09ICdzeW5jLWVycm9yJyxcbn07XG4iLCAiLyoqXG4gKiBCYXNlbGluZSBDb25maXJtYXRpb24gVUkgQ29tcG9uZW50XG4gKlxuICogU2hvd3MgY29uZmlybWF0aW9uIFVJIHdoZW4gYSBiYXNlbGluZSBmaWxlIGlzIGRldGVjdGVkIHdpdGggMyBzdGF0ZXM6XG4gKiAtIFZhbGlkIGJhc2VsaW5lOiBSZWFkeSB0byBpbXBvcnRcbiAqIC0gQnJva2VuIHJlZmVyZW5jZXM6IEJsb2NrcyBpbXBvcnQgd2l0aCBlcnJvciBkZXRhaWxzXG4gKiAtIFZlcnNpb24gd2FybmluZzogQWxsb3dzIGltcG9ydCB3aXRoIGNvbXBhdGliaWxpdHkgd2FybmluZ1xuICovXG5cbmltcG9ydCB7IGdldFN0YXRlLCBzZXRTdGF0ZSB9IGZyb20gJy4uL3N0YXRlLmpzJztcbmltcG9ydCB0eXBlIHsgQmFzZWxpbmVEZXRlY3Rpb25SZXN1bHQgfSBmcm9tICcuLi8uLi9iYWNrZW5kL3V0aWxzL2Jhc2VsaW5lLWRldGVjdG9yLmpzJztcbmltcG9ydCB0eXBlIHsgVmFsaWRhdGlvblJlc3VsdCB9IGZyb20gJy4uLy4uL2JhY2tlbmQvdXRpbHMvYmFzZWxpbmUtdmFsaWRhdG9yLmpzJztcbmltcG9ydCB0eXBlIHsgVXBsb2FkZWRGaWxlIH0gZnJvbSAnLi4vc3RhdGUuanMnO1xuaW1wb3J0IHsgaXNWZXJzaW9uQ29tcGF0aWJsZSB9IGZyb20gJy4uLy4uL2JhY2tlbmQvdXRpbHMvYmFzZWxpbmUtZGV0ZWN0b3IuanMnO1xuaW1wb3J0IHsgc2VuZFRvQmFja2VuZCB9IGZyb20gJy4uL3V0aWxzL21lc3NhZ2UtYnJpZGdlLmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBCYXNlbGluZUNvbmZpcm1hdGlvbk9wdGlvbnMge1xuICBkZXRlY3Rpb246IEJhc2VsaW5lRGV0ZWN0aW9uUmVzdWx0O1xuICB2YWxpZGF0aW9uOiBWYWxpZGF0aW9uUmVzdWx0O1xuICBvbkltcG9ydD86ICgpID0+IHZvaWQ7XG4gIG9uQ29uZmlndXJlTWFudWFsbHk/OiAoKSA9PiB2b2lkO1xufVxuXG4vKipcbiAqIFJlbmRlciBiYXNlbGluZSBjb25maXJtYXRpb24gVUlcbiAqXG4gKiBEaXNwbGF5cyBhcHByb3ByaWF0ZSBVSSBiYXNlZCBvbiB2YWxpZGF0aW9uIHN0YXR1cyBhbmQgdmVyc2lvbiBjb21wYXRpYmlsaXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJCYXNlbGluZUNvbmZpcm1hdGlvbihvcHRpb25zOiBCYXNlbGluZUNvbmZpcm1hdGlvbk9wdGlvbnMpOiB2b2lkIHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Jhc2VsaW5lQ29uZmlybWF0aW9uU2VjdGlvbicpO1xuICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICBpZiAoIW9wdGlvbnMudmFsaWRhdGlvbi52YWxpZCkge1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSByZW5kZXJCcm9rZW5SZWZlcmVuY2VzVUkob3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoaGFzVmVyc2lvbldhcm5pbmcob3B0aW9ucy5kZXRlY3Rpb24pKSB7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IHJlbmRlclZlcnNpb25XYXJuaW5nVUkob3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLmlubmVySFRNTCA9IHJlbmRlclZhbGlkQmFzZWxpbmVVSShvcHRpb25zKTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgYXR0YWNoQmFzZWxpbmVFdmVudExpc3RlbmVycyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdmFsaWQgYmFzZWxpbmUgVUlcbiAqXG4gKiBTaG93cyBjb2xsZWN0aW9uIHN1bW1hcnkgd2l0aCBtZXRhZGF0YSBhbmQgaW1wb3J0IGNvbmZpcm1hdGlvblxuICovXG5mdW5jdGlvbiByZW5kZXJWYWxpZEJhc2VsaW5lVUkob3B0aW9uczogQmFzZWxpbmVDb25maXJtYXRpb25PcHRpb25zKTogc3RyaW5nIHtcbiAgY29uc3QgeyBkZXRlY3Rpb24gfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGV4cG9ydGVkRGF0ZSA9IGZvcm1hdERhdGUoZGV0ZWN0aW9uLm1ldGFkYXRhIS5leHBvcnRlZEF0KTtcblxuICByZXR1cm4gYFxuICAgIDxkaXYgY2xhc3M9XCJiYXNlbGluZS1jb25maXJtYXRpb24gdmFsaWRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJiYXNlbGluZS1oZWFkZXJcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGF0dXMtaWNvblwiPlx1MjcwNTwvc3Bhbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJhc2VsaW5lLXRpdGxlXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZpbGVuYW1lXCI+QmFzZWxpbmUgZXhwb3J0IGZpbGUgZGV0ZWN0ZWQ8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZS1pbmZvXCI+RXhwb3J0ZWQ6ICR7ZXhwb3J0ZWREYXRlfSBcdTIwMjIgVmVyc2lvbjogdiR7ZGV0ZWN0aW9uLm1ldGFkYXRhIS52ZXJzaW9ufTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiYmFzZWxpbmUtY29udGVudFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sbGVjdGlvbnMtc3VtbWFyeVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdW1tYXJ5LXRpdGxlXCI+XHVEODNEXHVEQ0NBIENvbnRhaW5zOjwvZGl2PlxuICAgICAgICAgICR7ZGV0ZWN0aW9uLmNvbGxlY3Rpb25zIS5tYXAoYyA9PiBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sbGVjdGlvbi1pdGVtXCI+XG4gICAgICAgICAgICAgIFx1MjAyMiAke2MubmFtZX0gKCR7Yy5tb2RlQ291bnR9IG1vZGUke2MubW9kZUNvdW50ID4gMSA/ICdzJyA6ICcnfSwgJHtjLnRva2VuQ291bnR9IHRva2VucylcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIGApLmpvaW4oJycpfVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidmFsaWRhdGlvbi1zdGF0dXNcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RhdHVzLWl0ZW0gdmFsaWRcIj5cdTI3MTMgTm8gYnJva2VuIHJlZmVyZW5jZXM8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RhdHVzLWl0ZW0gdmFsaWRcIj5cdTI3MTMgQWxsIGFsaWFzZXMgdmFsaWQ8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbmZpcm1hdGlvbi1xdWVzdGlvblwiPlxuICAgICAgICAgIEltcG9ydCBhcyBvcmlnaW5hbGx5IGV4cG9ydGVkP1xuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiYmFzZWxpbmUtYWN0aW9uc1wiPlxuICAgICAgICA8YnV0dG9uIGlkPVwiaW1wb3J0QmFzZWxpbmVCdG5cIiBjbGFzcz1cImJ1dHRvbiBidXR0b24tcHJpbWFyeVwiPlxuICAgICAgICAgIFx1MjcxMyBZZXMsIEltcG9ydCBhcy1pc1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBpZD1cImNvbmZpZ3VyZU1hbnVhbGx5QnRuXCIgY2xhc3M9XCJidXR0b24gYnV0dG9uLXNlY29uZGFyeVwiPlxuICAgICAgICAgIENvbmZpZ3VyZSBNYW51YWxseVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xufVxuXG4vKipcbiAqIFJlbmRlciBicm9rZW4gcmVmZXJlbmNlcyBVSSAoYmxvY2tzIGltcG9ydClcbiAqXG4gKiBTaG93cyBkZXRhaWxlZCBlcnJvciBpbmZvcm1hdGlvbiBmb3IgYnJva2VuIGFsaWFzIHJlZmVyZW5jZXNcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQnJva2VuUmVmZXJlbmNlc1VJKG9wdGlvbnM6IEJhc2VsaW5lQ29uZmlybWF0aW9uT3B0aW9ucyk6IHN0cmluZyB7XG4gIGNvbnN0IHsgdmFsaWRhdGlvbiB9ID0gb3B0aW9ucztcblxuICByZXR1cm4gYFxuICAgIDxkaXYgY2xhc3M9XCJiYXNlbGluZS1jb25maXJtYXRpb24gYmxvY2tlZFwiPlxuICAgICAgPGRpdiBjbGFzcz1cImJhc2VsaW5lLWhlYWRlciBlcnJvclwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInN0YXR1cy1pY29uXCI+XHUyNkQ0PC9zcGFuPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiYmFzZWxpbmUtdGl0bGVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZW5hbWVcIj5DYW5ub3QgSW1wb3J0IC0gQnJva2VuIFJlZmVyZW5jZXM8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZS1pbmZvXCI+VmVyc2lvbjogdiR7b3B0aW9ucy5kZXRlY3Rpb24ubWV0YWRhdGE/LnZlcnNpb24gfHwgJ3Vua25vd24nfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiYmFzZWxpbmUtY29udGVudFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXJyb3Itc3VtbWFyeVwiPlxuICAgICAgICAgIFx1Mjc0QyBGb3VuZCAke3ZhbGlkYXRpb24uYnJva2VuQWxpYXNlcy5sZW5ndGh9IGJyb2tlbiBhbGlhcyByZWZlcmVuY2Uke3ZhbGlkYXRpb24uYnJva2VuQWxpYXNlcy5sZW5ndGggPiAxID8gJ3MnIDogJyd9OlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiYnJva2VuLWFsaWFzZXMtbGlzdFwiPlxuICAgICAgICAgICR7dmFsaWRhdGlvbi5icm9rZW5BbGlhc2VzLnNsaWNlKDAsIDUpLm1hcChhbGlhcyA9PiBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnJva2VuLWFsaWFzLWl0ZW1cIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFsaWFzLXBhdGhcIj5cdTIwMjIgJHthbGlhcy50b2tlblBhdGh9PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhbGlhcy1lcnJvclwiPlx1MjE5MiBSZWZlcmVuY2VzOiAke2FsaWFzLmFsaWFzUmVmZXJlbmNlfTwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYWxpYXMtZXJyb3JcIj5cdTIxOTIgRXJyb3I6ICR7YWxpYXMuZXJyb3J9PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICBgKS5qb2luKCcnKX1cbiAgICAgICAgICAke3ZhbGlkYXRpb24uYnJva2VuQWxpYXNlcy5sZW5ndGggPiA1ID8gYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vcmUtZXJyb3JzXCI+XG4gICAgICAgICAgICAgIC4uLiBhbmQgJHt2YWxpZGF0aW9uLmJyb2tlbkFsaWFzZXMubGVuZ3RoIC0gNX0gbW9yZVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgYCA6ICcnfVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiZml4LWluc3RydWN0aW9uc1wiPlxuICAgICAgICAgIFx1MjZBMFx1RkUwRiBGaXggcmVxdWlyZWQ6XG4gICAgICAgICAgPG9sPlxuICAgICAgICAgICAgPGxpPlJlc3RvcmUgZGVsZXRlZCB0b2tlbnMsIE9SPC9saT5cbiAgICAgICAgICAgIDxsaT5VcGRhdGUgYWxpYXNlcyB0byB2YWxpZCByZWZlcmVuY2VzLCBPUjwvbGk+XG4gICAgICAgICAgICA8bGk+Q29udmVydCBhbGlhc2VzIHRvIGhhcmRjb2RlZCB2YWx1ZXM8L2xpPlxuICAgICAgICAgIDwvb2w+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJiYXNlbGluZS1hY3Rpb25zXCI+XG4gICAgICAgIDxidXR0b24gaWQ9XCJjbG9zZUJhc2VsaW5lQnRuXCIgY2xhc3M9XCJidXR0b24gYnV0dG9uLXNlY29uZGFyeVwiPlxuICAgICAgICAgIENsb3NlXG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG59XG5cbi8qKlxuICogUmVuZGVyIHZlcnNpb24gd2FybmluZyBVSVxuICpcbiAqIFNob3dzIGNvbXBhdGliaWxpdHkgd2FybmluZyBidXQgYWxsb3dzIGltcG9ydFxuICovXG5mdW5jdGlvbiByZW5kZXJWZXJzaW9uV2FybmluZ1VJKG9wdGlvbnM6IEJhc2VsaW5lQ29uZmlybWF0aW9uT3B0aW9ucyk6IHN0cmluZyB7XG4gIGNvbnN0IHsgZGV0ZWN0aW9uIH0gPSBvcHRpb25zO1xuICBjb25zdCBwbHVnaW5WZXJzaW9uID0gJzIuMC4wJzsgLy8gQ3VycmVudCBwbHVnaW4gdmVyc2lvblxuICBjb25zdCBjb21wYXRpYmlsaXR5ID0gaXNWZXJzaW9uQ29tcGF0aWJsZShkZXRlY3Rpb24ubWV0YWRhdGEhLnZlcnNpb24pO1xuXG4gIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cImJhc2VsaW5lLWNvbmZpcm1hdGlvbiB3YXJuaW5nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiYmFzZWxpbmUtaGVhZGVyIHdhcm5pbmdcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzdGF0dXMtaWNvblwiPlx1MjZBMFx1RkUwRjwvc3Bhbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJhc2VsaW5lLXRpdGxlXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZpbGVuYW1lXCI+VmVyc2lvbiBNaXNtYXRjaCBXYXJuaW5nPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZpbGUtaW5mb1wiPlxuICAgICAgICAgICAgQmFzZWxpbmU6IHYke2RldGVjdGlvbi5tZXRhZGF0YSEudmVyc2lvbn0gXHUyMDIyIFBsdWdpbjogdiR7cGx1Z2luVmVyc2lvbn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cImJhc2VsaW5lLWNvbnRlbnRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIndhcm5pbmctbWVzc2FnZVwiPlxuICAgICAgICAgICR7Y29tcGF0aWJpbGl0eS53YXJuaW5nIHx8ICdcdTI2QTBcdUZFMEYgVGhpcyBiYXNlbGluZSB3YXMgZXhwb3J0ZWQgZnJvbSBhIGRpZmZlcmVudCBwbHVnaW4gdmVyc2lvbi4gU29tZSBmZWF0dXJlcyBtYXkgbm90IGJlIHN1cHBvcnRlZC4nfVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29sbGVjdGlvbnMtc3VtbWFyeVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdW1tYXJ5LXRpdGxlXCI+XHVEODNEXHVEQ0NBIENvbnRhaW5zOjwvZGl2PlxuICAgICAgICAgICR7ZGV0ZWN0aW9uLmNvbGxlY3Rpb25zIS5tYXAoYyA9PiBgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sbGVjdGlvbi1pdGVtXCI+XG4gICAgICAgICAgICAgIFx1MjAyMiAke2MubmFtZX0gKCR7Yy5tb2RlQ291bnR9IG1vZGUke2MubW9kZUNvdW50ID4gMSA/ICdzJyA6ICcnfSwgJHtjLnRva2VuQ291bnR9IHRva2VucylcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIGApLmpvaW4oJycpfVxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiY29uZmlybWF0aW9uLXF1ZXN0aW9uXCI+XG4gICAgICAgICAgQ29udGludWUgd2l0aCBpbXBvcnQ/XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJiYXNlbGluZS1hY3Rpb25zXCI+XG4gICAgICAgIDxidXR0b24gaWQ9XCJjYW5jZWxCYXNlbGluZUJ0blwiIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1zZWNvbmRhcnlcIj5cbiAgICAgICAgICBDYW5jZWxcbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gaWQ9XCJpbXBvcnRBbnl3YXlCdG5cIiBjbGFzcz1cImJ1dHRvbiBidXR0b24tcHJpbWFyeVwiPlxuICAgICAgICAgIEltcG9ydCBBbnl3YXlcbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYDtcbn1cblxuLyoqXG4gKiBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIGJhc2VsaW5lIGNvbmZpcm1hdGlvbiBidXR0b25zXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEJhc2VsaW5lRXZlbnRMaXN0ZW5lcnMob3B0aW9uczogQmFzZWxpbmVDb25maXJtYXRpb25PcHRpb25zKTogdm9pZCB7XG4gIGNvbnN0IGltcG9ydEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbXBvcnRCYXNlbGluZUJ0bicpO1xuICBjb25zdCBpbXBvcnRBbnl3YXlCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW1wb3J0QW55d2F5QnRuJyk7XG4gIGNvbnN0IGNvbmZpZ3VyZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb25maWd1cmVNYW51YWxseUJ0bicpO1xuICBjb25zdCBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FuY2VsQmFzZWxpbmVCdG4nKTtcbiAgY29uc3QgY2xvc2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2xvc2VCYXNlbGluZUJ0bicpO1xuXG4gIGlmIChpbXBvcnRCdG4gfHwgaW1wb3J0QW55d2F5QnRuKSB7XG4gICAgKGltcG9ydEJ0biB8fCBpbXBvcnRBbnl3YXlCdG4pIS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGhhbmRsZUltcG9ydEJhc2VsaW5lKG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNvbmZpZ3VyZUJ0biB8fCBjYW5jZWxCdG4gfHwgY2xvc2VCdG4pIHtcbiAgICAoY29uZmlndXJlQnRuIHx8IGNhbmNlbEJ0biB8fCBjbG9zZUJ0bikhLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgaGlkZUJhc2VsaW5lQ29uZmlybWF0aW9uKCk7XG4gICAgICBvcHRpb25zLm9uQ29uZmlndXJlTWFudWFsbHk/LigpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGltcG9ydCBiYXNlbGluZSBhY3Rpb25cbiAqXG4gKiBTZW5kcyB0aGUgYmFzZWxpbmUgZmlsZSB0byB0aGUgYmFja2VuZCBmb3IgaW1wb3J0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUltcG9ydEJhc2VsaW5lKG9wdGlvbnM6IEJhc2VsaW5lQ29uZmlybWF0aW9uT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG5cbiAgLy8gRmluZCB0aGUgYmFzZWxpbmUgZmlsZSBpbiB1cGxvYWRlZCBmaWxlc1xuICBsZXQgYmFzZWxpbmVGaWxlOiBVcGxvYWRlZEZpbGUgfCB1bmRlZmluZWQ7XG5cbiAgZm9yIChjb25zdCBbbmFtZSwgZmlsZV0gb2Ygc3RhdGUuZmlsZXMuZW50cmllcygpKSB7XG4gICAgYmFzZWxpbmVGaWxlID0gZmlsZTtcbiAgICBicmVhazsgLy8gRm9yIG5vdywgYXNzdW1lIGZpcnN0IGZpbGUgaXMgdGhlIGJhc2VsaW5lXG4gIH1cblxuICBpZiAoIWJhc2VsaW5lRmlsZSkge1xuICAgIHNob3dOb3RpZmljYXRpb24oJ1x1Mjc0QyBGaWxlIG5vdCBmb3VuZCcsICdlcnJvcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgc2hvd05vdGlmaWNhdGlvbignQW5hbHl6aW5nIGNoYW5nZXMuLi4nKTtcblxuICAgIC8vIFNlbmQgbWVzc2FnZSB0byBiYWNrZW5kIHRvIHByZXZpZXcgaW1wb3J0IChzaG93cyBkaWZmIGJlZm9yZSBhcHBseWluZylcbiAgICBzZW5kVG9CYWNrZW5kKHtcbiAgICAgIHR5cGU6ICdwcmV2aWV3LWJhc2VsaW5lLWltcG9ydCcsXG4gICAgICBiYXNlbGluZTogYmFzZWxpbmVGaWxlLmNvbnRlbnRcbiAgICB9KTtcblxuICAgIC8vIFRoZSByZXN1bHQgd2lsbCBjb21lIGJhY2sgdmlhICdpbXBvcnQtY2hhbmdlcy1kZXRlY3RlZCcgbWVzc2FnZVxuICAgIC8vIEhpZGUgdGhlIGNvbmZpcm1hdGlvbiBVSSAtIHRoZSBpbXBvcnQgZGlmZiBtb2RhbCB3aWxsIHNob3dcbiAgICBoaWRlQmFzZWxpbmVDb25maXJtYXRpb24oKTtcbiAgICBvcHRpb25zLm9uSW1wb3J0Py4oKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBzaG93Tm90aWZpY2F0aW9uKGBcdTI3NEMgSW1wb3J0IGVycm9yOiAkeyhlcnJvciBhcyBFcnJvcikubWVzc2FnZX1gLCAnZXJyb3InKTtcbiAgfVxufVxuXG4vKipcbiAqIEhpZGUgYmFzZWxpbmUgY29uZmlybWF0aW9uIFVJXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoaWRlQmFzZWxpbmVDb25maXJtYXRpb24oKTogdm9pZCB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdiYXNlbGluZUNvbmZpcm1hdGlvblNlY3Rpb24nKTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IGRhdGUgc3RyaW5nIGZvciBkaXNwbGF5XG4gKlxuICogQ29udmVydHMgSVNPIHN0cmluZyB0byBodW1hbi1yZWFkYWJsZSBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlU3RyaW5nOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUoZGF0ZVN0cmluZyk7XG4gIHJldHVybiBkYXRlLnRvTG9jYWxlRGF0ZVN0cmluZygnZW4tVVMnLCB7XG4gICAgbW9udGg6ICdzaG9ydCcsXG4gICAgZGF5OiAnbnVtZXJpYycsXG4gICAgeWVhcjogJ251bWVyaWMnLFxuICAgIGhvdXI6ICcyLWRpZ2l0JyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0J1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2ZXJzaW9uIHdhcm5pbmcgc2hvdWxkIGJlIHNob3duXG4gKlxuICogQ29tcGFyZXMgYmFzZWxpbmUgdmVyc2lvbiB3aXRoIGN1cnJlbnQgcGx1Z2luIHZlcnNpb25cbiAqL1xuZnVuY3Rpb24gaGFzVmVyc2lvbldhcm5pbmcoZGV0ZWN0aW9uOiBCYXNlbGluZURldGVjdGlvblJlc3VsdCk6IGJvb2xlYW4ge1xuICBpZiAoIWRldGVjdGlvbi5tZXRhZGF0YSkgcmV0dXJuIGZhbHNlO1xuXG4gIGNvbnN0IGNvbXBhdGliaWxpdHkgPSBpc1ZlcnNpb25Db21wYXRpYmxlKGRldGVjdGlvbi5tZXRhZGF0YS52ZXJzaW9uKTtcbiAgcmV0dXJuIGNvbXBhdGliaWxpdHkuY29tcGF0aWJsZSAmJiAhIWNvbXBhdGliaWxpdHkud2FybmluZztcbn1cblxuLyoqXG4gKiBTaG93IG5vdGlmaWNhdGlvbiB0byB1c2VyXG4gKlxuICogU2ltcGxlIFVJIG5vdGlmaWNhdGlvbiAoaW4gcHJvZHVjdGlvbiwgdGhpcyBjb3VsZCBiZSBlbmhhbmNlZCB3aXRoIGEgdG9hc3QgY29tcG9uZW50KVxuICovXG5mdW5jdGlvbiBzaG93Tm90aWZpY2F0aW9uKG1lc3NhZ2U6IHN0cmluZywgdHlwZTogJ2Vycm9yJyB8ICdzdWNjZXNzJyB8ICdpbmZvJyA9ICdpbmZvJyk6IHZvaWQge1xuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGFsZXJ0KG1lc3NhZ2UpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGBbJHt0eXBlfV0gJHttZXNzYWdlfWApO1xuICB9XG59XG4iLCAiLyoqXG4gKiBTeW5jIENoYW5nZXMgRGlmZiBDb21wb25lbnRcbiAqXG4gKiBEaXNwbGF5cyBkZXRlY3RlZCBjaGFuZ2VzIGJldHdlZW4gY3VycmVudCBGaWdtYSB0b2tlbnMgYW5kIHByZXZpb3VzIGJhc2VsaW5lLFxuICogc2hvd2luZyB2ZXJzaW9uIGJ1bXAgc3VnZ2VzdGlvbnMgYW5kIGFsbG93aW5nIG1hbnVhbCB2ZXJzaW9uIG92ZXJyaWRlLlxuICovXG5cbmltcG9ydCB0eXBlIHsgVmVyc2lvbkJ1bXAsIFRva2VuQ2hhbmdlIH0gZnJvbSAnLi4vLi4vYmFja2VuZC91dGlscy92ZXJzaW9uLW1hbmFnZXIuanMnO1xuaW1wb3J0IHsgc2VuZE1lc3NhZ2UgfSBmcm9tICcuLi9tZXNzYWdlLWJyaWRnZS5qcyc7XG5cbi8qKlxuICogUmVuZGVyIHN5bmMgY2hhbmdlcyBkaWZmIFVJXG4gKiBAcGFyYW0gdmVyc2lvbkJ1bXAgLSBWZXJzaW9uIGJ1bXAgZGF0YSB3aXRoIGNoYW5nZXMgYW5kIHN1Z2dlc3RlZCB2ZXJzaW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJTeW5jQ2hhbmdlc0RpZmYodmVyc2lvbkJ1bXA6IFZlcnNpb25CdW1wKTogdm9pZCB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzeW5jQ2hhbmdlc1NlY3Rpb24nKTtcbiAgaWYgKCFjb250YWluZXIpIHJldHVybjtcblxuICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cInN5bmMtY2hhbmdlc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cImNoYW5nZXMtaGVhZGVyXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPlx1RDgzRFx1RENDQTwvc3Bhbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+Q2hhbmdlcyBEZXRlY3RlZDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJjaGFuZ2VzLWNvbnRlbnRcIj5cbiAgICAgICAgJHtyZW5kZXJDaGFuZ2VTZWN0aW9uKCdicmVha2luZycsIHZlcnNpb25CdW1wLmNoYW5nZXMsICdcdUQ4M0RcdUREMzQgQnJlYWtpbmcgQ2hhbmdlcycsICdNQUpPUicpfVxuICAgICAgICAke3JlbmRlckNoYW5nZVNlY3Rpb24oJ2FkZGl0aW9uJywgdmVyc2lvbkJ1bXAuY2hhbmdlcywgJ1x1RDgzRFx1REZFMSBOZXcgQWRkaXRpb25zJywgJ01JTk9SJyl9XG4gICAgICAgICR7cmVuZGVyQ2hhbmdlU2VjdGlvbigncGF0Y2gnLCB2ZXJzaW9uQnVtcC5jaGFuZ2VzLCAnXHVEODNEXHVERkUyIFZhbHVlIFVwZGF0ZXMnLCAnUEFUQ0gnKX1cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidmVyc2lvbi1idW1wLWJveFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJidW1wLXRpdGxlXCI+VmVyc2lvbiBCdW1wPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImJ1bXAtZGlzcGxheVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2ZXJzaW9uLWN1cnJlbnRcIj4ke3ZlcnNpb25CdW1wLmN1cnJlbnR9PC9zcGFuPlxuICAgICAgICAgICAgXHUyMTkyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInZlcnNpb24tbmV3XCI+JHt2ZXJzaW9uQnVtcC5zdWdnZXN0ZWR9ICgke3ZlcnNpb25CdW1wLmNoYW5nZVR5cGUudG9VcHBlckNhc2UoKX0pPC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGRpdiBjbGFzcz1cInZlcnNpb24tb3ZlcnJpZGVcIj5cbiAgICAgICAgICAgIDxsYWJlbD5PdmVycmlkZTo8L2xhYmVsPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZlcnNpb24taW5wdXRzXCI+XG4gICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgaWQ9XCJ2ZXJzaW9uTWFqb3JcIiB2YWx1ZT1cIiR7dmVyc2lvbkJ1bXAuc3VnZ2VzdGVkLnNwbGl0KCcuJylbMF19XCIgbWluPVwiMFwiIC8+XG4gICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJudW1iZXJcIiBpZD1cInZlcnNpb25NaW5vclwiIHZhbHVlPVwiJHt2ZXJzaW9uQnVtcC5zdWdnZXN0ZWQuc3BsaXQoJy4nKVsxXX1cIiBtaW49XCIwXCIgLz5cbiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cIm51bWJlclwiIGlkPVwidmVyc2lvblBhdGNoXCIgdmFsdWU9XCIke3ZlcnNpb25CdW1wLnN1Z2dlc3RlZC5zcGxpdCgnLicpWzJdfVwiIG1pbj1cIjBcIiAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJzeW5jLWFjdGlvbnNcIj5cbiAgICAgICAgPGJ1dHRvbiBpZD1cImNhbmNlbFN5bmNCdG5cIiBjbGFzcz1cImJ1dHRvbiBidXR0b24tc2Vjb25kYXJ5XCI+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgIDxidXR0b24gaWQ9XCJzeW5jTm93QnRuXCIgY2xhc3M9XCJidXR0b24gYnV0dG9uLXByaW1hcnlcIj5TeW5jIE5vdyAodiR7dmVyc2lvbkJ1bXAuc3VnZ2VzdGVkfSk8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xuXG4gIGF0dGFjaFN5bmNFdmVudExpc3RlbmVycyh2ZXJzaW9uQnVtcCk7XG59XG5cbi8qKlxuICogUmVuZGVyIGEgY2hhbmdlIHNlY3Rpb24gZm9yIGEgc3BlY2lmaWMgY2hhbmdlIHR5cGVcbiAqIEBwYXJhbSB0eXBlIC0gQ2hhbmdlIHR5cGUgdG8gZmlsdGVyIGJ5XG4gKiBAcGFyYW0gYWxsQ2hhbmdlcyAtIEFsbCBkZXRlY3RlZCBjaGFuZ2VzXG4gKiBAcGFyYW0gdGl0bGUgLSBTZWN0aW9uIHRpdGxlIHdpdGggZW1vamlcbiAqIEBwYXJhbSBiYWRnZSAtIEJhZGdlIHRleHQgKE1BSk9SLCBNSU5PUiwgUEFUQ0gpXG4gKiBAcmV0dXJucyBIVE1MIHN0cmluZyBmb3IgdGhlIHNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ2hhbmdlU2VjdGlvbihcbiAgdHlwZTogJ2JyZWFraW5nJyB8ICdhZGRpdGlvbicgfCAncGF0Y2gnLFxuICBhbGxDaGFuZ2VzOiBUb2tlbkNoYW5nZVtdLFxuICB0aXRsZTogc3RyaW5nLFxuICBiYWRnZTogc3RyaW5nXG4pOiBzdHJpbmcge1xuICBjb25zdCBjaGFuZ2VzID0gYWxsQ2hhbmdlcy5maWx0ZXIoYyA9PiBjLnR5cGUgPT09IHR5cGUpO1xuXG4gIGlmIChjaGFuZ2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuXG4gIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cImNoYW5nZS1zZWN0aW9uICR7dHlwZX1cIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWhlYWRlclwiPlxuICAgICAgICAke3RpdGxlfSAoJHtjaGFuZ2VzLmxlbmd0aH0pIFx1MjE5MiAke2JhZGdlfVxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1pdGVtc1wiPlxuICAgICAgICAke2NoYW5nZXMuc2xpY2UoMCwgNSkubWFwKGNoYW5nZSA9PiBgXG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNoYW5nZS1pdGVtXCI+XG4gICAgICAgICAgICBcdTIwMjIgJHtlc2NhcGVIdG1sKGNoYW5nZS5kZXNjcmlwdGlvbil9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIGApLmpvaW4oJycpfVxuICAgICAgICAke2NoYW5nZXMubGVuZ3RoID4gNSA/IGBcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9yZS1jaGFuZ2VzXCI+XG4gICAgICAgICAgICAuLi4gYW5kICR7Y2hhbmdlcy5sZW5ndGggLSA1fSBtb3JlXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIGAgOiAnJ31cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xufVxuXG4vKipcbiAqIEF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG8gc3luYyBkaWZmIFVJIGVsZW1lbnRzXG4gKiBAcGFyYW0gdmVyc2lvbkJ1bXAgLSBWZXJzaW9uIGJ1bXAgZGF0YSBmb3Igc3luYyBvcGVyYXRpb25cbiAqL1xuZnVuY3Rpb24gYXR0YWNoU3luY0V2ZW50TGlzdGVuZXJzKHZlcnNpb25CdW1wOiBWZXJzaW9uQnVtcCk6IHZvaWQge1xuICBjb25zdCBzeW5jQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNOb3dCdG4nKTtcbiAgY29uc3QgY2FuY2VsQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbmNlbFN5bmNCdG4nKTtcblxuICAvLyBWZXJzaW9uIG92ZXJyaWRlIGlucHV0c1xuICBjb25zdCBtYWpvcklucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZlcnNpb25NYWpvcicpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gIGNvbnN0IG1pbm9ySW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmVyc2lvbk1pbm9yJykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgY29uc3QgcGF0Y2hJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2ZXJzaW9uUGF0Y2gnKSBhcyBIVE1MSW5wdXRFbGVtZW50O1xuXG4gIGNvbnN0IHVwZGF0ZVN5bmNCdXR0b24gPSAoKSA9PiB7XG4gICAgY29uc3QgdmVyc2lvbiA9IGAke21ham9ySW5wdXQudmFsdWV9LiR7bWlub3JJbnB1dC52YWx1ZX0uJHtwYXRjaElucHV0LnZhbHVlfWA7XG4gICAgaWYgKHN5bmNCdG4pIHtcbiAgICAgIHN5bmNCdG4udGV4dENvbnRlbnQgPSBgU3luYyBOb3cgKHYke3ZlcnNpb259KWA7XG4gICAgfVxuICB9O1xuXG4gIFttYWpvcklucHV0LCBtaW5vcklucHV0LCBwYXRjaElucHV0XS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlU3luY0J1dHRvbik7XG4gICAgfVxuICB9KTtcblxuICBpZiAoc3luY0J0bikge1xuICAgIHN5bmNCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBuZXdWZXJzaW9uID0gYCR7bWFqb3JJbnB1dC52YWx1ZX0uJHttaW5vcklucHV0LnZhbHVlfS4ke3BhdGNoSW5wdXQudmFsdWV9YDtcbiAgICAgIGF3YWl0IGhhbmRsZVN5bmNOb3cobmV3VmVyc2lvbiwgdmVyc2lvbkJ1bXApO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNhbmNlbEJ0bikge1xuICAgIGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGhpZGVTeW5jQ2hhbmdlc0RpZmYoKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBzeW5jIG5vdyBhY3Rpb24gLSB0cmlnZ2VycyBiYWNrZW5kIHN5bmMgd2l0aCBuZXcgdmVyc2lvblxuICogQHBhcmFtIG5ld1ZlcnNpb24gLSBWZXJzaW9uIHRvIHVzZSBmb3IgdGhlIHN5bmNcbiAqIEBwYXJhbSB2ZXJzaW9uQnVtcCAtIE9yaWdpbmFsIHZlcnNpb24gYnVtcCBkYXRhXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVN5bmNOb3cobmV3VmVyc2lvbjogc3RyaW5nLCB2ZXJzaW9uQnVtcDogVmVyc2lvbkJ1bXApOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICAvLyBTZW5kIHN5bmMgbWVzc2FnZSB3aXRoIHZlcnNpb24gb3ZlcnJpZGVcbiAgICBzZW5kTWVzc2FnZSh7XG4gICAgICB0eXBlOiAnc3luYy13aXRoLXZlcnNpb24nLFxuICAgICAgdmVyc2lvbjogbmV3VmVyc2lvbixcbiAgICAgIGNoYW5nZXM6IHZlcnNpb25CdW1wLmNoYW5nZXNcbiAgICB9IGFzIGFueSk7IC8vIFRPRE86IFVwZGF0ZSBVSU1lc3NhZ2UgdHlwZVxuXG4gICAgLy8gVUkgd2lsbCBiZSB1cGRhdGVkIHdoZW4gc3luYy1jb21wbGV0ZSBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gICAgaGlkZVN5bmNDaGFuZ2VzRGlmZigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1N5bmMgZmFpbGVkOicsIGVycm9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEhpZGUgc3luYyBjaGFuZ2VzIGRpZmYgVUlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhpZGVTeW5jQ2hhbmdlc0RpZmYoKTogdm9pZCB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzeW5jQ2hhbmdlc1NlY3Rpb24nKTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBIVE1MIHNwZWNpYWwgY2hhcmFjdGVycyB0byBwcmV2ZW50IFhTU1xuICogQHBhcmFtIHRleHQgLSBUZXh0IHRvIGVzY2FwZVxuICogQHJldHVybnMgRXNjYXBlZCB0ZXh0IHNhZmUgZm9yIEhUTUwgaW5zZXJ0aW9uXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MO1xufVxuIiwgIi8qKlxuICogSW1wb3J0IENoYW5nZXMgRGlmZiBDb21wb25lbnRcbiAqXG4gKiBEaXNwbGF5cyBkZXRlY3RlZCBjaGFuZ2VzIGJldHdlZW4gaW1wb3J0ZWQgYmFzZWxpbmUgYW5kIGN1cnJlbnQgRmlnbWEgc3RhdGUsXG4gKiBhbGxvd2luZyB1c2VycyB0byBwcmV2aWV3IHdoYXQgd2lsbCBjaGFuZ2UgYmVmb3JlIGFwcGx5aW5nIHRoZSBpbXBvcnQuXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBWZXJzaW9uQnVtcCwgVG9rZW5DaGFuZ2UgfSBmcm9tICcuLi8uLi9iYWNrZW5kL3V0aWxzL3ZlcnNpb24tbWFuYWdlci5qcyc7XG5pbXBvcnQgeyBzZW5kVG9CYWNrZW5kIH0gZnJvbSAnLi4vdXRpbHMvbWVzc2FnZS1icmlkZ2UuanMnO1xuXG4vLyBTdG9yZSB0aGUgYmFzZWxpbmUgZm9yIGNvbmZpcm1hdGlvblxubGV0IHBlbmRpbmdCYXNlbGluZTogdW5rbm93biA9IG51bGw7XG5cbi8qKlxuICogUmVuZGVyIGltcG9ydCBjaGFuZ2VzIGRpZmYgVUlcbiAqIEBwYXJhbSB2ZXJzaW9uQnVtcCAtIFZlcnNpb24gYnVtcCBkYXRhIHdpdGggY2hhbmdlc1xuICogQHBhcmFtIGJhc2VsaW5lIC0gVGhlIGJhc2VsaW5lIGRhdGEgdG8gaW1wb3J0IG9uIGNvbmZpcm1hdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVySW1wb3J0Q2hhbmdlc0RpZmYodmVyc2lvbkJ1bXA6IFZlcnNpb25CdW1wLCBiYXNlbGluZTogdW5rbm93bik6IHZvaWQge1xuICBwZW5kaW5nQmFzZWxpbmUgPSBiYXNlbGluZTtcbiAgXG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbXBvcnRDaGFuZ2VzU2VjdGlvbicpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIC8vIENyZWF0ZSB0aGUgY29udGFpbmVyIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBjb25zdCBtYWluQ29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250ZW50JykgfHwgZG9jdW1lbnQuYm9keTtcbiAgICBjb25zdCBzZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2VjdGlvbi5pZCA9ICdpbXBvcnRDaGFuZ2VzU2VjdGlvbic7XG4gICAgc2VjdGlvbi5jbGFzc05hbWUgPSAnaW1wb3J0LWNoYW5nZXMtc2VjdGlvbic7XG4gICAgbWFpbkNvbnRlbnQuaW5zZXJ0QmVmb3JlKHNlY3Rpb24sIG1haW5Db250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIHJlbmRlckltcG9ydENoYW5nZXNEaWZmKHZlcnNpb25CdW1wLCBiYXNlbGluZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICBcbiAgY29uc3QgaGFzQ2hhbmdlcyA9IHZlcnNpb25CdW1wLmNoYW5nZXMubGVuZ3RoID4gMDtcbiAgY29uc3QgYWN0aW9uVGV4dCA9IGhhc0NoYW5nZXMgPyAnQXBwbHkgSW1wb3J0JyA6ICdJbXBvcnQgQW55d2F5JztcbiAgXG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cInN5bmMtY2hhbmdlcyBpbXBvcnQtY2hhbmdlc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cImNoYW5nZXMtaGVhZGVyXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPlx1RDgzRFx1RENFNTwvc3Bhbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRpdGxlXCI+SW1wb3J0IFByZXZpZXc8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN1YnRpdGxlXCI+Q29tcGFyaW5nIGltcG9ydGVkIGJhc2VsaW5lIHdpdGggY3VycmVudCBGaWdtYSB2YXJpYWJsZXM8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiY2hhbmdlcy1jb250ZW50XCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ2ZXJzaW9uLWNvbXBhcmlzb25cIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImxhYmVsXCI+Q3VycmVudCBGaWdtYTo8L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJ2ZXJzaW9uLWJhZGdlIGN1cnJlbnRcIj52JHt2ZXJzaW9uQnVtcC5jdXJyZW50fTwvc3Bhbj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cImFycm93XCI+XHUyMTkyPC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj5JbXBvcnRpbmc6PC9zcGFuPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwidmVyc2lvbi1iYWRnZSBpbXBvcnRpbmdcIj52JHt2ZXJzaW9uQnVtcC5zdWdnZXN0ZWR9PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICAke2hhc0NoYW5nZXMgPyBgXG4gICAgICAgICAgJHtyZW5kZXJDaGFuZ2VTZWN0aW9uKCdicmVha2luZycsIHZlcnNpb25CdW1wLmNoYW5nZXMsICdcdUQ4M0RcdUREMzQgQnJlYWtpbmcgQ2hhbmdlcycsICdXaWxsIGJlIHJlbW92ZWQvY2hhbmdlZCcpfVxuICAgICAgICAgICR7cmVuZGVyQ2hhbmdlU2VjdGlvbignYWRkaXRpb24nLCB2ZXJzaW9uQnVtcC5jaGFuZ2VzLCAnXHVEODNEXHVERkUyIE5ldyBBZGRpdGlvbnMnLCAnV2lsbCBiZSBhZGRlZCcpfVxuICAgICAgICAgICR7cmVuZGVyQ2hhbmdlU2VjdGlvbigncGF0Y2gnLCB2ZXJzaW9uQnVtcC5jaGFuZ2VzLCAnXHVEODNEXHVERkUxIFZhbHVlIFVwZGF0ZXMnLCAnV2lsbCBiZSB1cGRhdGVkJyl9XG4gICAgICAgIGAgOiBgXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5vLWNoYW5nZXNcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaWNvblwiPlx1MjcxMzwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuPk5vIGRpZmZlcmVuY2VzIGRldGVjdGVkLiBUaGUgaW1wb3J0ZWQgYmFzZWxpbmUgbWF0Y2hlcyB5b3VyIGN1cnJlbnQgRmlnbWEgdmFyaWFibGVzLjwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYH1cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW1wb3J0LXN1bW1hcnlcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VtbWFyeS1pdGVtXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNvdW50XCI+JHt2ZXJzaW9uQnVtcC5icmVha2luZ0NvdW50fTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj5CcmVha2luZzwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VtbWFyeS1pdGVtXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNvdW50XCI+JHt2ZXJzaW9uQnVtcC5hZGRpdGlvbkNvdW50fTwvc3Bhbj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibGFiZWxcIj5BZGRpdGlvbnM8L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInN1bW1hcnktaXRlbVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjb3VudFwiPiR7dmVyc2lvbkJ1bXAucGF0Y2hDb3VudH08L3NwYW4+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImxhYmVsXCI+VXBkYXRlczwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cInN5bmMtYWN0aW9ucyBpbXBvcnQtYWN0aW9uc1wiPlxuICAgICAgICA8YnV0dG9uIGlkPVwiY2FuY2VsSW1wb3J0QnRuXCIgY2xhc3M9XCJidXR0b24gYnV0dG9uLXNlY29uZGFyeVwiPkNhbmNlbDwvYnV0dG9uPlxuICAgICAgICA8YnV0dG9uIGlkPVwiY29uZmlybUltcG9ydEJ0blwiIGNsYXNzPVwiYnV0dG9uIGJ1dHRvbi1wcmltYXJ5XCI+JHthY3Rpb25UZXh0fTwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG5cbiAgYXR0YWNoSW1wb3J0RXZlbnRMaXN0ZW5lcnMoKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSBjaGFuZ2Ugc2VjdGlvbiBmb3IgYSBzcGVjaWZpYyBjaGFuZ2UgdHlwZVxuICovXG5mdW5jdGlvbiByZW5kZXJDaGFuZ2VTZWN0aW9uKFxuICB0eXBlOiAnYnJlYWtpbmcnIHwgJ2FkZGl0aW9uJyB8ICdwYXRjaCcsXG4gIGFsbENoYW5nZXM6IFRva2VuQ2hhbmdlW10sXG4gIHRpdGxlOiBzdHJpbmcsXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbik6IHN0cmluZyB7XG4gIGNvbnN0IGNoYW5nZXMgPSBhbGxDaGFuZ2VzLmZpbHRlcihjID0+IGMudHlwZSA9PT0gdHlwZSk7XG5cbiAgaWYgKGNoYW5nZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG5cbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwiY2hhbmdlLXNlY3Rpb24gJHt0eXBlfVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24taGVhZGVyXCI+XG4gICAgICAgICR7dGl0bGV9ICgke2NoYW5nZXMubGVuZ3RofSlcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzZWN0aW9uLWRlc2NcIj4ke2Rlc2NyaXB0aW9ufTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24taXRlbXNcIj5cbiAgICAgICAgJHtjaGFuZ2VzLnNsaWNlKDAsIDgpLm1hcChjaGFuZ2UgPT4gYFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGFuZ2UtaXRlbVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjaGFuZ2UtcGF0aFwiPiR7ZXNjYXBlSHRtbChjaGFuZ2UucGF0aCl9PC9zcGFuPlxuICAgICAgICAgICAgJHtyZW5kZXJDaGFuZ2VWYWx1ZShjaGFuZ2UpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgKS5qb2luKCcnKX1cbiAgICAgICAgJHtjaGFuZ2VzLmxlbmd0aCA+IDggPyBgXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm1vcmUtY2hhbmdlc1wiPlxuICAgICAgICAgICAgLi4uIGFuZCAke2NoYW5nZXMubGVuZ3RoIC0gOH0gbW9yZSAke3R5cGV9IGNoYW5nZXNcbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYCA6ICcnfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSBiZWZvcmUvYWZ0ZXIgdmFsdWVzIGZvciBhIGNoYW5nZVxuICovXG5mdW5jdGlvbiByZW5kZXJDaGFuZ2VWYWx1ZShjaGFuZ2U6IFRva2VuQ2hhbmdlKTogc3RyaW5nIHtcbiAgaWYgKGNoYW5nZS5iZWZvcmUgIT09IHVuZGVmaW5lZCAmJiBjaGFuZ2UuYWZ0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwiY2hhbmdlLXZhbHVlc1wiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImJlZm9yZVwiPiR7ZXNjYXBlSHRtbChmb3JtYXRWYWx1ZShjaGFuZ2UuYmVmb3JlKSl9PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImFycm93XCI+XHUyMTkyPC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImFmdGVyXCI+JHtlc2NhcGVIdG1sKGZvcm1hdFZhbHVlKGNoYW5nZS5hZnRlcikpfTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH0gZWxzZSBpZiAoY2hhbmdlLmFmdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCJjaGFuZ2UtdmFsdWVzXCI+PHNwYW4gY2xhc3M9XCJhZnRlciBuZXdcIj4ke2VzY2FwZUh0bWwoZm9ybWF0VmFsdWUoY2hhbmdlLmFmdGVyKSl9PC9zcGFuPjwvZGl2PmA7XG4gIH0gZWxzZSBpZiAoY2hhbmdlLmJlZm9yZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGA8ZGl2IGNsYXNzPVwiY2hhbmdlLXZhbHVlc1wiPjxzcGFuIGNsYXNzPVwiYmVmb3JlIHJlbW92ZWRcIj4ke2VzY2FwZUh0bWwoZm9ybWF0VmFsdWUoY2hhbmdlLmJlZm9yZSkpfTwvc3Bhbj48L2Rpdj5gO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBGb3JtYXQgYSB2YWx1ZSBmb3IgZGlzcGxheVxuICovXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZTogYW55KTogc3RyaW5nIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiAnbnVsbCc7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzIHRvIGltcG9ydCBkaWZmIFVJXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEltcG9ydEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICBjb25zdCBjb25maXJtQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbmZpcm1JbXBvcnRCdG4nKTtcbiAgY29uc3QgY2FuY2VsQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbmNlbEltcG9ydEJ0bicpO1xuXG4gIGlmIChjb25maXJtQnRuKSB7XG4gICAgY29uZmlybUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgIGlmIChwZW5kaW5nQmFzZWxpbmUpIHtcbiAgICAgICAgc2VuZFRvQmFja2VuZCh7XG4gICAgICAgICAgdHlwZTogJ2NvbmZpcm0tYmFzZWxpbmUtaW1wb3J0JyxcbiAgICAgICAgICBiYXNlbGluZTogcGVuZGluZ0Jhc2VsaW5lXG4gICAgICAgIH0gYXMgYW55KTtcbiAgICAgICAgaGlkZUltcG9ydENoYW5nZXNEaWZmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoY2FuY2VsQnRuKSB7XG4gICAgY2FuY2VsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgaGlkZUltcG9ydENoYW5nZXNEaWZmKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIaWRlIGltcG9ydCBjaGFuZ2VzIGRpZmYgVUlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhpZGVJbXBvcnRDaGFuZ2VzRGlmZigpOiB2b2lkIHtcbiAgcGVuZGluZ0Jhc2VsaW5lID0gbnVsbDtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ltcG9ydENoYW5nZXNTZWN0aW9uJyk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gIH1cbn1cblxuLyoqXG4gKiBFc2NhcGUgSFRNTCBzcGVjaWFsIGNoYXJhY3RlcnNcbiAqL1xuZnVuY3Rpb24gZXNjYXBlSHRtbCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUw7XG59XG4iLCAiLyoqXG4gKiBTdHJ1Y3R1cmUgUHJldmlldyBVSSBDb21wb25lbnRcbiAqXG4gKiBEaXNwbGF5cyBKU09OIHN0cnVjdHVyZSBhcyBhIHRyZWUgd2l0aCBjb2xsYXBzaWJsZSBsZXZlbHMuXG4gKiBTaG93cyBkZXB0aCwga2V5cyBhdCBlYWNoIGxldmVsLCBhbmQgc2FtcGxlIHZhbHVlcy5cbiAqIE5PIHJvbGUgYXNzaWdubWVudCAtIHRoaXMgaXMgcmVhZC1vbmx5IHZpc3VhbGl6YXRpb24gb25seS5cbiAqL1xuXG5pbXBvcnQgeyBzZW5kTWVzc2FnZSB9IGZyb20gJy4uL21lc3NhZ2UtYnJpZGdlLmpzJztcbmltcG9ydCB0eXBlIHsgQW5hbHl6ZWRTdHJ1Y3R1cmUsIEFuYWx5emVkTGV2ZWwgfSBmcm9tICcuLi8uLi9iYWNrZW5kL3V0aWxzL3N0cnVjdHVyZS1hbmFseXplci5qcyc7XG5cbi8qKlxuICogU3RhdGUgZm9yIGNvbGxhcHNlZCBsZXZlbHNcbiAqL1xuY29uc3QgY29sbGFwc2VkTGV2ZWxzID0gbmV3IFNldDxudW1iZXI+KCk7XG5cbi8qKlxuICogUmVuZGVyIHN0cnVjdHVyZSBwcmV2aWV3IGNvbXBvbmVudFxuICpcbiAqIERpc3BsYXlzIHRoZSBhbmFseXplZCBKU09OIHN0cnVjdHVyZSBpbiBhIHRyZWUgdmlldyBmb3JtYXQuXG4gKiBFYWNoIGxldmVsIGNhbiBiZSBleHBhbmRlZC9jb2xsYXBzZWQgdG8gc2hvdyBrZXlzIGFuZCBzYW1wbGUgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBmaWxlTmFtZSAtIE5hbWUgb2YgdGhlIGZpbGUgYmVpbmcgYW5hbHl6ZWRcbiAqIEBwYXJhbSBkYXRhIC0gUGFyc2VkIEpTT04gZGF0YVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyU3RydWN0dXJlUHJldmlldyhmaWxlTmFtZTogc3RyaW5nLCBkYXRhOiB1bmtub3duKTogdm9pZCB7XG4gIC8vIFJlcXVlc3Qgc3RydWN0dXJlIGFuYWx5c2lzIGZyb20gYmFja2VuZFxuICBjb25zb2xlLmxvZygnW1N0cnVjdHVyZVByZXZpZXddIHJlbmRlclN0cnVjdHVyZVByZXZpZXcgLSBzZW5kaW5nIGFuYWx5emUtc3RydWN0dXJlIGZvcjonLCBmaWxlTmFtZSk7XG4gIHNlbmRNZXNzYWdlKHtcbiAgICB0eXBlOiAnYW5hbHl6ZS1zdHJ1Y3R1cmUnLFxuICAgIGZpbGVOYW1lLFxuICAgIGpzb25EYXRhOiBkYXRhLFxuICB9KTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IGFuYWx5emVkIHN0cnVjdHVyZSBpbiBVSVxuICpcbiAqIENhbGxlZCBhZnRlciByZWNlaXZpbmcgc3RydWN0dXJlLWFuYWx5emVkIG1lc3NhZ2UgZnJvbSBiYWNrZW5kLlxuICpcbiAqIEBwYXJhbSBmaWxlTmFtZSAtIE5hbWUgb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSBzdHJ1Y3R1cmUgLSBBbmFseXplZCBzdHJ1Y3R1cmUgZnJvbSBiYWNrZW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5QW5hbHl6ZWRTdHJ1Y3R1cmUoZmlsZU5hbWU6IHN0cmluZywgc3RydWN0dXJlOiBBbmFseXplZFN0cnVjdHVyZSk6IHZvaWQge1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RydWN0dXJlUHJldmlld1NlY3Rpb24nKTtcbiAgaWYgKCFjb250YWluZXIpIHJldHVybjtcblxuICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSByZW5kZXJTdHJ1Y3R1cmVQcmV2aWV3SFRNTChmaWxlTmFtZSwgc3RydWN0dXJlKTtcblxuICAvLyBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzIGZvciBjb2xsYXBzaWJsZSBsZXZlbHNcbiAgYXR0YWNoU3RydWN0dXJlRXZlbnRMaXN0ZW5lcnMoc3RydWN0dXJlKTtcbn1cblxuLyoqXG4gKiBIaWRlIHN0cnVjdHVyZSBwcmV2aWV3XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoaWRlU3RydWN0dXJlUHJldmlldygpOiB2b2lkIHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0cnVjdHVyZVByZXZpZXdTZWN0aW9uJyk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gIH1cbiAgY29sbGFwc2VkTGV2ZWxzLmNsZWFyKCk7XG59XG5cbi8qKlxuICogUmVuZGVyIHN0cnVjdHVyZSBwcmV2aWV3IEhUTUxcbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RydWN0dXJlUHJldmlld0hUTUwoZmlsZU5hbWU6IHN0cmluZywgc3RydWN0dXJlOiBBbmFseXplZFN0cnVjdHVyZSk6IHN0cmluZyB7XG4gIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cInN0cnVjdHVyZS1wcmV2aWV3XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwic3RydWN0dXJlLWhlYWRlclwiPlxuICAgICAgICA8aDM+SlNPTiBTdHJ1Y3R1cmUgUHJldmlldzwvaDM+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzdHJ1Y3R1cmUtbWV0YVwiPlxuICAgICAgICAgIEZpbGU6IDxzdHJvbmc+JHtlc2NhcGVIdG1sKGZpbGVOYW1lKX08L3N0cm9uZz4gXHUyMDIyXG4gICAgICAgICAgJHtzdHJ1Y3R1cmUubWF4RGVwdGh9IGxldmVsJHtzdHJ1Y3R1cmUubWF4RGVwdGggIT09IDEgPyAncycgOiAnJ30gZGVlcCBcdTIwMjJcbiAgICAgICAgICAke3N0cnVjdHVyZS5oYXNUb2tlblZhbHVlcyA/ICdDb250YWlucyBEZXNpZ24gVG9rZW5zIGZvcm1hdCcgOiAnU3RhbmRhcmQgSlNPTid9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJzdHJ1Y3R1cmUtdHJlZVwiPlxuICAgICAgICAke3N0cnVjdHVyZS5sZXZlbHMubWFwKChsZXZlbCkgPT4gcmVuZGVyTGV2ZWwobGV2ZWwpKS5qb2luKCcnKX1cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwic3RydWN0dXJlLWZvb3RlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5mby10ZXh0XCI+XG4gICAgICAgICAgPHN0cm9uZz5OZXh0IHN0ZXA6PC9zdHJvbmc+IENvbmZpZ3VyZSBob3cgZWFjaCBsZXZlbCBtYXBzIHRvIEZpZ21hIGNvbGxlY3Rpb25zIGFuZCBtb2Rlcy5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYDtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSBzaW5nbGUgbGV2ZWwgaW4gdGhlIHRyZWVcbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGV2ZWwobGV2ZWw6IEFuYWx5emVkTGV2ZWwpOiBzdHJpbmcge1xuICBjb25zdCBpc0NvbGxhcHNlZCA9IGNvbGxhcHNlZExldmVscy5oYXMobGV2ZWwuZGVwdGgpO1xuICBjb25zdCBoYXNNdWx0aXBsZUtleXMgPSBsZXZlbC5rZXlDb3VudCA+IDU7XG5cbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwic3RydWN0dXJlLWxldmVsXCIgZGF0YS1kZXB0aD1cIiR7bGV2ZWwuZGVwdGh9XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibGV2ZWwtaGVhZGVyXCIgZGF0YS1sZXZlbD1cIiR7bGV2ZWwuZGVwdGh9XCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibGV2ZWwtdG9nZ2xlICR7aXNDb2xsYXBzZWQgPyAnY29sbGFwc2VkJyA6ICdleHBhbmRlZCd9XCI+XG4gICAgICAgICAgJHtpc0NvbGxhcHNlZCA/ICdcdTI1QjYnIDogJ1x1MjVCQyd9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJsZXZlbC1sYWJlbFwiPkxldmVsICR7bGV2ZWwuZGVwdGh9PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImxldmVsLWNvdW50XCI+JHtsZXZlbC5rZXlDb3VudH0ga2V5JHtsZXZlbC5rZXlDb3VudCAhPT0gMSA/ICdzJyA6ICcnfTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibGV2ZWwtY29udGVudCAke2lzQ29sbGFwc2VkID8gJ2hpZGRlbicgOiAnJ31cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImxldmVsLWtleXNcIj5cbiAgICAgICAgICAke3JlbmRlcktleXMobGV2ZWwua2V5cywgaGFzTXVsdGlwbGVLZXlzKX1cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgJHtsZXZlbC5zYW1wbGVWYWx1ZXMubGVuZ3RoID4gMCA/IGBcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibGV2ZWwtc2FtcGxlc1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNhbXBsZXMtbGFiZWxcIj5TYW1wbGUgdmFsdWVzOjwvZGl2PlxuICAgICAgICAgICAgJHtsZXZlbC5zYW1wbGVWYWx1ZXMubWFwKChzYW1wbGUpID0+IHJlbmRlclNhbXBsZShzYW1wbGUpKS5qb2luKCcnKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYCA6ICcnfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG59XG5cbi8qKlxuICogUmVuZGVyIGtleXMgZm9yIGEgbGV2ZWxcbiAqL1xuZnVuY3Rpb24gcmVuZGVyS2V5cyhrZXlzOiBzdHJpbmdbXSwgaGFzTWFueTogYm9vbGVhbik6IHN0cmluZyB7XG4gIGNvbnN0IGRpc3BsYXlLZXlzID0gaGFzTWFueSA/IGtleXMuc2xpY2UoMCwgNSkgOiBrZXlzO1xuICBjb25zdCByZW1haW5pbmcgPSBrZXlzLmxlbmd0aCAtIGRpc3BsYXlLZXlzLmxlbmd0aDtcblxuICBjb25zdCBrZXlCYWRnZXMgPSBkaXNwbGF5S2V5c1xuICAgIC5tYXAoKGtleSkgPT4gYDxzcGFuIGNsYXNzPVwia2V5LWJhZGdlXCI+JHtlc2NhcGVIdG1sKGtleSl9PC9zcGFuPmApXG4gICAgLmpvaW4oJycpO1xuXG4gIGNvbnN0IHJlbWFpbmluZ0JhZGdlID0gcmVtYWluaW5nID4gMFxuICAgID8gYDxzcGFuIGNsYXNzPVwia2V5LWJhZGdlIG1vcmVcIj4rJHtyZW1haW5pbmd9IG1vcmU8L3NwYW4+YFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIGtleUJhZGdlcyArIHJlbWFpbmluZ0JhZGdlO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIHNhbXBsZSB2YWx1ZVxuICovXG5mdW5jdGlvbiByZW5kZXJTYW1wbGUoc2FtcGxlOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCB2YWx1ZURpc3BsYXkgPSBmb3JtYXRWYWx1ZURpc3BsYXkoc2FtcGxlLnZhbHVlLCBzYW1wbGUudHlwZSk7XG5cbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwic2FtcGxlLWl0ZW1cIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwic2FtcGxlLXBhdGhcIj4ke2VzY2FwZUh0bWwoc2FtcGxlLnBhdGgpfTwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwic2FtcGxlLXNlcGFyYXRvclwiPlx1MjE5Mjwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwic2FtcGxlLXZhbHVlICR7c2FtcGxlLnR5cGV9XCI+JHtlc2NhcGVIdG1sKFN0cmluZyh2YWx1ZURpc3BsYXkpKX08L3NwYW4+XG4gICAgPC9kaXY+XG4gIGA7XG59XG5cbi8qKlxuICogRm9ybWF0IHZhbHVlIGZvciBkaXNwbGF5XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlRGlzcGxheSh2YWx1ZTogdW5rbm93biwgdHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuICd1bmRlZmluZWQnO1xuXG4gIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIC8vIFRydW5jYXRlIGxvbmcgc3RyaW5nc1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPiAzMCA/IGBcIiR7c3RyLnN1YnN0cmluZygwLCAzMCl9Li4uXCJgIDogYFwiJHtzdHJ9XCJgO1xuICB9XG5cbiAgaWYgKHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICB9XG5cbiAgLy8gT2JqZWN0L2FycmF5IHByZXZpZXdzXG4gIHJldHVybiBTdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIEF0dGFjaCBldmVudCBsaXN0ZW5lcnMgZm9yIGludGVyYWN0aXZlIGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFN0cnVjdHVyZUV2ZW50TGlzdGVuZXJzKHN0cnVjdHVyZTogQW5hbHl6ZWRTdHJ1Y3R1cmUpOiB2b2lkIHtcbiAgLy8gVG9nZ2xlIGxldmVsIGNvbGxhcHNlL2V4cGFuZFxuICBzdHJ1Y3R1cmUubGV2ZWxzLmZvckVhY2goKGxldmVsKSA9PiB7XG4gICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLmxldmVsLWhlYWRlcltkYXRhLWxldmVsPVwiJHtsZXZlbC5kZXB0aH1cIl1gKTtcbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIHRvZ2dsZUxldmVsKGxldmVsLmRlcHRoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogVG9nZ2xlIGxldmVsIGV4cGFuZGVkL2NvbGxhcHNlZCBzdGF0ZVxuICovXG5mdW5jdGlvbiB0b2dnbGVMZXZlbChkZXB0aDogbnVtYmVyKTogdm9pZCB7XG4gIGNvbnN0IGlzQ29sbGFwc2VkID0gY29sbGFwc2VkTGV2ZWxzLmhhcyhkZXB0aCk7XG5cbiAgaWYgKGlzQ29sbGFwc2VkKSB7XG4gICAgY29sbGFwc2VkTGV2ZWxzLmRlbGV0ZShkZXB0aCk7XG4gIH0gZWxzZSB7XG4gICAgY29sbGFwc2VkTGV2ZWxzLmFkZChkZXB0aCk7XG4gIH1cblxuICAvLyBVcGRhdGUgVUlcbiAgY29uc3QgbGV2ZWxFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgLnN0cnVjdHVyZS1sZXZlbFtkYXRhLWRlcHRoPVwiJHtkZXB0aH1cIl1gKTtcbiAgaWYgKCFsZXZlbEVsZW1lbnQpIHJldHVybjtcblxuICBjb25zdCB0b2dnbGUgPSBsZXZlbEVsZW1lbnQucXVlcnlTZWxlY3RvcignLmxldmVsLXRvZ2dsZScpO1xuICBjb25zdCBjb250ZW50ID0gbGV2ZWxFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5sZXZlbC1jb250ZW50Jyk7XG5cbiAgaWYgKHRvZ2dsZSAmJiBjb250ZW50KSB7XG4gICAgaWYgKGlzQ29sbGFwc2VkKSB7XG4gICAgICB0b2dnbGUuY2xhc3NMaXN0LnJlbW92ZSgnY29sbGFwc2VkJyk7XG4gICAgICB0b2dnbGUuY2xhc3NMaXN0LmFkZCgnZXhwYW5kZWQnKTtcbiAgICAgIHRvZ2dsZS50ZXh0Q29udGVudCA9ICdcdTI1QkMnO1xuICAgICAgY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9nZ2xlLmNsYXNzTGlzdC5yZW1vdmUoJ2V4cGFuZGVkJyk7XG4gICAgICB0b2dnbGUuY2xhc3NMaXN0LmFkZCgnY29sbGFwc2VkJyk7XG4gICAgICB0b2dnbGUudGV4dENvbnRlbnQgPSAnXHUyNUI2JztcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIEhUTUwgdG8gcHJldmVudCBYU1NcbiAqL1xuZnVuY3Rpb24gZXNjYXBlSHRtbCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUw7XG59XG4iLCAiLyoqXG4gKiBMZXZlbCBjb25maWd1cmF0aW9uIHZhbGlkYXRpb24gdXRpbGl0aWVzXG4gKiBDbGllbnQtc2lkZSB2YWxpZGF0aW9uIGJlZm9yZSBiYWNrZW5kIHByb2Nlc3NpbmdcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IExldmVsQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uLy4uL3R5cGVzL2xldmVsLWNvbmZpZy50eXBlcy5qcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGV2ZWxWYWxpZGF0aW9uUmVzdWx0IHtcbiAgdmFsaWQ6IGJvb2xlYW47XG4gIGVycm9yczogc3RyaW5nW107XG4gIHdhcm5pbmdzOiBzdHJpbmdbXTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBsZXZlbCByb2xlIGFzc2lnbm1lbnRzXG4gKiAtIEF0IGxlYXN0IG9uZSBsZXZlbCBtdXN0IGJlICdjb2xsZWN0aW9uJ1xuICogLSBEZXB0aHMgbXVzdCBiZSBzZXF1ZW50aWFsXG4gKiAtIFJldHVybnMgZXJyb3JzLCB3YXJuaW5ncywgYW5kIG92ZXJhbGwgdmFsaWRpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTGV2ZWxSb2xlcyhsZXZlbHM6IExldmVsQ29uZmlndXJhdGlvbltdKTogTGV2ZWxWYWxpZGF0aW9uUmVzdWx0IHtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBDaGVjayBmb3IgZW1wdHkgbGV2ZWxzXG4gIGlmIChsZXZlbHMubGVuZ3RoID09PSAwKSB7XG4gICAgZXJyb3JzLnB1c2goJ05vIGxldmVsIGNvbmZpZ3VyYXRpb25zIHByb3ZpZGVkJyk7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBlcnJvcnMsIHdhcm5pbmdzIH07XG4gIH1cblxuICAvLyBDaGVjayBmb3IgYXQgbGVhc3Qgb25lIGNvbGxlY3Rpb25cbiAgY29uc3QgaGFzQ29sbGVjdGlvbiA9IGxldmVscy5zb21lKChsZXZlbCkgPT4gbGV2ZWwucm9sZSA9PT0gJ2NvbGxlY3Rpb24nKTtcbiAgaWYgKCFoYXNDb2xsZWN0aW9uKSB7XG4gICAgZXJyb3JzLnB1c2goJ0F0IGxlYXN0IG9uZSBsZXZlbCBtdXN0IGJlIG1hcHBlZCBhcyBDb2xsZWN0aW9uJyk7XG4gIH1cblxuICAvLyBDaGVjayBkZXB0aHMgYXJlIHNlcXVlbnRpYWwgc3RhcnRpbmcgZnJvbSAxXG4gIGNvbnN0IGRlcHRocyA9IGxldmVscy5tYXAoKGxldmVsKSA9PiBsZXZlbC5kZXB0aCkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRocy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChkZXB0aHNbaV0gIT09IGkgKyAxKSB7XG4gICAgICBlcnJvcnMucHVzaChgTGV2ZWwgZGVwdGhzIG11c3QgYmUgc2VxdWVudGlhbCBzdGFydGluZyBmcm9tIDEuIEZvdW5kIGdhcCBhdCBkZXB0aCAke2kgKyAxfWApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gV2FybmluZyBpZiBubyBtb2RlIHNlbGVjdGVkXG4gIGNvbnN0IGhhc01vZGUgPSBsZXZlbHMuc29tZSgobGV2ZWwpID0+IGxldmVsLnJvbGUgPT09ICdtb2RlJyk7XG4gIGlmICghaGFzTW9kZSkge1xuICAgIHdhcm5pbmdzLnB1c2goJ05vIE1vZGUgbGV2ZWwgZGVmaW5lZCAtIGEgZGVmYXVsdCBtb2RlIHdpbGwgYmUgY3JlYXRlZCBmb3IgZWFjaCBjb2xsZWN0aW9uJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgIGVycm9ycyxcbiAgICB3YXJuaW5ncyxcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIGxldmVsIGNvbmZpZ3VyYXRpb24gaGFzIHdhcm5pbmdzIChidXQgaXMgc3RpbGwgdmFsaWQpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNXYXJuaW5ncyhsZXZlbHM6IExldmVsQ29uZmlndXJhdGlvbltdKTogYm9vbGVhbiB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlTGV2ZWxSb2xlcyhsZXZlbHMpO1xuICByZXR1cm4gcmVzdWx0LnZhbGlkICYmIHJlc3VsdC53YXJuaW5ncy5sZW5ndGggPiAwO1xufVxuXG4vKipcbiAqIEdldCBhIHVzZXItZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBmb3IgZGlzcGxheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGxldmVsczogTGV2ZWxDb25maWd1cmF0aW9uW10pOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGVMZXZlbFJvbGVzKGxldmVscyk7XG4gIHJldHVybiByZXN1bHQuZXJyb3JzLmxlbmd0aCA+IDAgPyByZXN1bHQuZXJyb3JzWzBdIDogbnVsbDtcbn1cblxuLyoqXG4gKiBHZXQgd2FybmluZyBtZXNzYWdlcyBmb3IgZGlzcGxheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2FybmluZ01lc3NhZ2VzKGxldmVsczogTGV2ZWxDb25maWd1cmF0aW9uW10pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlTGV2ZWxSb2xlcyhsZXZlbHMpO1xuICByZXR1cm4gcmVzdWx0Lndhcm5pbmdzO1xufVxuIiwgIi8qKlxuICogTGV2ZWwgU2VsZWN0b3IgQ29tcG9uZW50XG4gKiBBbGxvd3MgdXNlcnMgdG8gY29uZmlndXJlIGhvdyBKU09OIGxldmVscyBtYXAgdG8gRmlnbWEgc3RydWN0dXJlXG4gKiAoQ29sbGVjdGlvbiwgTW9kZSwgb3IgVG9rZW4gUGF0aClcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IExldmVsQ29uZmlndXJhdGlvbiwgTGV2ZWxSb2xlIH0gZnJvbSAnLi4vLi4vdHlwZXMvbGV2ZWwtY29uZmlnLnR5cGVzLmpzJztcbmltcG9ydCB7IHVwZGF0ZUxldmVsQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uL3N0YXRlLmpzJztcbmltcG9ydCB7IHZhbGlkYXRlTGV2ZWxSb2xlcyB9IGZyb20gJy4uL3V0aWxzL2xldmVsLXZhbGlkYXRpb24uanMnO1xuXG4vKipcbiAqIEFuYWx5emVkIGxldmVsIGluZm9ybWF0aW9uIGZyb20gSlNPTiBzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBbmFseXplZExldmVsIHtcbiAgZGVwdGg6IG51bWJlcjtcbiAgZXhhbXBsZUtleXM6IHN0cmluZ1tdO1xuICBrZXlDb3VudDogbnVtYmVyO1xufVxuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHJlbmRlckxldmVsU2VsZWN0b3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBMZXZlbFNlbGVjdG9yT3B0aW9ucyB7XG4gIGNvbnRhaW5lcklkPzogc3RyaW5nO1xuICBjb21wYWN0PzogYm9vbGVhbjtcbiAgb25Db25maWdDaGFuZ2U/OiAoY29uZmlnOiBMZXZlbENvbmZpZ3VyYXRpb25bXSkgPT4gdm9pZDtcbn1cblxuLyoqXG4gKiBSZW5kZXIgbGV2ZWwgc2VsZWN0b3IgY29tcG9uZW50XG4gKiBTaG93cyByYWRpbyBidXR0b25zIGZvciBlYWNoIGxldmVsIHdpdGggQ29sbGVjdGlvbi9Nb2RlL1Rva2VuIFBhdGggb3B0aW9uc1xuICogQHBhcmFtIGxldmVscyAtIEFycmF5IG9mIGFuYWx5emVkIGxldmVscyBmcm9tIEpTT04gc3RydWN0dXJlXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTGV2ZWxTZWxlY3RvcihcbiAgbGV2ZWxzOiBBbmFseXplZExldmVsW10sXG4gIG9wdGlvbnM6IExldmVsU2VsZWN0b3JPcHRpb25zIHwgc3RyaW5nID0ge31cbik6IHZvaWQge1xuICAvLyBTdXBwb3J0IGxlZ2FjeSBjYWxsIHNpZ25hdHVyZTogcmVuZGVyTGV2ZWxTZWxlY3RvcihsZXZlbHMsIGNvbnRhaW5lcklkLCBjb21wYWN0KVxuICBsZXQgY29udGFpbmVySWQgPSAnbGV2ZWxTZWxlY3RvckNvbnRhaW5lcic7XG4gIGxldCBjb21wYWN0ID0gZmFsc2U7XG4gIGxldCBvbkNvbmZpZ0NoYW5nZTogKChjb25maWc6IExldmVsQ29uZmlndXJhdGlvbltdKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gTGVnYWN5IGNhbGw6IHJlbmRlckxldmVsU2VsZWN0b3IobGV2ZWxzLCBjb250YWluZXJJZClcbiAgICBjb250YWluZXJJZCA9IG9wdGlvbnM7XG4gICAgLy8gQ2hlY2sgaWYgdGhpcmQgYXJndW1lbnQgd2FzIHBhc3NlZCAoY29tcGFjdCBib29sZWFuKVxuICAgIC8vIFRoaXMgaGFuZGxlcyBjYWxscyBsaWtlIHJlbmRlckxldmVsU2VsZWN0b3IobGV2ZWxzLCAnY29udGFpbmVyLWlkJywgdHJ1ZSlcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXJJZCA9IG9wdGlvbnMuY29udGFpbmVySWQgfHwgJ2xldmVsU2VsZWN0b3JDb250YWluZXInO1xuICAgIGNvbXBhY3QgPSBvcHRpb25zLmNvbXBhY3QgfHwgZmFsc2U7XG4gICAgb25Db25maWdDaGFuZ2UgPSBvcHRpb25zLm9uQ29uZmlnQ2hhbmdlO1xuICB9XG5cbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVySWQpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFtMZXZlbFNlbGVjdG9yXSBDb250YWluZXIgZWxlbWVudCBub3QgZm91bmQ6ICMke2NvbnRhaW5lcklkfWApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIENyZWF0ZSB1bmlxdWUgSURzIGZvciB0aGlzIGluc3RhbmNlIHVzaW5nIHRoZSBjb250YWluZXIgSURcbiAgLy8gSGFuZGxlIGJvdGggJ2xldmVsU2VsZWN0b3JDb250YWluZXInIChkZWZhdWx0KSBhbmQgJ2xldmVsLXNlbGVjdG9yLXtncm91cElkfScgKG11bHRpLWNvbGxlY3Rpb24pXG4gIGNvbnN0IGlzRGVmYXVsdCA9IGNvbnRhaW5lcklkID09PSAnbGV2ZWxTZWxlY3RvckNvbnRhaW5lcic7XG4gIGNvbnN0IHVuaXF1ZVN1ZmZpeCA9IGlzRGVmYXVsdCA/ICcnIDogY29udGFpbmVySWQucmVwbGFjZSgvXmxldmVsLXNlbGVjdG9yLS8sICcnKTtcbiAgY29uc3QgbGV2ZWxzSWQgPSB1bmlxdWVTdWZmaXggPyBgbGV2ZWxTZWxlY3RvckxldmVscy0ke3VuaXF1ZVN1ZmZpeH1gIDogJ2xldmVsU2VsZWN0b3JMZXZlbHMnO1xuICBjb25zdCB2YWxpZGF0aW9uSWQgPSB1bmlxdWVTdWZmaXggPyBgbGV2ZWxWYWxpZGF0aW9uLSR7dW5pcXVlU3VmZml4fWAgOiAnbGV2ZWxWYWxpZGF0aW9uJztcblxuICAvLyBJbml0aWFsaXplIGNvbmZpZ3VyYXRpb24gd2l0aCBhbGwgbGV2ZWxzIGFzICd0b2tlbi1wYXRoJ1xuICBjb25zdCBpbml0aWFsQ29uZmlnOiBMZXZlbENvbmZpZ3VyYXRpb25bXSA9IGxldmVscy5tYXAoKGxldmVsKSA9PiAoe1xuICAgIGRlcHRoOiBsZXZlbC5kZXB0aCxcbiAgICByb2xlOiAndG9rZW4tcGF0aCcgYXMgTGV2ZWxSb2xlLFxuICAgIGV4YW1wbGVLZXlzOiBsZXZlbC5leGFtcGxlS2V5cyxcbiAgICBrZXlDb3VudDogbGV2ZWwua2V5Q291bnQsXG4gIH0pKTtcblxuICAvLyBIZWFkZXIgc2VjdGlvbiAoaGlkZGVuIGluIGNvbXBhY3QgbW9kZSlcbiAgY29uc3QgaGVhZGVySHRtbCA9IGNvbXBhY3QgPyAnJyA6IGBcbiAgICAgIDxkaXYgY2xhc3M9XCJsZXZlbC1zZWxlY3Rvci1oZWFkZXJcIj5cbiAgICAgICAgPGgzIGNsYXNzPVwic2VjdGlvbi10aXRsZVwiPkNvbmZpZ3VyZSBJbXBvcnQgU3RydWN0dXJlPC9oMz5cbiAgICAgICAgPHAgY2xhc3M9XCJzZWN0aW9uLWRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgRGVmaW5lIGhvdyB0aGUgSlNPTiBsZXZlbHMgbWFwIHRvIEZpZ21hIGNvbGxlY3Rpb25zIGFuZCBtb2RlczpcbiAgICAgICAgPC9wPlxuICAgICAgPC9kaXY+YDtcblxuICAvLyBSZW5kZXIgdGhlIHNlbGVjdG9yIFVJXG4gIGNvbnRhaW5lci5pbm5lckhUTUwgPSBgXG4gICAgPGRpdiBjbGFzcz1cImxldmVsLXNlbGVjdG9yJHtjb21wYWN0ID8gJyBsZXZlbC1zZWxlY3Rvci1jb21wYWN0JyA6ICcnfVwiPlxuICAgICAgJHtoZWFkZXJIdG1sfVxuICAgICAgPGRpdiBjbGFzcz1cImxldmVsLXNlbGVjdG9yLWxldmVsc1wiIGlkPVwiJHtsZXZlbHNJZH1cIj5cbiAgICAgICAgJHtsZXZlbHMubWFwKChsZXZlbCwgaW5kZXgpID0+IHJlbmRlckxldmVsT3B0aW9uKGxldmVsLCBpbmRleCwgaW5pdGlhbENvbmZpZykpLmpvaW4oJycpfVxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJsZXZlbC1zZWxlY3Rvci12YWxpZGF0aW9uXCIgaWQ9XCIke3ZhbGlkYXRpb25JZH1cIj5cbiAgICAgICAgJHtyZW5kZXJWYWxpZGF0aW9uKGluaXRpYWxDb25maWcpfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG5cbiAgLy8gQXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICBhdHRhY2hFdmVudExpc3RlbmVycyhjb250YWluZXIsIGxldmVscywgaW5pdGlhbENvbmZpZywgdmFsaWRhdGlvbklkLCBvbkNvbmZpZ0NoYW5nZSk7XG5cbiAgLy8gRW1pdCBpbml0aWFsIGNvbmZpZ3VyYXRpb24gKGdsb2JhbCBzdGF0ZSB1cGRhdGUgZm9yIHNpbmdsZS1maWxlIG1vZGUpXG4gIGlmICghb25Db25maWdDaGFuZ2UpIHtcbiAgICB1cGRhdGVMZXZlbENvbmZpZ3VyYXRpb24oaW5pdGlhbENvbmZpZyk7XG4gIH0gZWxzZSB7XG4gICAgb25Db25maWdDaGFuZ2UoaW5pdGlhbENvbmZpZyk7XG4gIH1cbiAgZW1pdENvbmZpZ3VyYXRpb25DaGFuZ2VkKGluaXRpYWxDb25maWcpO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIHNpbmdsZSBsZXZlbCBzZWxlY3RvciBvcHRpb25cbiAqL1xuZnVuY3Rpb24gcmVuZGVyTGV2ZWxPcHRpb24oXG4gIGxldmVsOiBBbmFseXplZExldmVsLFxuICBpbmRleDogbnVtYmVyLFxuICBjdXJyZW50Q29uZmlnOiBMZXZlbENvbmZpZ3VyYXRpb25bXVxuKTogc3RyaW5nIHtcbiAgY29uc3QgY3VycmVudFJvbGUgPSBjdXJyZW50Q29uZmlnW2luZGV4XT8ucm9sZSB8fCAndG9rZW4tcGF0aCc7XG4gIGNvbnN0IGlzTGFzdExldmVsID0gaW5kZXggPT09IGN1cnJlbnRDb25maWcubGVuZ3RoIC0gMTtcblxuICAvLyBGb3JtYXQgZXhhbXBsZSBrZXlzIGZvciBkaXNwbGF5IChtYXggNSlcbiAgY29uc3QgZGlzcGxheUtleXMgPSBsZXZlbC5leGFtcGxlS2V5cy5zbGljZSgwLCA1KS5qb2luKCcsICcpO1xuICBjb25zdCBtb3JlQ291bnQgPSBsZXZlbC5rZXlDb3VudCA+IDUgPyBsZXZlbC5rZXlDb3VudCAtIDUgOiAwO1xuICBjb25zdCBrZXlzRGlzcGxheSA9IG1vcmVDb3VudCA+IDAgPyBgJHtkaXNwbGF5S2V5c30uLi4gKCske21vcmVDb3VudH0gbW9yZSlgIDogZGlzcGxheUtleXM7XG5cbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwibGV2ZWwtb3B0aW9uXCIgZGF0YS1kZXB0aD1cIiR7bGV2ZWwuZGVwdGh9XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibGV2ZWwtb3B0aW9uLWhlYWRlclwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImxldmVsLWxhYmVsXCI+TGV2ZWwgJHtsZXZlbC5kZXB0aH06PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImxldmVsLWtleS1jb3VudFwiPiR7bGV2ZWwua2V5Q291bnR9IGtleXM8L3NwYW4+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cImxldmVsLW9wdGlvbi1rZXlzXCI+XG4gICAgICAgICR7ZXNjYXBlSHRtbChrZXlzRGlzcGxheSl9XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cImxldmVsLW9wdGlvbi1yYWRpb3NcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwicmFkaW8tbGFiZWwgJHtpc0xhc3RMZXZlbCA/ICdkaXNhYmxlZCcgOiAnJ31cIj5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgICBuYW1lPVwibGV2ZWwtJHtsZXZlbC5kZXB0aH1cIlxuICAgICAgICAgICAgdmFsdWU9XCJjb2xsZWN0aW9uXCJcbiAgICAgICAgICAgICR7Y3VycmVudFJvbGUgPT09ICdjb2xsZWN0aW9uJyA/ICdjaGVja2VkJyA6ICcnfVxuICAgICAgICAgICAgJHtpc0xhc3RMZXZlbCA/ICdkaXNhYmxlZCcgOiAnJ31cbiAgICAgICAgICAgIGRhdGEtZGVwdGg9XCIke2xldmVsLmRlcHRofVwiXG4gICAgICAgICAgLz5cbiAgICAgICAgICA8c3Bhbj5Db2xsZWN0aW9uPC9zcGFuPlxuICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cInJhZGlvLWxhYmVsICR7aXNMYXN0TGV2ZWwgPyAnZGlzYWJsZWQnIDogJyd9XCI+XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICAgICAgbmFtZT1cImxldmVsLSR7bGV2ZWwuZGVwdGh9XCJcbiAgICAgICAgICAgIHZhbHVlPVwibW9kZVwiXG4gICAgICAgICAgICAke2N1cnJlbnRSb2xlID09PSAnbW9kZScgPyAnY2hlY2tlZCcgOiAnJ31cbiAgICAgICAgICAgICR7aXNMYXN0TGV2ZWwgPyAnZGlzYWJsZWQnIDogJyd9XG4gICAgICAgICAgICBkYXRhLWRlcHRoPVwiJHtsZXZlbC5kZXB0aH1cIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHNwYW4+TW9kZTwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cblxuICAgICAgICA8bGFiZWwgY2xhc3M9XCJyYWRpby1sYWJlbFwiPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgIG5hbWU9XCJsZXZlbC0ke2xldmVsLmRlcHRofVwiXG4gICAgICAgICAgICB2YWx1ZT1cInRva2VuLXBhdGhcIlxuICAgICAgICAgICAgJHtjdXJyZW50Um9sZSA9PT0gJ3Rva2VuLXBhdGgnID8gJ2NoZWNrZWQnIDogJyd9XG4gICAgICAgICAgICBkYXRhLWRlcHRoPVwiJHtsZXZlbC5kZXB0aH1cIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPHNwYW4+VG9rZW4gUGF0aDwvc3Bhbj5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xufVxuXG4vKipcbiAqIFJlbmRlciB2YWxpZGF0aW9uIG1lc3NhZ2VzXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclZhbGlkYXRpb24oY29uZmlnOiBMZXZlbENvbmZpZ3VyYXRpb25bXSk6IHN0cmluZyB7XG4gIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZUxldmVsUm9sZXMoY29uZmlnKTtcblxuICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICByZXR1cm4gYFxuICAgICAgPGRpdiBjbGFzcz1cInZhbGlkYXRpb24tZXJyb3JcIj5cbiAgICAgICAgPHN2ZyB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCIgZmlsbD1cIm5vbmVcIj5cbiAgICAgICAgICA8Y2lyY2xlIGN4PVwiOFwiIGN5PVwiOFwiIHI9XCI3XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIG9wYWNpdHk9XCIwLjFcIi8+XG4gICAgICAgICAgPHBhdGggZD1cIk04IDR2NU04IDExaC4wMVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPHNwYW4+JHtlc2NhcGVIdG1sKHZhbGlkYXRpb24uZXJyb3JzWzBdKX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xuICB9XG5cbiAgaWYgKHZhbGlkYXRpb24ud2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBgXG4gICAgICA8ZGl2IGNsYXNzPVwidmFsaWRhdGlvbi13YXJuaW5nXCI+XG4gICAgICAgIDxzdmcgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiIGZpbGw9XCJub25lXCI+XG4gICAgICAgICAgPHBhdGggZD1cIk04IDFsNyAxMkgxTDggMXpcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgb3BhY2l0eT1cIjAuMVwiLz5cbiAgICAgICAgICA8cGF0aCBkPVwiTTggNnY0TTggMTFoLjAxXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIi8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8c3Bhbj4ke2VzY2FwZUh0bWwodmFsaWRhdGlvbi53YXJuaW5nc1swXSl9PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBBdHRhY2ggZXZlbnQgbGlzdGVuZXJzIGZvciByYWRpbyBidXR0b24gY2hhbmdlc1xuICovXG5mdW5jdGlvbiBhdHRhY2hFdmVudExpc3RlbmVycyhcbiAgY29udGFpbmVyOiBIVE1MRWxlbWVudCxcbiAgbGV2ZWxzOiBBbmFseXplZExldmVsW10sXG4gIGluaXRpYWxDb25maWc6IExldmVsQ29uZmlndXJhdGlvbltdLFxuICB2YWxpZGF0aW9uSWQ6IHN0cmluZyA9ICdsZXZlbFZhbGlkYXRpb24nLFxuICBvbkNvbmZpZ0NoYW5nZT86IChjb25maWc6IExldmVsQ29uZmlndXJhdGlvbltdKSA9PiB2b2lkXG4pOiB2b2lkIHtcbiAgbGV0IGN1cnJlbnRDb25maWcgPSBbLi4uaW5pdGlhbENvbmZpZ107XG5cbiAgLy8gTGlzdGVuIGZvciByYWRpbyBidXR0b24gY2hhbmdlc1xuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICBpZiAodGFyZ2V0LnR5cGUgPT09ICdyYWRpbycgJiYgdGFyZ2V0LmRhdGFzZXQuZGVwdGgpIHtcbiAgICAgIGNvbnN0IGRlcHRoID0gcGFyc2VJbnQodGFyZ2V0LmRhdGFzZXQuZGVwdGgsIDEwKTtcbiAgICAgIGNvbnN0IG5ld1JvbGUgPSB0YXJnZXQudmFsdWUgYXMgTGV2ZWxSb2xlO1xuXG4gICAgICAvLyBVcGRhdGUgY29uZmlndXJhdGlvblxuICAgICAgY29uc3QgY29uZmlnSW5kZXggPSBjdXJyZW50Q29uZmlnLmZpbmRJbmRleCgoYykgPT4gYy5kZXB0aCA9PT0gZGVwdGgpO1xuICAgICAgaWYgKGNvbmZpZ0luZGV4ICE9PSAtMSkge1xuICAgICAgICBjdXJyZW50Q29uZmlnW2NvbmZpZ0luZGV4XSA9IHtcbiAgICAgICAgICAuLi5jdXJyZW50Q29uZmlnW2NvbmZpZ0luZGV4XSxcbiAgICAgICAgICByb2xlOiBuZXdSb2xlLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZSAoZWl0aGVyIHZpYSBjYWxsYmFjayBvciBnbG9iYWwgc3RhdGUpXG4gICAgICAgIGlmIChvbkNvbmZpZ0NoYW5nZSkge1xuICAgICAgICAgIG9uQ29uZmlnQ2hhbmdlKGN1cnJlbnRDb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZUxldmVsQ29uZmlndXJhdGlvbihjdXJyZW50Q29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlLXJlbmRlciB2YWxpZGF0aW9uXG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25FbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHZhbGlkYXRpb25JZCk7XG4gICAgICAgIGlmICh2YWxpZGF0aW9uRWwpIHtcbiAgICAgICAgICB2YWxpZGF0aW9uRWwuaW5uZXJIVE1MID0gcmVuZGVyVmFsaWRhdGlvbihjdXJyZW50Q29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVtaXQgZXZlbnQgZm9yIHByZXZpZXcgdXBkYXRlc1xuICAgICAgICBlbWl0Q29uZmlndXJhdGlvbkNoYW5nZWQoY3VycmVudENvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBFbWl0IGN1c3RvbSBldmVudCB3aGVuIGNvbmZpZ3VyYXRpb24gY2hhbmdlc1xuICogVGhpcyBhbGxvd3MgdGhlIGxpdmUgcHJldmlldyBjb21wb25lbnQgdG8gdXBkYXRlXG4gKi9cbmZ1bmN0aW9uIGVtaXRDb25maWd1cmF0aW9uQ2hhbmdlZChjb25maWc6IExldmVsQ29uZmlndXJhdGlvbltdKTogdm9pZCB7XG4gIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdsZXZlbC1jb25maWd1cmF0aW9uLWNoYW5nZWQnLCB7XG4gICAgZGV0YWlsOiB7XG4gICAgICBjb25maWd1cmF0aW9uOiBjb25maWcsXG4gICAgICB2YWxpZGF0aW9uOiB2YWxpZGF0ZUxldmVsUm9sZXMoY29uZmlnKSxcbiAgICB9LFxuICB9KTtcbiAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbi8qKlxuICogU2ltcGxlIEhUTUwgZXNjYXBlIHRvIHByZXZlbnQgWFNTXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MO1xufVxuXG4vKipcbiAqIEdldCBjdXJyZW50IGNvbmZpZ3VyYXRpb24gKGZvciBleHRlcm5hbCB1c2UpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50Q29uZmlndXJhdGlvbihjb250YWluZXI6IEhUTUxFbGVtZW50KTogTGV2ZWxDb25maWd1cmF0aW9uW10gfCBudWxsIHtcbiAgY29uc3QgbGV2ZWxPcHRpb25zID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5sZXZlbC1vcHRpb24nKTtcbiAgaWYgKGxldmVsT3B0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGNvbmZpZzogTGV2ZWxDb25maWd1cmF0aW9uW10gPSBbXTtcblxuICBsZXZlbE9wdGlvbnMuZm9yRWFjaCgob3B0aW9uKSA9PiB7XG4gICAgY29uc3QgZGVwdGggPSBwYXJzZUludChvcHRpb24uZ2V0QXR0cmlidXRlKCdkYXRhLWRlcHRoJykgfHwgJzAnLCAxMCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRSYWRpbyA9IG9wdGlvbi5xdWVyeVNlbGVjdG9yKCdpbnB1dFt0eXBlPVwicmFkaW9cIl06Y2hlY2tlZCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICBpZiAoc2VsZWN0ZWRSYWRpbykge1xuICAgICAgY29uZmlnLnB1c2goe1xuICAgICAgICBkZXB0aCxcbiAgICAgICAgcm9sZTogc2VsZWN0ZWRSYWRpby52YWx1ZSBhcyBMZXZlbFJvbGUsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb25maWc7XG59XG4iLCAiLyoqXG4gKiBMZXZlbC1iYXNlZCBpbXBvcnQgY29uZmlndXJhdGlvbiB0eXBlc1xuICogRGVmaW5lcyBob3cgSlNPTiBzdHJ1Y3R1cmUgbGV2ZWxzIG1hcCB0byBGaWdtYSBjb25jZXB0c1xuICovXG5cbi8qKlxuICogVHlwZSBvZiByb2xlIGEgbGV2ZWwgY2FuIHBsYXkgaW4gdGhlIGltcG9ydCBzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0IHR5cGUgTGV2ZWxSb2xlID0gJ2NvbGxlY3Rpb24nIHwgJ21vZGUnIHwgJ3Rva2VuLXBhdGgnO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGEgc2luZ2xlIGxldmVsIGluIHRoZSBKU09OIHN0cnVjdHVyZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIExldmVsQ29uZmlndXJhdGlvbiB7XG4gIC8qKlxuICAgKiBMZXZlbCBkZXB0aCAoMS1iYXNlZCBpbmRleClcbiAgICovXG4gIGRlcHRoOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFJvbGUgdGhpcyBsZXZlbCBwbGF5cyBpbiB0aGUgRmlnbWEgc3RydWN0dXJlXG4gICAqL1xuICByb2xlOiBMZXZlbFJvbGU7XG5cbiAgLyoqXG4gICAqIEV4YW1wbGUga2V5cyBmb3VuZCBhdCB0aGlzIGxldmVsIChtYXggNSlcbiAgICovXG4gIGV4YW1wbGVLZXlzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFRvdGFsIGNvdW50IG9mIHVuaXF1ZSBrZXlzIGF0IHRoaXMgbGV2ZWxcbiAgICovXG4gIGtleUNvdW50PzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEZpbGUgZ3JvdXBpbmcgY29uZmlndXJhdGlvbiBmb3IgbXVsdGktZmlsZSBpbXBvcnRzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUdyb3VwIHtcbiAgLyoqXG4gICAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGdyb3VwXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBjb2xsZWN0aW9uIHRoaXMgZ3JvdXAgd2lsbCBjcmVhdGVcbiAgICovXG4gIGNvbGxlY3Rpb25OYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEZpbGUgbmFtZXMgaW5jbHVkZWQgaW4gdGhpcyBncm91cFxuICAgKi9cbiAgZmlsZU5hbWVzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogSG93IHRvIGhhbmRsZSBtdWx0aXBsZSBmaWxlc1xuICAgKiAtICdwZXItZmlsZSc6IEVhY2ggZmlsZSBiZWNvbWVzIGEgc2VwYXJhdGUgbW9kZVxuICAgKiAtICdtZXJnZWQnOiBNZXJnZSBhbGwgZmlsZXMgaW50byBvbmUgbW9kZVxuICAgKi9cbiAgbW9kZVN0cmF0ZWd5OiAncGVyLWZpbGUnIHwgJ21lcmdlZCc7XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RlZCBtb2RlIG5hbWVzIGZvciBlYWNoIGZpbGUgKHdoZW4gbW9kZVN0cmF0ZWd5IGlzICdwZXItZmlsZScpXG4gICAqIE1hcHMgZmlsZU5hbWUgLT4gbW9kZU5hbWUgKGFzIFJlY29yZCBmb3IgSlNPTiBzZXJpYWxpemF0aW9uKVxuICAgKi9cbiAgbW9kZU5hbWVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbn1cblxuLyoqXG4gKiBDb21wbGV0ZSBjb25maWd1cmF0aW9uIGZvciBhIGNvbGxlY3Rpb24gaW1wb3J0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGVjdGlvbkNvbmZpZ3VyYXRpb24ge1xuICAvKipcbiAgICogQ29sbGVjdGlvbiBuYW1lXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIExldmVsIGNvbmZpZ3VyYXRpb25zIGZvciB0aGlzIGNvbGxlY3Rpb25cbiAgICovXG4gIGxldmVsczogTGV2ZWxDb25maWd1cmF0aW9uW107XG5cbiAgLyoqXG4gICAqIFNvdXJjZSBmaWxlcyBmb3IgdGhpcyBjb2xsZWN0aW9uXG4gICAqL1xuICBzb3VyY2VGaWxlczogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIE1vZGUgc3RyYXRlZ3kgKGZvciBtdWx0aS1maWxlIGltcG9ydHMpXG4gICAqL1xuICBtb2RlU3RyYXRlZ3k/OiAncGVyLWZpbGUnIHwgJ21lcmdlZCc7XG59XG5cbi8qKlxuICogVmFsaWRhdGlvbiByZXN1bHQgZm9yIGxldmVsIGNvbmZpZ3VyYXRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGV2ZWxWYWxpZGF0aW9uIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGNvbmZpZ3VyYXRpb24gaXMgdmFsaWRcbiAgICovXG4gIHZhbGlkOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFcnJvciBtZXNzYWdlIGlmIGludmFsaWRcbiAgICovXG4gIGVycm9yPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXYXJuaW5nIG1lc3NhZ2VzXG4gICAqL1xuICB3YXJuaW5ncz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgbGV2ZWwgY29uZmlndXJhdGlvbnMgYXJlIGNvcnJlY3RcbiAqIC0gQXQgbGVhc3Qgb25lIGxldmVsIG11c3QgYmUgJ2NvbGxlY3Rpb24nXG4gKiAtIERlcHRocyBtdXN0IGJlIHNlcXVlbnRpYWwgc3RhcnRpbmcgZnJvbSAxXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxldmVsQ29uZmlndXJhdGlvbihsZXZlbHM6IExldmVsQ29uZmlndXJhdGlvbltdKTogTGV2ZWxWYWxpZGF0aW9uIHtcbiAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdObyBsZXZlbCBjb25maWd1cmF0aW9ucyBwcm92aWRlZCcsXG4gICAgfTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBhdCBsZWFzdCBvbmUgY29sbGVjdGlvblxuICBjb25zdCBoYXNDb2xsZWN0aW9uID0gbGV2ZWxzLnNvbWUoKGxldmVsKSA9PiBsZXZlbC5yb2xlID09PSAnY29sbGVjdGlvbicpO1xuICBpZiAoIWhhc0NvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdBdCBsZWFzdCBvbmUgbGV2ZWwgbXVzdCBiZSBtYXBwZWQgYXMgQ29sbGVjdGlvbicsXG4gICAgfTtcbiAgfVxuXG4gIC8vIENoZWNrIGRlcHRocyBhcmUgc2VxdWVudGlhbFxuICBjb25zdCBkZXB0aHMgPSBsZXZlbHMubWFwKChsZXZlbCkgPT4gbGV2ZWwuZGVwdGgpLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZGVwdGhzW2ldICE9PSBpICsgMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcjogYExldmVsIGRlcHRocyBtdXN0IGJlIHNlcXVlbnRpYWwgc3RhcnRpbmcgZnJvbSAxLiBGb3VuZCBnYXAgYXQgZGVwdGggJHtpICsgMX1gLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBXYXJuaW5nc1xuICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgaGFzTW9kZSA9IGxldmVscy5zb21lKChsZXZlbCkgPT4gbGV2ZWwucm9sZSA9PT0gJ21vZGUnKTtcbiAgaWYgKCFoYXNNb2RlKSB7XG4gICAgd2FybmluZ3MucHVzaCgnTm8gTW9kZSBsZXZlbCBkZWZpbmVkIC0gYSBkZWZhdWx0IG1vZGUgd2lsbCBiZSBjcmVhdGVkJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbGlkOiB0cnVlLFxuICAgIHdhcm5pbmdzOiB3YXJuaW5ncy5sZW5ndGggPiAwID8gd2FybmluZ3MgOiB1bmRlZmluZWQsXG4gIH07XG59XG5cbi8qKlxuICogRXh0cmFjdCBtb2RlIG5hbWUgZnJvbSBmaWxlbmFtZVxuICogU3VwcG9ydHMgcGF0dGVybnMgbGlrZTpcbiAqIC0gXCJzZW1hbnRpYy1saWdodC5qc29uXCIgLT4gXCJsaWdodFwiXG4gKiAtIFwidGhlbWUuZGFyay5qc29uXCIgLT4gXCJkYXJrXCJcbiAqIC0gXCJtb2JpbGVfdGhlbWUuanNvblwiIC0+IFwibW9iaWxlX3RoZW1lXCJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RNb2RlTmFtZUZyb21GaWxlbmFtZShmaWxlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gUmVtb3ZlIC5qc29uIGV4dGVuc2lvblxuICBjb25zdCBuYW1lV2l0aG91dEV4dCA9IGZpbGVOYW1lLnJlcGxhY2UoL1xcLmpzb24kL2ksICcnKTtcblxuICAvLyBUcnkgaHlwaGVuIHNlcGFyYXRvciAoc2VtYW50aWMtbGlnaHQpXG4gIGlmIChuYW1lV2l0aG91dEV4dC5pbmNsdWRlcygnLScpKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lV2l0aG91dEV4dC5zcGxpdCgnLScpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyeSBkb3Qgc2VwYXJhdG9yICh0aGVtZS5saWdodClcbiAgaWYgKG5hbWVXaXRob3V0RXh0LmluY2x1ZGVzKCcuJykpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWVXaXRob3V0RXh0LnNwbGl0KCcuJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9XG5cbiAgLy8gVHJ5IHVuZGVyc2NvcmUgc2VwYXJhdG9yIChtb2JpbGVfdGhlbWUpXG4gIGlmIChuYW1lV2l0aG91dEV4dC5pbmNsdWRlcygnXycpKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lV2l0aG91dEV4dC5zcGxpdCgnXycpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGxiYWNrOiByZXR1cm4gZnVsbCBuYW1lIHdpdGhvdXQgZXh0ZW5zaW9uXG4gIHJldHVybiBuYW1lV2l0aG91dEV4dDtcbn1cblxuLyoqXG4gKiBTdWdnZXN0IGNvbGxlY3Rpb24gbmFtZSBmcm9tIGdyb3VwZWQgZmlsZSBuYW1lc1xuICogRmluZHMgY29tbW9uIHByZWZpeCBmcm9tIGZpbGVuYW1lc1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3VnZ2VzdENvbGxlY3Rpb25OYW1lKGZpbGVOYW1lczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBpZiAoZmlsZU5hbWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdUb2tlbnMnO1xuICBpZiAoZmlsZU5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFJlbW92ZSBtb2RlIHN1ZmZpeCBhbmQgZXh0ZW5zaW9uXG4gICAgcmV0dXJuIGZpbGVOYW1lc1swXVxuICAgICAgLnJlcGxhY2UoL1xcLmpzb24kL2ksICcnKVxuICAgICAgLnJlcGxhY2UoL1stLl9dKGxpZ2h0fGRhcmt8bW9iaWxlfGRlc2t0b3ApJC9pLCAnJyk7XG4gIH1cblxuICAvLyBGaW5kIGNvbW1vbiBwcmVmaXhcbiAgY29uc3QgcHJlZml4ID0gZmluZENvbW1vblByZWZpeChmaWxlTmFtZXMubWFwKChmKSA9PiBmLnJlcGxhY2UoL1xcLmpzb24kL2ksICcnKSkpO1xuXG4gIHJldHVybiBwcmVmaXggfHwgJ1Rva2Vucyc7XG59XG5cbi8qKlxuICogRmluZCBjb21tb24gcHJlZml4IGFtb25nIHN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vblByZWZpeChzdHJpbmdzOiBzdHJpbmdbXSk6IHN0cmluZyB7XG4gIGlmIChzdHJpbmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuXG4gIGxldCBwcmVmaXggPSBzdHJpbmdzWzBdO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgIHdoaWxlICghc3RyaW5nc1tpXS5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICAgIHByZWZpeCA9IHByZWZpeC5zbGljZSgwLCAtMSk7XG4gICAgICBpZiAocHJlZml4ID09PSAnJykgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSB0cmFpbGluZyBzZXBhcmF0b3JzXG4gIHJldHVybiBwcmVmaXgucmVwbGFjZSgvWy0uX10rJC8sICcnKTtcbn1cbiIsICIvKipcbiAqIEZpbGUgR3JvdXBpbmcgSGVscGVyIFV0aWxpdGllc1xuICogQXV0by1zdWdnZXN0IGZpbGUgZ3JvdXBzIGJhc2VkIG9uIGZpbGVuYW1lIHBhdHRlcm5zXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBGaWxlR3JvdXAgfSBmcm9tICcuLi8uLi90eXBlcy9sZXZlbC1jb25maWcudHlwZXMuanMnO1xuaW1wb3J0IHR5cGUgeyBVcGxvYWRlZEZpbGUgfSBmcm9tICcuLi9zdGF0ZS5qcyc7XG5pbXBvcnQgeyBzdWdnZXN0Q29sbGVjdGlvbk5hbWUsIGV4dHJhY3RNb2RlTmFtZUZyb21GaWxlbmFtZSB9IGZyb20gJy4uLy4uL3R5cGVzL2xldmVsLWNvbmZpZy50eXBlcy5qcyc7XG5cbi8qKlxuICogU3VnZ2VzdCBpbml0aWFsIGZpbGUgZ3JvdXBzIGJhc2VkIG9uIGZpbGVuYW1lIHBhdHRlcm5zXG4gKiBHcm91cHMgZmlsZXMgd2l0aCBjb21tb24gcHJlZml4ZXMgKGUuZy4sIFwic2VtYW50aWMtbGlnaHRcIiBhbmQgXCJzZW1hbnRpYy1kYXJrXCIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWdnZXN0RmlsZUdyb3VwcyhmaWxlczogTWFwPHN0cmluZywgVXBsb2FkZWRGaWxlPik6IEZpbGVHcm91cFtdIHtcbiAgY29uc3QgZmlsZU5hbWVzID0gQXJyYXkuZnJvbShmaWxlcy5rZXlzKCkpO1xuXG4gIGlmIChmaWxlTmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gSWYgb25seSBvbmUgZmlsZSwgY3JlYXRlIG9uZSBncm91cFxuICBpZiAoZmlsZU5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGZpbGVOYW1lID0gZmlsZU5hbWVzWzBdO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUdyb3VwSWQoKSxcbiAgICAgICAgY29sbGVjdGlvbk5hbWU6IGV4dHJhY3RDb2xsZWN0aW9uTmFtZUZyb21GaWxlbmFtZShmaWxlTmFtZSksXG4gICAgICAgIGZpbGVOYW1lczogW2ZpbGVOYW1lXSxcbiAgICAgICAgbW9kZVN0cmF0ZWd5OiAnbWVyZ2VkJyxcbiAgICAgICAgbW9kZU5hbWVzOiB7fSxcbiAgICAgIH0sXG4gICAgXTtcbiAgfVxuXG4gIC8vIEFuYWx5emUgZmlsZW5hbWUgcGF0dGVybnMgdG8gZmluZCBncm91cHNcbiAgY29uc3QgcHJlZml4TWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZ1tdPigpO1xuXG4gIGZvciAoY29uc3QgZmlsZU5hbWUgb2YgZmlsZU5hbWVzKSB7XG4gICAgY29uc3QgcHJlZml4ID0gZXh0cmFjdEZpbGVQcmVmaXgoZmlsZU5hbWUpO1xuXG4gICAgaWYgKCFwcmVmaXhNYXAuaGFzKHByZWZpeCkpIHtcbiAgICAgIHByZWZpeE1hcC5zZXQocHJlZml4LCBbXSk7XG4gICAgfVxuICAgIHByZWZpeE1hcC5nZXQocHJlZml4KSEucHVzaChmaWxlTmFtZSk7XG4gIH1cblxuICAvLyBDcmVhdGUgZ3JvdXBzIGZyb20gcHJlZml4IG1hcFxuICBjb25zdCBncm91cHM6IEZpbGVHcm91cFtdID0gW107XG5cbiAgZm9yIChjb25zdCBbcHJlZml4LCBncm91cEZpbGVOYW1lc10gb2YgcHJlZml4TWFwKSB7XG4gICAgY29uc3QgY29sbGVjdGlvbk5hbWUgPSBzdWdnZXN0Q29sbGVjdGlvbk5hbWUoZ3JvdXBGaWxlTmFtZXMpO1xuXG4gICAgLy8gSWYgbXVsdGlwbGUgZmlsZXMgd2l0aCBzYW1lIHByZWZpeCwgc3VnZ2VzdCBwZXItZmlsZSBtb2RlIHN0cmF0ZWd5XG4gICAgY29uc3QgbW9kZVN0cmF0ZWd5ID0gZ3JvdXBGaWxlTmFtZXMubGVuZ3RoID4gMSA/ICdwZXItZmlsZScgOiAnbWVyZ2VkJztcblxuICAgIC8vIEV4dHJhY3QgbW9kZSBuYW1lcyBmb3IgcGVyLWZpbGUgc3RyYXRlZ3lcbiAgICBjb25zdCBtb2RlTmFtZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgICBpZiAobW9kZVN0cmF0ZWd5ID09PSAncGVyLWZpbGUnKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIGdyb3VwRmlsZU5hbWVzKSB7XG4gICAgICAgIGNvbnN0IG1vZGVOYW1lID0gZXh0cmFjdE1vZGVOYW1lRnJvbUZpbGVuYW1lKGZpbGVOYW1lICsgJy5qc29uJyk7XG4gICAgICAgIG1vZGVOYW1lc1tmaWxlTmFtZV0gPSBtb2RlTmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBncm91cHMucHVzaCh7XG4gICAgICBpZDogZ2VuZXJhdGVHcm91cElkKCksXG4gICAgICBjb2xsZWN0aW9uTmFtZSxcbiAgICAgIGZpbGVOYW1lczogZ3JvdXBGaWxlTmFtZXMsXG4gICAgICBtb2RlU3RyYXRlZ3ksXG4gICAgICBtb2RlTmFtZXMsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZ3JvdXBzO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgY29tbW9uIHByZWZpeCBmcm9tIGZpbGVuYW1lIGZvciBncm91cGluZ1xuICogU3VwcG9ydHMgc2VwYXJhdG9yczogaHlwaGVuICgtKSwgdW5kZXJzY29yZSAoXyksIGRvdCAoLilcbiAqXG4gKiBFeGFtcGxlczpcbiAqIC0gXCJzZW1hbnRpYy1saWdodFwiIC0+IFwic2VtYW50aWNcIlxuICogLSBcInNlbWFudGljLWRhcmtcIiAtPiBcInNlbWFudGljXCJcbiAqIC0gXCJ0aGVtZS5saWdodFwiIC0+IFwidGhlbWVcIlxuICogLSBcInByaW1pdGl2ZXNcIiAtPiBcInByaW1pdGl2ZXNcIlxuICovXG5mdW5jdGlvbiBleHRyYWN0RmlsZVByZWZpeChmaWxlTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gVHJ5IGh5cGhlbiBzZXBhcmF0b3JcbiAgaWYgKGZpbGVOYW1lLmluY2x1ZGVzKCctJykpIHtcbiAgICBjb25zdCBwYXJ0cyA9IGZpbGVOYW1lLnNwbGl0KCctJyk7XG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICByZXR1cm4gcGFydHMuc2xpY2UoMCwgLTEpLmpvaW4oJy0nKTtcbiAgICB9XG4gIH1cblxuICAvLyBUcnkgZG90IHNlcGFyYXRvclxuICBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoJy4nKSkge1xuICAgIGNvbnN0IHBhcnRzID0gZmlsZU5hbWUuc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiBwYXJ0cy5zbGljZSgwLCAtMSkuam9pbignLicpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyeSB1bmRlcnNjb3JlIHNlcGFyYXRvclxuICBpZiAoZmlsZU5hbWUuaW5jbHVkZXMoJ18nKSkge1xuICAgIGNvbnN0IHBhcnRzID0gZmlsZU5hbWUuc3BsaXQoJ18nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiBwYXJ0cy5zbGljZSgwLCAtMSkuam9pbignXycpO1xuICAgIH1cbiAgfVxuXG4gIC8vIE5vIHNlcGFyYXRvciBmb3VuZCwgcmV0dXJuIGZ1bGwgbmFtZSBhcyBwcmVmaXhcbiAgcmV0dXJuIGZpbGVOYW1lO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgY29sbGVjdGlvbiBuYW1lIGZyb20gYSBzaW5nbGUgZmlsZW5hbWVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbGxlY3Rpb25OYW1lRnJvbUZpbGVuYW1lKGZpbGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAvLyBSZW1vdmUgY29tbW9uIG1vZGUgc3VmZml4ZXNcbiAgcmV0dXJuIGZpbGVOYW1lXG4gICAgLnJlcGxhY2UoL1stLl9dKGxpZ2h0fGRhcmt8bW9iaWxlfGRlc2t0b3B8ZGVmYXVsdCkkL2ksICcnKVxuICAgIHx8ICdUb2tlbnMnO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHVuaXF1ZSBncm91cCBJRFxuICovXG5sZXQgZ3JvdXBJZENvdW50ZXIgPSAwO1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlR3JvdXBJZCgpOiBzdHJpbmcge1xuICByZXR1cm4gYGdyb3VwLSR7RGF0ZS5ub3coKX0tJHtncm91cElkQ291bnRlcisrfWA7XG59XG5cbi8qKlxuICogRmluZCBncm91cCBjb250YWluaW5nIGEgc3BlY2lmaWMgZmlsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEdyb3VwQnlGaWxlKGdyb3VwczogRmlsZUdyb3VwW10sIGZpbGVOYW1lOiBzdHJpbmcpOiBGaWxlR3JvdXAgfCB1bmRlZmluZWQge1xuICByZXR1cm4gZ3JvdXBzLmZpbmQoKGdyb3VwKSA9PiBncm91cC5maWxlTmFtZXMuaW5jbHVkZXMoZmlsZU5hbWUpKTtcbn1cblxuLyoqXG4gKiBNb3ZlIGZpbGUgZnJvbSBvbmUgZ3JvdXAgdG8gYW5vdGhlclxuICovXG5leHBvcnQgZnVuY3Rpb24gbW92ZUZpbGVUb0dyb3VwKFxuICBncm91cHM6IEZpbGVHcm91cFtdLFxuICBmaWxlTmFtZTogc3RyaW5nLFxuICB0YXJnZXRHcm91cElkOiBzdHJpbmdcbik6IEZpbGVHcm91cFtdIHtcbiAgLy8gUmVtb3ZlIGZpbGUgZnJvbSBjdXJyZW50IGdyb3VwXG4gIGNvbnN0IHVwZGF0ZWRHcm91cHMgPSBncm91cHMubWFwKChncm91cCkgPT4gKHtcbiAgICAuLi5ncm91cCxcbiAgICBmaWxlTmFtZXM6IGdyb3VwLmZpbGVOYW1lcy5maWx0ZXIoKG5hbWUpID0+IG5hbWUgIT09IGZpbGVOYW1lKSxcbiAgfSkpO1xuXG4gIC8vIEFkZCBmaWxlIHRvIHRhcmdldCBncm91cFxuICByZXR1cm4gdXBkYXRlZEdyb3Vwcy5tYXAoKGdyb3VwKSA9PiB7XG4gICAgaWYgKGdyb3VwLmlkID09PSB0YXJnZXRHcm91cElkKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ncm91cCxcbiAgICAgICAgZmlsZU5hbWVzOiBbLi4uZ3JvdXAuZmlsZU5hbWVzLCBmaWxlTmFtZV0sXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZSBlbXB0eSBncm91cHMgKG5vIGZpbGVzKVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRW1wdHlHcm91cHMoZ3JvdXBzOiBGaWxlR3JvdXBbXSk6IEZpbGVHcm91cFtdIHtcbiAgcmV0dXJuIGdyb3Vwcy5maWx0ZXIoKGdyb3VwKSA9PiBncm91cC5maWxlTmFtZXMubGVuZ3RoID4gMCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGVtcHR5IGdyb3VwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVOZXdHcm91cCgpOiBGaWxlR3JvdXAge1xuICByZXR1cm4ge1xuICAgIGlkOiBnZW5lcmF0ZUdyb3VwSWQoKSxcbiAgICBjb2xsZWN0aW9uTmFtZTogJ05ldyBDb2xsZWN0aW9uJyxcbiAgICBmaWxlTmFtZXM6IFtdLFxuICAgIG1vZGVTdHJhdGVneTogJ21lcmdlZCcsXG4gICAgbW9kZU5hbWVzOiB7fSxcbiAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgZ3JvdXAgY29sbGVjdGlvbiBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVHcm91cE5hbWUoXG4gIGdyb3VwczogRmlsZUdyb3VwW10sXG4gIGdyb3VwSWQ6IHN0cmluZyxcbiAgbmV3TmFtZTogc3RyaW5nXG4pOiBGaWxlR3JvdXBbXSB7XG4gIHJldHVybiBncm91cHMubWFwKChncm91cCkgPT4ge1xuICAgIGlmIChncm91cC5pZCA9PT0gZ3JvdXBJZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZ3JvdXAsXG4gICAgICAgIGNvbGxlY3Rpb25OYW1lOiBuZXdOYW1lLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgZ3JvdXAgbW9kZSBzdHJhdGVneVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlR3JvdXBNb2RlU3RyYXRlZ3koXG4gIGdyb3VwczogRmlsZUdyb3VwW10sXG4gIGdyb3VwSWQ6IHN0cmluZyxcbiAgbW9kZVN0cmF0ZWd5OiAncGVyLWZpbGUnIHwgJ21lcmdlZCdcbik6IEZpbGVHcm91cFtdIHtcbiAgcmV0dXJuIGdyb3Vwcy5tYXAoKGdyb3VwKSA9PiB7XG4gICAgaWYgKGdyb3VwLmlkID09PSBncm91cElkKSB7XG4gICAgICAvLyBJZiBzd2l0Y2hpbmcgdG8gcGVyLWZpbGUsIGV4dHJhY3QgbW9kZSBuYW1lc1xuICAgICAgY29uc3QgbW9kZU5hbWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgICBpZiAobW9kZVN0cmF0ZWd5ID09PSAncGVyLWZpbGUnKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsZU5hbWUgb2YgZ3JvdXAuZmlsZU5hbWVzKSB7XG4gICAgICAgICAgY29uc3QgbW9kZU5hbWUgPSBleHRyYWN0TW9kZU5hbWVGcm9tRmlsZW5hbWUoZmlsZU5hbWUgKyAnLmpzb24nKTtcbiAgICAgICAgICBtb2RlTmFtZXNbZmlsZU5hbWVdID0gbW9kZU5hbWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZ3JvdXAsXG4gICAgICAgIG1vZGVTdHJhdGVneSxcbiAgICAgICAgbW9kZU5hbWVzLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgbW9kZSBuYW1lIGZvciBhIHNwZWNpZmljIGZpbGUgaW4gYSBncm91cFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTW9kZU5hbWUoXG4gIGdyb3VwczogRmlsZUdyb3VwW10sXG4gIGdyb3VwSWQ6IHN0cmluZyxcbiAgZmlsZU5hbWU6IHN0cmluZyxcbiAgbW9kZU5hbWU6IHN0cmluZ1xuKTogRmlsZUdyb3VwW10ge1xuICByZXR1cm4gZ3JvdXBzLm1hcCgoZ3JvdXApID0+IHtcbiAgICBpZiAoZ3JvdXAuaWQgPT09IGdyb3VwSWQgJiYgZ3JvdXAubW9kZU5hbWVzKSB7XG4gICAgICBjb25zdCB1cGRhdGVkTW9kZU5hbWVzID0geyAuLi5ncm91cC5tb2RlTmFtZXMsIFtmaWxlTmFtZV06IG1vZGVOYW1lIH07XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmdyb3VwLFxuICAgICAgICBtb2RlTmFtZXM6IHVwZGF0ZWRNb2RlTmFtZXMsXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH0pO1xufVxuIiwgIi8qKlxuICogRmlsZSBHcm91cGluZyBDb21wb25lbnRcbiAqIE11bHRpLWZpbGUgaW1wb3J0OiBkcmFnLWFuZC1kcm9wIGZpbGUgb3JnYW5pemF0aW9uIGludG8gY29sbGVjdGlvbiBncm91cHNcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IEZpbGVHcm91cCB9IGZyb20gJy4uLy4uL3R5cGVzL2xldmVsLWNvbmZpZy50eXBlcy5qcyc7XG5pbXBvcnQgeyBnZXRTdGF0ZSwgc2V0RmlsZUdyb3VwcyB9IGZyb20gJy4uL3N0YXRlLmpzJztcbmltcG9ydCB7IHNlbmRNZXNzYWdlIH0gZnJvbSAnLi4vbWVzc2FnZS1icmlkZ2UuanMnO1xuaW1wb3J0IHtcbiAgc3VnZ2VzdEZpbGVHcm91cHMsXG4gIG1vdmVGaWxlVG9Hcm91cCxcbiAgcmVtb3ZlRW1wdHlHcm91cHMsXG4gIGNyZWF0ZU5ld0dyb3VwLFxuICB1cGRhdGVHcm91cE5hbWUsXG4gIHVwZGF0ZUdyb3VwTW9kZVN0cmF0ZWd5LFxuICB1cGRhdGVNb2RlTmFtZSxcbn0gZnJvbSAnLi4vdXRpbHMvZmlsZS1ncm91cGluZy1oZWxwZXJzLmpzJztcblxubGV0IGN1cnJlbnREcmFnZ2VkRmlsZTogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5sZXQgdWlSZWFkeVRpbWVzdGFtcDogbnVtYmVyID0gMDtcblxuLy8gU3RvcmUgYW5hbHl6ZWQgZmlyc3QtbGV2ZWwga2V5cyBwZXIgZmlsZVxuY29uc3QgYW5hbHl6ZWRGaXJzdExldmVsS2V5czogTWFwPHN0cmluZywgc3RyaW5nW10+ID0gbmV3IE1hcCgpO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYW5kIHJlbmRlciBmaWxlIGdyb3VwaW5nIGNvbXBvbmVudFxuICogT25seSBzaG93biB3aGVuIG11bHRpcGxlIGZpbGVzIGFyZSB1cGxvYWRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyRmlsZUdyb3VwaW5nKCk6IHZvaWQge1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmlsZUdyb3VwaW5nQ29udGFpbmVyJyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgY29uc29sZS5lcnJvcignW0ZpbGVHcm91cGluZ10gQ29udGFpbmVyIGVsZW1lbnQgbm90IGZvdW5kJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuXG4gIC8vIE9ubHkgc2hvdyBmb3IgbXVsdGlwbGUgZmlsZXNcbiAgaWYgKHN0YXRlLmZpbGVzLnNpemUgPCAyKSB7XG4gICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gIC8vIEF1dG8tc3VnZ2VzdCBncm91cHMgaWYgbm90IGFscmVhZHkgc2V0XG4gIGlmICghc3RhdGUuZmlsZUdyb3VwcyB8fCBzdGF0ZS5maWxlR3JvdXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnN0IHN1Z2dlc3RlZEdyb3VwcyA9IHN1Z2dlc3RGaWxlR3JvdXBzKHN0YXRlLmZpbGVzKTtcbiAgICBzZXRGaWxlR3JvdXBzKHN1Z2dlc3RlZEdyb3Vwcyk7XG4gIH1cblxuICAvLyBTZXQgdGltZXN0YW1wIHRvIGJsb2NrIGF1dG8tdHJpZ2dlcnMgZm9yIGZpcnN0IDUwMG1zXG4gIHVpUmVhZHlUaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICBjb25zb2xlLmxvZygnW0ZpbGVHcm91cGluZ10gVUkgcmVhZHkgYXQ6JywgdWlSZWFkeVRpbWVzdGFtcCk7XG5cbiAgLy8gUmVuZGVyIHRoZSBVSVxuICByZW5kZXJHcm91cGluZ1VJKGNvbnRhaW5lcik7XG59XG5cbi8qKlxuICogSGlkZSBmaWxlIGdyb3VwaW5nIGNvbXBvbmVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaGlkZUZpbGVHcm91cGluZygpOiB2b2lkIHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGVHcm91cGluZ0NvbnRhaW5lcicpO1xuICBpZiAoY29udGFpbmVyKSB7XG4gICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIGZpbGUgZ3JvdXBpbmcgVUlcbiAqL1xuZnVuY3Rpb24gcmVuZGVyR3JvdXBpbmdVSShjb250YWluZXI6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgY29uc3QgZ3JvdXBzID0gc3RhdGUuZmlsZUdyb3VwcyB8fCBbXTtcblxuICBjb250YWluZXIuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJmaWxlLWdyb3VwaW5nXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi10aXRsZVwiPjIuIENvbmZpZ3VyZSBDb2xsZWN0aW9uczwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tZGVzY3JpcHRpb25cIj5cbiAgICAgICAgT3JnYW5pemUgZmlsZXMgaW50byBjb2xsZWN0aW9ucyBhbmQgY29uZmlndXJlIGhvdyBtb2RlcyBhcmUgaGFuZGxlZC5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiZ3JvdXBzLWNvbnRhaW5lclwiIGlkPVwiZ3JvdXBzQ29udGFpbmVyXCI+XG4gICAgICAgICR7Z3JvdXBzLm1hcCgoZ3JvdXApID0+IHJlbmRlckdyb3VwQ2FyZChncm91cCkpLmpvaW4oJycpfVxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24tYWRkXCIgaWQ9XCJjcmVhdGVHcm91cEJ0blwiPlxuICAgICAgICArIENyZWF0ZSBOZXcgQ29sbGVjdGlvblxuICAgICAgPC9idXR0b24+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJncm91cGluZy1hY3Rpb25zXCI+XG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidXR0b24gYnV0dG9uLXByaW1hcnkgYnV0dG9uLWZ1bGxcIiBpZD1cImltcG9ydEFsbEJ0blwiPlxuICAgICAgICAgIEltcG9ydCBBbGwgQ29sbGVjdGlvbnNcbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYDtcblxuICAvLyBBbmFseXplIGZpcnN0LWxldmVsIGtleXMgZm9yIGFsbCBmaWxlc1xuICBhbmFseXplQWxsRmlsZXNGaXJzdExldmVsKCk7XG5cbiAgLy8gQXR0YWNoIGV2ZW50IGxpc3RlbmVyc1xuICBhdHRhY2hHcm91cGluZ0V2ZW50TGlzdGVuZXJzKCk7XG59XG5cbi8qKlxuICogUmVuZGVyIGEgc2luZ2xlIGdyb3VwIGNhcmRcbiAqL1xuZnVuY3Rpb24gcmVuZGVyR3JvdXBDYXJkKGdyb3VwOiBGaWxlR3JvdXApOiBzdHJpbmcge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IGlzU2luZ2xlRmlsZSA9IGdyb3VwLmZpbGVOYW1lcy5sZW5ndGggPT09IDE7XG5cbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwiZ3JvdXAtY2FyZFwiIGRhdGEtZ3JvdXAtaWQ9XCIke2VzY2FwZUh0bWwoZ3JvdXAuaWQpfVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImdyb3VwLWhlYWRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZ3JvdXAtaWNvblwiPlx1RDgzRFx1RENFNjwvZGl2PlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgY2xhc3M9XCJncm91cC1uYW1lLWlucHV0XCJcbiAgICAgICAgICB2YWx1ZT1cIiR7ZXNjYXBlSHRtbChncm91cC5jb2xsZWN0aW9uTmFtZSl9XCJcbiAgICAgICAgICBkYXRhLWdyb3VwLWlkPVwiJHtlc2NhcGVIdG1sKGdyb3VwLmlkKX1cIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiQ29sbGVjdGlvbiBuYW1lXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzPVwiZ3JvdXAtZmlsZXNcIiBkYXRhLWdyb3VwLWlkPVwiJHtlc2NhcGVIdG1sKGdyb3VwLmlkKX1cIj5cbiAgICAgICAgJHtncm91cC5maWxlTmFtZXMubWFwKChmaWxlTmFtZSkgPT4gcmVuZGVyRmlsZUNhcmQoZmlsZU5hbWUsIGdyb3VwLmlkKSkuam9pbignJyl9XG4gICAgICA8L2Rpdj5cblxuICAgICAgJHtpc1NpbmdsZUZpbGUgPyByZW5kZXJTaW5nbGVGaWxlTW9kZU9wdGlvbnMoZ3JvdXApIDogcmVuZGVyTXVsdGlGaWxlTW9kZU9wdGlvbnMoZ3JvdXApfVxuICAgIDwvZGl2PlxuICBgO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIGRyYWdnYWJsZSBmaWxlIGNhcmRcbiAqL1xuZnVuY3Rpb24gcmVuZGVyRmlsZUNhcmQoZmlsZU5hbWU6IHN0cmluZywgZ3JvdXBJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBjb25zdCBmaWxlID0gc3RhdGUuZmlsZXMuZ2V0KGZpbGVOYW1lKTtcblxuICBpZiAoIWZpbGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gYFxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwiZmlsZS1jYXJkXCJcbiAgICAgIGRyYWdnYWJsZT1cInRydWVcIlxuICAgICAgZGF0YS1maWxlLW5hbWU9XCIke2VzY2FwZUh0bWwoZmlsZU5hbWUpfVwiXG4gICAgICBkYXRhLWdyb3VwLWlkPVwiJHtlc2NhcGVIdG1sKGdyb3VwSWQpfVwiXG4gICAgPlxuICAgICAgPGRpdiBjbGFzcz1cImZpbGUtY2FyZC1pY29uXCI+XHVEODNEXHVEQ0M0PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiZmlsZS1jYXJkLWluZm9cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZpbGUtY2FyZC1uYW1lXCI+JHtlc2NhcGVIdG1sKGZpbGVOYW1lKX0uanNvbjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsZS1jYXJkLXNpemVcIj4ke2Zvcm1hdEZpbGVTaXplKGZpbGUuc2l6ZSl9PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJmaWxlLWNhcmQtZHJhZy1oYW5kbGVcIj5cdTIyRUVcdTIyRUU8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYDtcbn1cblxuLyoqXG4gKiBSZW5kZXIgbW9kZSBvcHRpb25zIGZvciBzaW5nbGUtZmlsZSBncm91cHNcbiAqIE9wdGlvbnM6IFwiRmlyc3QgbGV2ZWwgcmVwcmVzZW50cyBtb2Rlc1wiIHZzIFwiTm8gbW9kZXMgKGRlZmF1bHQgbW9kZSlcIlxuICovXG5mdW5jdGlvbiByZW5kZXJTaW5nbGVGaWxlTW9kZU9wdGlvbnMoZ3JvdXA6IEZpbGVHcm91cCk6IHN0cmluZyB7XG4gIGNvbnN0IGZpbGVOYW1lID0gZ3JvdXAuZmlsZU5hbWVzWzBdO1xuICBjb25zdCBmaXJzdExldmVsS2V5cyA9IGFuYWx5emVkRmlyc3RMZXZlbEtleXMuZ2V0KGZpbGVOYW1lKSB8fCBbXTtcbiAgY29uc3QgaXNQZXJGaWxlID0gZ3JvdXAubW9kZVN0cmF0ZWd5ID09PSAncGVyLWZpbGUnO1xuICBcbiAgLy8gRGlzcGxheSBmaXJzdCBsZXZlbCBrZXlzIHByZXZpZXdcbiAgY29uc3Qga2V5c1ByZXZpZXcgPSBmaXJzdExldmVsS2V5cy5sZW5ndGggPiAwIFxuICAgID8gZmlyc3RMZXZlbEtleXMuc2xpY2UoMCwgNSkuam9pbignLCAnKSArIChmaXJzdExldmVsS2V5cy5sZW5ndGggPiA1ID8gJy4uLicgOiAnJylcbiAgICA6ICdBbmFseXppbmcuLi4nO1xuXG4gIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cIm1vZGUtb3B0aW9uc1wiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1vZGUtb3B0aW9ucy10aXRsZVwiPkhvdyBzaG91bGQgbW9kZXMgYmUgZGV0ZXJtaW5lZD88L2Rpdj5cblxuICAgICAgPGxhYmVsIGNsYXNzPVwibW9kZS1vcHRpb24gJHtpc1BlckZpbGUgPyAnc2VsZWN0ZWQnIDogJyd9XCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgbmFtZT1cIm1vZGUtc3RyYXRlZ3ktJHtlc2NhcGVIdG1sKGdyb3VwLmlkKX1cIlxuICAgICAgICAgIHZhbHVlPVwicGVyLWZpbGVcIlxuICAgICAgICAgIGRhdGEtZ3JvdXAtaWQ9XCIke2VzY2FwZUh0bWwoZ3JvdXAuaWQpfVwiXG4gICAgICAgICAgJHtpc1BlckZpbGUgPyAnY2hlY2tlZCcgOiAnJ31cbiAgICAgICAgLz5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJyYWRpby1pbmRpY2F0b3JcIj48L3NwYW4+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtb2RlLW9wdGlvbi1jb250ZW50XCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGUtb3B0aW9uLWxhYmVsXCI+TW9kZXM6IEZpcnN0IGxldmVsIHJlcHJlc2VudHMgbW9kZXM8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZS1vcHRpb24tZGVzY3JpcHRpb25cIj5LZXlzOiAke2VzY2FwZUh0bWwoa2V5c1ByZXZpZXcpfTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbGFiZWw+XG5cbiAgICAgIDxsYWJlbCBjbGFzcz1cIm1vZGUtb3B0aW9uICR7IWlzUGVyRmlsZSA/ICdzZWxlY3RlZCcgOiAnJ31cIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICBuYW1lPVwibW9kZS1zdHJhdGVneS0ke2VzY2FwZUh0bWwoZ3JvdXAuaWQpfVwiXG4gICAgICAgICAgdmFsdWU9XCJtZXJnZWRcIlxuICAgICAgICAgIGRhdGEtZ3JvdXAtaWQ9XCIke2VzY2FwZUh0bWwoZ3JvdXAuaWQpfVwiXG4gICAgICAgICAgJHshaXNQZXJGaWxlID8gJ2NoZWNrZWQnIDogJyd9XG4gICAgICAgIC8+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwicmFkaW8taW5kaWNhdG9yXCI+PC9zcGFuPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZS1vcHRpb24tY29udGVudFwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RlLW9wdGlvbi1sYWJlbFwiPk5vIG1vZGVzOiBGaWxlIGhhcyBvbmUgZGVmYXVsdCBtb2RlPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGUtb3B0aW9uLWRlc2NyaXB0aW9uXCI+QWxsIHRva2VucyBpbXBvcnRlZCBpbnRvIFwiTW9kZSAxXCI8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2xhYmVsPlxuICAgIDwvZGl2PlxuICBgO1xufVxuXG4vKipcbiAqIFJlbmRlciBtb2RlIG9wdGlvbnMgZm9yIG11bHRpLWZpbGUgZ3JvdXBzXG4gKiBPcHRpb25zOiBcIkVhY2ggZmlsZSA9IDEgbW9kZVwiIHZzIFwiTWVyZ2UgYWxsIGZpbGVzXCJcbiAqL1xuZnVuY3Rpb24gcmVuZGVyTXVsdGlGaWxlTW9kZU9wdGlvbnMoZ3JvdXA6IEZpbGVHcm91cCk6IHN0cmluZyB7XG4gIGNvbnN0IGlzUGVyRmlsZSA9IGdyb3VwLm1vZGVTdHJhdGVneSA9PT0gJ3Blci1maWxlJztcblxuICByZXR1cm4gYFxuICAgIDxkaXYgY2xhc3M9XCJtb2RlLW9wdGlvbnNcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtb2RlLW9wdGlvbnMtdGl0bGVcIj5Ib3cgc2hvdWxkIHRoZXNlIGZpbGVzIGJlIGNvbWJpbmVkPzwvZGl2PlxuXG4gICAgICA8bGFiZWwgY2xhc3M9XCJtb2RlLW9wdGlvbiAke2lzUGVyRmlsZSA/ICdzZWxlY3RlZCcgOiAnJ31cIj5cbiAgICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICBuYW1lPVwibW9kZS1zdHJhdGVneS0ke2VzY2FwZUh0bWwoZ3JvdXAuaWQpfVwiXG4gICAgICAgICAgdmFsdWU9XCJwZXItZmlsZVwiXG4gICAgICAgICAgZGF0YS1ncm91cC1pZD1cIiR7ZXNjYXBlSHRtbChncm91cC5pZCl9XCJcbiAgICAgICAgICAke2lzUGVyRmlsZSA/ICdjaGVja2VkJyA6ICcnfVxuICAgICAgICAvPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInJhZGlvLWluZGljYXRvclwiPjwvc3Bhbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGUtb3B0aW9uLWNvbnRlbnRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZS1vcHRpb24tbGFiZWxcIj5FYWNoIGZpbGUgPSAxIG1vZGU8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZS1vcHRpb24tZGVzY3JpcHRpb25cIj5DcmVhdGVzICR7Z3JvdXAuZmlsZU5hbWVzLmxlbmd0aH0gbW9kZXMgaW4gdGhpcyBjb2xsZWN0aW9uPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9sYWJlbD5cblxuICAgICAgJHtpc1BlckZpbGUgPyByZW5kZXJNb2RlTmFtZXNMaXN0KGdyb3VwKSA6ICcnfVxuXG4gICAgICA8bGFiZWwgY2xhc3M9XCJtb2RlLW9wdGlvbiAkeyFpc1BlckZpbGUgPyAnc2VsZWN0ZWQnIDogJyd9XCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJyYWRpb1wiXG4gICAgICAgICAgbmFtZT1cIm1vZGUtc3RyYXRlZ3ktJHtlc2NhcGVIdG1sKGdyb3VwLmlkKX1cIlxuICAgICAgICAgIHZhbHVlPVwibWVyZ2VkXCJcbiAgICAgICAgICBkYXRhLWdyb3VwLWlkPVwiJHtlc2NhcGVIdG1sKGdyb3VwLmlkKX1cIlxuICAgICAgICAgICR7IWlzUGVyRmlsZSA/ICdjaGVja2VkJyA6ICcnfVxuICAgICAgICAvPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInJhZGlvLWluZGljYXRvclwiPjwvc3Bhbj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGUtb3B0aW9uLWNvbnRlbnRcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZS1vcHRpb24tbGFiZWxcIj5NZXJnZSBpbnRvIDEgbW9kZTwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RlLW9wdGlvbi1kZXNjcmlwdGlvblwiPkFsbCB0b2tlbnMgY29tYmluZWQgaW50byBcIk1vZGUgMVwiPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9sYWJlbD5cbiAgICA8L2Rpdj5cbiAgYDtcbn1cblxuLyoqXG4gKiBSZW5kZXIgZWRpdGFibGUgbW9kZSBuYW1lcyBsaXN0XG4gKi9cbmZ1bmN0aW9uIHJlbmRlck1vZGVOYW1lc0xpc3QoZ3JvdXA6IEZpbGVHcm91cCk6IHN0cmluZyB7XG4gIGNvbnN0IG1vZGVOYW1lcyA9IGdyb3VwLm1vZGVOYW1lcyB8fCB7fTtcblxuICByZXR1cm4gYFxuICAgIDxkaXYgY2xhc3M9XCJtb2RlLW5hbWVzLWxpc3RcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtb2RlLW5hbWVzLWxhYmVsXCI+TW9kZSBuYW1lcyAoZWRpdGFibGUpOjwvZGl2PlxuICAgICAgJHtncm91cC5maWxlTmFtZXNcbiAgICAgICAgLm1hcCgoZmlsZU5hbWUpID0+IHtcbiAgICAgICAgICAvLyBTdXBwb3J0IGJvdGggUmVjb3JkPHN0cmluZywgc3RyaW5nPiBhbmQgTWFwPHN0cmluZywgc3RyaW5nPlxuICAgICAgICAgIGNvbnN0IG1vZGVOYW1lID0gdHlwZW9mIG1vZGVOYW1lcyA9PT0gJ29iamVjdCcgJiYgISgnZ2V0JyBpbiBtb2RlTmFtZXMpXG4gICAgICAgICAgICA/IChtb2RlTmFtZXMgYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPilbZmlsZU5hbWVdIHx8IGV4dHJhY3RNb2RlTmFtZUZyb21GaWxlbmFtZShmaWxlTmFtZSlcbiAgICAgICAgICAgIDogZmlsZU5hbWU7XG4gICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RlLW5hbWUtaXRlbVwiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm1vZGUtbmFtZS1maWxlXCI+JHtlc2NhcGVIdG1sKGZpbGVOYW1lKX0uanNvbjwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtb2RlLW5hbWUtYXJyb3dcIj5cdTIxOTI8L3NwYW4+XG4gICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cIm1vZGUtbmFtZS1pbnB1dFwiXG4gICAgICAgICAgICAgICAgdmFsdWU9XCIke2VzY2FwZUh0bWwobW9kZU5hbWUpfVwiXG4gICAgICAgICAgICAgICAgZGF0YS1ncm91cC1pZD1cIiR7ZXNjYXBlSHRtbChncm91cC5pZCl9XCJcbiAgICAgICAgICAgICAgICBkYXRhLWZpbGUtbmFtZT1cIiR7ZXNjYXBlSHRtbChmaWxlTmFtZSl9XCJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIk1vZGUgbmFtZVwiXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICBgO1xuICAgICAgICB9KVxuICAgICAgICAuam9pbignJyl9XG4gICAgPC9kaXY+XG4gIGA7XG59XG5cbi8qKlxuICogRXh0cmFjdCBtb2RlIG5hbWUgZnJvbSBmaWxlbmFtZSAoZS5nLiwgXCJzZW1hbnRpYy1saWdodFwiIC0+IFwibGlnaHRcIilcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdE1vZGVOYW1lRnJvbUZpbGVuYW1lKGZpbGVOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBwYXJ0cyA9IGZpbGVOYW1lLnNwbGl0KCctJyk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBmaWxlTmFtZTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYWxsIGV2ZW50IGxpc3RlbmVycyBmb3IgZ3JvdXBpbmcgaW50ZXJhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEdyb3VwaW5nRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gIGNvbnNvbGUubG9nKCdbRmlsZUdyb3VwaW5nXSBhdHRhY2hHcm91cGluZ0V2ZW50TGlzdGVuZXJzIGNhbGxlZCcpO1xuICBjb25zb2xlLnRyYWNlKCdbRmlsZUdyb3VwaW5nXSBUcmFjZTonKTtcblxuICAvLyBHcm91cCBuYW1lIGNoYW5nZXNcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmdyb3VwLW5hbWUtaW5wdXQnKS5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZUdyb3VwTmFtZUNoYW5nZSk7XG4gIH0pO1xuXG4gIC8vIE1vZGUgc3RyYXRlZ3kgY2hhbmdlc1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZV49XCJtb2RlLXN0cmF0ZWd5XCJdJykuZm9yRWFjaCgocmFkaW8pID0+IHtcbiAgICByYWRpby5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVNb2RlU3RyYXRlZ3lDaGFuZ2UpO1xuICB9KTtcblxuICAvLyBNb2RlIG5hbWUgY2hhbmdlc1xuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubW9kZS1uYW1lLWlucHV0JykuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVNb2RlTmFtZUNoYW5nZSk7XG4gIH0pO1xuXG4gIC8vIERyYWcgYW5kIGRyb3AgZm9yIGZpbGUgY2FyZHNcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmZpbGUtY2FyZCcpLmZvckVhY2goKGNhcmQpID0+IHtcbiAgICBjYXJkLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdTdGFydCBhcyBFdmVudExpc3RlbmVyKTtcbiAgICBjYXJkLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCBoYW5kbGVEcmFnRW5kIGFzIEV2ZW50TGlzdGVuZXIpO1xuICB9KTtcblxuICAvLyBEcm9wIHpvbmVzIChncm91cCBjb250YWluZXJzKVxuICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZ3JvdXAtZmlsZXMnKS5mb3JFYWNoKCh6b25lKSA9PiB7XG4gICAgem9uZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIGhhbmRsZURyYWdPdmVyIGFzIEV2ZW50TGlzdGVuZXIpO1xuICAgIHpvbmUuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJywgaGFuZGxlRHJhZ0xlYXZlIGFzIEV2ZW50TGlzdGVuZXIpO1xuICAgIHpvbmUuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGhhbmRsZURyb3AgYXMgRXZlbnRMaXN0ZW5lcik7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSBuZXcgZ3JvdXAgYnV0dG9uXG4gIGNvbnN0IGNyZWF0ZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjcmVhdGVHcm91cEJ0bicpO1xuICBjcmVhdGVCdG4/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ3JlYXRlTmV3R3JvdXApO1xuXG4gIC8vIEltcG9ydCBidXR0b24gKHdhcyBuZXh0U3RlcEJ0bilcbiAgY29uc3QgaW1wb3J0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ltcG9ydEFsbEJ0bicpO1xuICBjb25zb2xlLmxvZygnW0ZpbGVHcm91cGluZ10gQXR0YWNoaW5nIGNsaWNrIGxpc3RlbmVyIHRvIGltcG9ydEFsbEJ0bjonLCBpbXBvcnRCdG4pO1xuICBpbXBvcnRCdG4/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlSW1wb3J0QWxsKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgZ3JvdXAgbmFtZSBpbnB1dCBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gaGFuZGxlR3JvdXBOYW1lQ2hhbmdlKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICBjb25zdCBpbnB1dCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBncm91cElkID0gaW5wdXQuZGF0YXNldC5ncm91cElkO1xuICBjb25zdCBuZXdOYW1lID0gaW5wdXQudmFsdWUudHJpbSgpO1xuXG4gIGlmICghZ3JvdXBJZCB8fCAhbmV3TmFtZSkgcmV0dXJuO1xuXG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgY29uc3QgdXBkYXRlZEdyb3VwcyA9IHVwZGF0ZUdyb3VwTmFtZShzdGF0ZS5maWxlR3JvdXBzIHx8IFtdLCBncm91cElkLCBuZXdOYW1lKTtcbiAgc2V0RmlsZUdyb3Vwcyh1cGRhdGVkR3JvdXBzKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgbW9kZSBzdHJhdGVneSByYWRpbyBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTW9kZVN0cmF0ZWd5Q2hhbmdlKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICBjb25zdCByYWRpbyA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBncm91cElkID0gcmFkaW8uZGF0YXNldC5ncm91cElkO1xuICBjb25zdCBzdHJhdGVneSA9IHJhZGlvLnZhbHVlIGFzICdwZXItZmlsZScgfCAnbWVyZ2VkJztcblxuICBpZiAoIWdyb3VwSWQpIHJldHVybjtcblxuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IHVwZGF0ZWRHcm91cHMgPSB1cGRhdGVHcm91cE1vZGVTdHJhdGVneShzdGF0ZS5maWxlR3JvdXBzIHx8IFtdLCBncm91cElkLCBzdHJhdGVneSk7XG4gIHNldEZpbGVHcm91cHModXBkYXRlZEdyb3Vwcyk7XG5cbiAgLy8gUmUtcmVuZGVyIHRvIHNob3cvaGlkZSBtb2RlIG5hbWVzXG4gIHJlbmRlckZpbGVHcm91cGluZygpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBtb2RlIG5hbWUgaW5wdXQgY2hhbmdlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU1vZGVOYW1lQ2hhbmdlKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuICBjb25zdCBpbnB1dCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICBjb25zdCBncm91cElkID0gaW5wdXQuZGF0YXNldC5ncm91cElkO1xuICBjb25zdCBmaWxlTmFtZSA9IGlucHV0LmRhdGFzZXQuZmlsZU5hbWU7XG4gIGNvbnN0IG1vZGVOYW1lID0gaW5wdXQudmFsdWUudHJpbSgpO1xuXG4gIGlmICghZ3JvdXBJZCB8fCAhZmlsZU5hbWUgfHwgIW1vZGVOYW1lKSByZXR1cm47XG5cbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBjb25zdCB1cGRhdGVkR3JvdXBzID0gdXBkYXRlTW9kZU5hbWUoc3RhdGUuZmlsZUdyb3VwcyB8fCBbXSwgZ3JvdXBJZCwgZmlsZU5hbWUsIG1vZGVOYW1lKTtcbiAgc2V0RmlsZUdyb3Vwcyh1cGRhdGVkR3JvdXBzKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgZHJhZyBzdGFydCBldmVudFxuICovXG5mdW5jdGlvbiBoYW5kbGVEcmFnU3RhcnQoZXZlbnQ6IERyYWdFdmVudCk6IHZvaWQge1xuICBjb25zdCBjYXJkID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MRWxlbWVudDtcbiAgY29uc3QgZmlsZU5hbWUgPSBjYXJkLmRhdGFzZXQuZmlsZU5hbWU7XG5cbiAgaWYgKCFmaWxlTmFtZSkgcmV0dXJuO1xuXG4gIGN1cnJlbnREcmFnZ2VkRmlsZSA9IGZpbGVOYW1lO1xuICBjYXJkLmNsYXNzTGlzdC5hZGQoJ2RyYWdnaW5nJyk7XG5cbiAgaWYgKGV2ZW50LmRhdGFUcmFuc2Zlcikge1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnO1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0L3BsYWluJywgZmlsZU5hbWUpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGRyYWcgZW5kIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURyYWdFbmQoZXZlbnQ6IERyYWdFdmVudCk6IHZvaWQge1xuICBjb25zdCBjYXJkID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MRWxlbWVudDtcbiAgY2FyZC5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnZ2luZycpO1xuICBjdXJyZW50RHJhZ2dlZEZpbGUgPSBudWxsO1xuXG4gIC8vIFJlbW92ZSBhbGwgZHJvcCB6b25lIGhpZ2hsaWdodHNcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmdyb3VwLWZpbGVzJykuZm9yRWFjaCgoem9uZSkgPT4ge1xuICAgIHpvbmUuY2xhc3NMaXN0LnJlbW92ZSgnZHJvcC16b25lLWFjdGl2ZScpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgZHJhZyBvdmVyIGV2ZW50IChzaG93IGRyb3Agem9uZSlcbiAqL1xuZnVuY3Rpb24gaGFuZGxlRHJhZ092ZXIoZXZlbnQ6IERyYWdFdmVudCk6IHZvaWQge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gIGNvbnN0IHpvbmUgPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICBjb25zdCB0YXJnZXRHcm91cElkID0gem9uZS5kYXRhc2V0Lmdyb3VwSWQ7XG5cbiAgaWYgKCF0YXJnZXRHcm91cElkIHx8ICFjdXJyZW50RHJhZ2dlZEZpbGUpIHJldHVybjtcblxuICAvLyBEb24ndCBhbGxvdyBkcm9wcGluZyBvbiB0aGUgc2FtZSBncm91cFxuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IGN1cnJlbnRHcm91cCA9IHN0YXRlLmZpbGVHcm91cHM/LmZpbmQoKGcpID0+IGcuZmlsZU5hbWVzLmluY2x1ZGVzKGN1cnJlbnREcmFnZ2VkRmlsZSEpKTtcblxuICBpZiAoY3VycmVudEdyb3VwPy5pZCA9PT0gdGFyZ2V0R3JvdXBJZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHpvbmUuY2xhc3NMaXN0LmFkZCgnZHJvcC16b25lLWFjdGl2ZScpO1xuXG4gIGlmIChldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdtb3ZlJztcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBkcmFnIGxlYXZlIGV2ZW50IChoaWRlIGRyb3Agem9uZSlcbiAqL1xuZnVuY3Rpb24gaGFuZGxlRHJhZ0xlYXZlKGV2ZW50OiBEcmFnRXZlbnQpOiB2b2lkIHtcbiAgY29uc3Qgem9uZSA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gIHpvbmUuY2xhc3NMaXN0LnJlbW92ZSgnZHJvcC16b25lLWFjdGl2ZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBkcm9wIGV2ZW50IChtb3ZlIGZpbGUgdG8gZ3JvdXApXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZURyb3AoZXZlbnQ6IERyYWdFdmVudCk6IHZvaWQge1xuICBjb25zb2xlLmxvZygnW0ZpbGVHcm91cGluZ10gaGFuZGxlRHJvcCBjYWxsZWQsIGV2ZW50OicsIGV2ZW50LCAnY3VycmVudERyYWdnZWRGaWxlOicsIGN1cnJlbnREcmFnZ2VkRmlsZSk7XG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICBjb25zdCB6b25lID0gZXZlbnQuY3VycmVudFRhcmdldCBhcyBIVE1MRWxlbWVudDtcbiAgY29uc3QgdGFyZ2V0R3JvdXBJZCA9IHpvbmUuZGF0YXNldC5ncm91cElkO1xuXG4gIHpvbmUuY2xhc3NMaXN0LnJlbW92ZSgnZHJvcC16b25lLWFjdGl2ZScpO1xuXG4gIC8vIEdVQVJEOiBPbmx5IHByb2NlZWQgaWYgd2UgYWN0dWFsbHkgaGF2ZSBhIGZpbGUgYmVpbmcgZHJhZ2dlZFxuICBpZiAoIXRhcmdldEdyb3VwSWQgfHwgIWN1cnJlbnREcmFnZ2VkRmlsZSkge1xuICAgIGNvbnNvbGUud2FybignW0ZpbGVHcm91cGluZ10gaGFuZGxlRHJvcCBjYWxsZWQgYnV0IG5vIGZpbGUgaXMgYmVpbmcgZHJhZ2dlZCAtIElHTk9SSU5HJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBsZXQgdXBkYXRlZEdyb3VwcyA9IG1vdmVGaWxlVG9Hcm91cChzdGF0ZS5maWxlR3JvdXBzIHx8IFtdLCBjdXJyZW50RHJhZ2dlZEZpbGUsIHRhcmdldEdyb3VwSWQpO1xuXG4gIC8vIFJlbW92ZSBlbXB0eSBncm91cHNcbiAgdXBkYXRlZEdyb3VwcyA9IHJlbW92ZUVtcHR5R3JvdXBzKHVwZGF0ZWRHcm91cHMpO1xuXG4gIHNldEZpbGVHcm91cHModXBkYXRlZEdyb3Vwcyk7XG5cbiAgLy8gUmUtcmVuZGVyXG4gIHJlbmRlckZpbGVHcm91cGluZygpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBjcmVhdGUgbmV3IGdyb3VwIGJ1dHRvbiBjbGlja1xuICovXG5mdW5jdGlvbiBoYW5kbGVDcmVhdGVOZXdHcm91cCgpOiB2b2lkIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBjb25zdCBuZXdHcm91cCA9IGNyZWF0ZU5ld0dyb3VwKCk7XG4gIGNvbnN0IHVwZGF0ZWRHcm91cHMgPSBbLi4uKHN0YXRlLmZpbGVHcm91cHMgfHwgW10pLCBuZXdHcm91cF07XG5cbiAgc2V0RmlsZUdyb3Vwcyh1cGRhdGVkR3JvdXBzKTtcbiAgcmVuZGVyRmlsZUdyb3VwaW5nKCk7XG59XG5cbi8qKlxuICogQW5hbHl6ZSBhbGwgZmlsZXMgdG8gZ2V0IGZpcnN0LWxldmVsIGtleXMgKGZvciBzaW5nbGUtZmlsZSBtb2RlIG9wdGlvbnMpXG4gKi9cbmZ1bmN0aW9uIGFuYWx5emVBbGxGaWxlc0ZpcnN0TGV2ZWwoKTogdm9pZCB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgXG4gIHN0YXRlLmZpbGVzLmZvckVhY2goKGZpbGVJbmZvLCBmaWxlTmFtZSkgPT4ge1xuICAgIGlmIChhbmFseXplZEZpcnN0TGV2ZWxLZXlzLmhhcyhmaWxlTmFtZSkpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YSA9IGZpbGVJbmZvLmNvbnRlbnQ7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnICYmIGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJyQnKSk7XG4gICAgICAgIGFuYWx5emVkRmlyc3RMZXZlbEtleXMuc2V0KGZpbGVOYW1lLCBrZXlzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbRmlsZUdyb3VwaW5nXSBGYWlsZWQgdG8gYW5hbHl6ZScsIGZpbGVOYW1lLCBlKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gUmUtcmVuZGVyIHRvIHNob3cgYW5hbHl6ZWQga2V5c1xuICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3JvdXBzQ29udGFpbmVyJyk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICBjb25zdCBncm91cHMgPSBzdGF0ZS5maWxlR3JvdXBzIHx8IFtdO1xuICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBncm91cHMubWFwKChncm91cCkgPT4gcmVuZGVyR3JvdXBDYXJkKGdyb3VwKSkuam9pbignJyk7XG4gICAgYXR0YWNoR3JvdXBpbmdFdmVudExpc3RlbmVycygpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGltcG9ydCBhbGwgY29sbGVjdGlvbnMgYnV0dG9uIGNsaWNrXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUltcG9ydEFsbChldmVudD86IEV2ZW50KTogdm9pZCB7XG4gIGNvbnN0IHRpbWVTaW5jZVJlbmRlciA9IERhdGUubm93KCkgLSB1aVJlYWR5VGltZXN0YW1wO1xuICBjb25zb2xlLmxvZygnW0ZpbGVHcm91cGluZ10gaGFuZGxlSW1wb3J0QWxsIGNhbGxlZCwgZXZlbnQ6JywgZXZlbnQsICd0aW1lU2luY2VSZW5kZXI6JywgdGltZVNpbmNlUmVuZGVyICsgJ21zJyk7XG5cbiAgLy8gR1VBUkQ6IEJsb2NrIGV2ZW50cyBpbiBmaXJzdCA1MDBtcyB0byBwcmV2ZW50IGF1dG8tdHJpZ2dlcnNcbiAgaWYgKHRpbWVTaW5jZVJlbmRlciA8IDUwMCkge1xuICAgIGNvbnNvbGUud2FybignW0ZpbGVHcm91cGluZ10gaGFuZGxlSW1wb3J0QWxsIGNhbGxlZCB0b28gc29vbiBhZnRlciByZW5kZXIgKCcsIHRpbWVTaW5jZVJlbmRlciwgJ21zKSAtIEJMT0NLSU5HIEFVVE8tVFJJR0dFUiEnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBHVUFSRDogT25seSBwcm9jZWVkIGlmIHRoaXMgd2FzIHRyaWdnZXJlZCBieSBhbiBhY3R1YWwgdXNlciBjbGljayBldmVudFxuICBpZiAoIWV2ZW50IHx8ICEoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSkge1xuICAgIGNvbnNvbGUud2FybignW0ZpbGVHcm91cGluZ10gaGFuZGxlSW1wb3J0QWxsIGNhbGxlZCB3aXRob3V0IHVzZXIgY2xpY2sgLSBJR05PUklORyEnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IGdyb3VwcyA9IHN0YXRlLmZpbGVHcm91cHMgfHwgW107XG5cbiAgLy8gQnVpbGQgbGV2ZWwgY29uZmlndXJhdGlvbnMgZm9yIGVhY2ggZ3JvdXBcbiAgLy8gRm9yIHNpbmdsZS1maWxlIHdpdGggXCJwZXItZmlsZVwiIChmaXJzdCBsZXZlbCA9IG1vZGVzKSwgbWFyayBsZXZlbCAxIGFzIG1vZGVcbiAgLy8gT3RoZXJ3aXNlLCBhbGwgbGV2ZWxzIGFyZSB0b2tlbi1wYXRoIHdpdGggZGVmYXVsdCBtb2RlXG4gIGNvbnN0IGxldmVsc0J5R3JvdXA6IFJlY29yZDxzdHJpbmcsIHsgZGVwdGg6IG51bWJlcjsgcm9sZTogJ2NvbGxlY3Rpb24nIHwgJ21vZGUnIHwgJ3Rva2VuLXBhdGgnIH1bXT4gPSB7fTtcbiAgXG4gIGdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICBjb25zdCBpc1NpbmdsZUZpbGUgPSBncm91cC5maWxlTmFtZXMubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IGZpcnN0TGV2ZWxLZXlzID0gaXNTaW5nbGVGaWxlID8gKGFuYWx5emVkRmlyc3RMZXZlbEtleXMuZ2V0KGdyb3VwLmZpbGVOYW1lc1swXSkgfHwgW10pIDogW107XG4gICAgXG4gICAgaWYgKGlzU2luZ2xlRmlsZSAmJiBncm91cC5tb2RlU3RyYXRlZ3kgPT09ICdwZXItZmlsZScgJiYgZmlyc3RMZXZlbEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gU2luZ2xlIGZpbGUgd2l0aCBmaXJzdCBsZXZlbCBhcyBtb2Rlc1xuICAgICAgbGV2ZWxzQnlHcm91cFtncm91cC5pZF0gPSBbXG4gICAgICAgIHsgZGVwdGg6IDEsIHJvbGU6ICdtb2RlJyB9LFxuICAgICAgICB7IGRlcHRoOiAyLCByb2xlOiAndG9rZW4tcGF0aCcgfVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVmYXVsdDogYWxsIHRva2VuLXBhdGggKGRlZmF1bHQgbW9kZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkpXG4gICAgICBsZXZlbHNCeUdyb3VwW2dyb3VwLmlkXSA9IFtcbiAgICAgICAgeyBkZXB0aDogMSwgcm9sZTogJ3Rva2VuLXBhdGgnIH1cbiAgICAgIF07XG4gICAgfVxuICB9KTtcblxuICAvLyBDb2xsZWN0IGZpbGUgZGF0YVxuICBjb25zdCBmaWxlc0RhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gIGdyb3Vwcy5mb3JFYWNoKGdyb3VwID0+IHtcbiAgICBncm91cC5maWxlTmFtZXMuZm9yRWFjaChmaWxlTmFtZSA9PiB7XG4gICAgICBjb25zdCBmaWxlSW5mbyA9IHN0YXRlLmZpbGVzLmdldChmaWxlTmFtZSk7XG4gICAgICBpZiAoZmlsZUluZm8pIHtcbiAgICAgICAgZmlsZXNEYXRhW2ZpbGVOYW1lXSA9IGZpbGVJbmZvLmNvbnRlbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGNvbnNvbGUubG9nKCdbRmlsZUdyb3VwaW5nXSBTZW5kaW5nIGltcG9ydCB3aXRoJywgT2JqZWN0LmtleXMoZmlsZXNEYXRhKS5sZW5ndGgsICdmaWxlcycpO1xuICBjb25zb2xlLmxvZygnW0ZpbGVHcm91cGluZ10gR3JvdXBzOicsIGdyb3Vwcy5tYXAoZyA9PiAoe1xuICAgIG5hbWU6IGcuY29sbGVjdGlvbk5hbWUsXG4gICAgc3RyYXRlZ3k6IGcubW9kZVN0cmF0ZWd5LFxuICAgIGZpbGVzOiBnLmZpbGVOYW1lcy5sZW5ndGhcbiAgfSkpKTtcblxuICAvLyBTZW5kIGltcG9ydCByZXF1ZXN0IGRpcmVjdGx5XG4gIHNlbmRNZXNzYWdlKHtcbiAgICB0eXBlOiAnaW1wb3J0LXdpdGgtbWFudWFsLWNvbmZpZycsXG4gICAgY29uZmlnOiB7XG4gICAgICBtdWx0aUZpbGU6IHtcbiAgICAgICAgZ3JvdXBzLFxuICAgICAgICBsZXZlbHNCeUdyb3VwLFxuICAgICAgICBmaWxlc0RhdGFcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEZvcm1hdCBmaWxlIHNpemUgZm9yIGRpc3BsYXlcbiAqL1xuZnVuY3Rpb24gZm9ybWF0RmlsZVNpemUoYnl0ZXM6IG51bWJlcik6IHN0cmluZyB7XG4gIGlmIChieXRlcyA8IDEwMjQpIHJldHVybiBgJHtieXRlc30gQmA7XG4gIGlmIChieXRlcyA8IDEwMjQgKiAxMDI0KSByZXR1cm4gYCR7KGJ5dGVzIC8gMTAyNCkudG9GaXhlZCgxKX0gS0JgO1xuICByZXR1cm4gYCR7KGJ5dGVzIC8gKDEwMjQgKiAxMDI0KSkudG9GaXhlZCgxKX0gTUJgO1xufVxuXG4vKipcbiAqIEVzY2FwZSBIVE1MIHRvIHByZXZlbnQgWFNTXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MO1xufVxuIiwgIi8qKlxuICogTGl2ZSBQcmV2aWV3IENvbXBvbmVudFxuICpcbiAqIERpc3BsYXlzIGEgdHJlZSB2aWV3IG9mIHRoZSBGaWdtYSBzdHJ1Y3R1cmUgdGhhdCB3aWxsIGJlIGNyZWF0ZWRcbiAqIGZyb20gdGhlIGltcG9ydGVkIHRva2Vucy4gVXBkYXRlcyBsaXZlIHdoZW4gdGhlIHVzZXIgY2hhbmdlc1xuICogdGhlIGxldmVsIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogU2hvd3M6XG4gKiAtIENvbGxlY3Rpb25zIHdpdGggaWNvblxuICogLSBNb2RlcyB3aXRoaW4gZWFjaCBjb2xsZWN0aW9uIHdpdGggaWNvblxuICogLSBWYXJpYWJsZSBjb3VudHMgYW5kIHNhbXBsZXNcbiAqIC0gU3VtbWFyeSBjb3VudHMgKHRvdGFsIGNvbGxlY3Rpb25zLCBtb2RlcywgdmFyaWFibGVzKVxuICogLSBXYXJuaW5ncyBmb3IgZGVmYXVsdCBtb2Rlc1xuICovXG5cbmltcG9ydCB0eXBlIHsgUHJldmlld1N0cnVjdHVyZSwgUHJldmlld0NvbGxlY3Rpb24sIFByZXZpZXdNb2RlIH0gZnJvbSAnLi4vLi4vdHlwZXMvbWVzc2FnZS50eXBlcy5qcyc7XG5cbi8qKlxuICogQ29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSBwcmV2aWV3XG4gKi9cbmxldCBwcmV2aWV3Q29udGFpbmVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xuXG4vKipcbiAqIFJlbmRlciB0aGUgbGl2ZSBwcmV2aWV3IG9mIHRoZSBpbXBvcnQgc3RydWN0dXJlXG4gKlxuICogQ3JlYXRlcyBhbiBleHBhbmRhYmxlIHRyZWUgdmlldyBzaG93aW5nIHdoYXQgd2lsbCBiZSBjcmVhdGVkIGluIEZpZ21hLlxuICogRWFjaCBjb2xsZWN0aW9uIGFuZCBtb2RlIGNhbiBiZSBleHBhbmRlZC9jb2xsYXBzZWQgdG8gdmlldyBkZXRhaWxzLlxuICpcbiAqIEBwYXJhbSBwcmV2aWV3IC0gUHJldmlldyBzdHJ1Y3R1cmUgdG8gcmVuZGVyXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiByZW5kZXJMaXZlUHJldmlldyh7XG4gKiAgIGNvbGxlY3Rpb25zOiBbXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ3NlbWFudGljJyxcbiAqICAgICAgIG1vZGVzOiBbXG4gKiAgICAgICAgIHsgbmFtZTogJ2xpZ2h0JywgdmFyaWFibGVDb3VudDogOCwgc2FtcGxlVmFyaWFibGVzOiBbJ2JnL3ByaW1hcnknLCAnYmcvc2Vjb25kYXJ5J10gfSxcbiAqICAgICAgICAgeyBuYW1lOiAnZGFyaycsIHZhcmlhYmxlQ291bnQ6IDgsIHNhbXBsZVZhcmlhYmxlczogWydiZy9wcmltYXJ5JywgJ2JnL3NlY29uZGFyeSddIH1cbiAqICAgICAgIF1cbiAqICAgICB9XG4gKiAgIF0sXG4gKiAgIHRvdGFsQ29sbGVjdGlvbnM6IDEsXG4gKiAgIHRvdGFsTW9kZXM6IDIsXG4gKiAgIHRvdGFsVmFyaWFibGVzOiAxNlxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckxpdmVQcmV2aWV3KHByZXZpZXc6IFByZXZpZXdTdHJ1Y3R1cmUpOiB2b2lkIHtcbiAgLy8gR2V0IG9yIGNyZWF0ZSBwcmV2aWV3IGNvbnRhaW5lclxuICBpZiAoIXByZXZpZXdDb250YWluZXIpIHtcbiAgICBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpdmUtcHJldmlldycpO1xuICAgIGlmICghcHJldmlld0NvbnRhaW5lcikge1xuICAgICAgY29uc29sZS5lcnJvcignUHJldmlldyBjb250YWluZXIgZWxlbWVudCBub3QgZm91bmQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhciBwcmV2aW91cyBjb250ZW50XG4gIHByZXZpZXdDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG5cbiAgLy8gU2hvdyBjb250YWluZXJcbiAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAvLyBDcmVhdGUgaGVhZGVyXG4gIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBoZWFkZXIuY2xhc3NOYW1lID0gJ3ByZXZpZXctaGVhZGVyJztcbiAgaGVhZGVyLmlubmVySFRNTCA9IGBcbiAgICA8aDM+UHJldmlldzwvaDM+XG4gICAgPHAgY2xhc3M9XCJwcmV2aWV3LWRlc2NyaXB0aW9uXCI+QmFzZWQgb24geW91ciBzZWxlY3Rpb25zIGFib3ZlOjwvcD5cbiAgYDtcbiAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChoZWFkZXIpO1xuXG4gIC8vIENyZWF0ZSB0cmVlIGNvbnRhaW5lclxuICBjb25zdCB0cmVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRyZWUuY2xhc3NOYW1lID0gJ3ByZXZpZXctdHJlZSc7XG5cbiAgLy8gUmVuZGVyIGVhY2ggY29sbGVjdGlvblxuICBmb3IgKGNvbnN0IGNvbGxlY3Rpb24gb2YgcHJldmlldy5jb2xsZWN0aW9ucykge1xuICAgIGNvbnN0IGNvbGxlY3Rpb25FbCA9IHJlbmRlckNvbGxlY3Rpb24oY29sbGVjdGlvbik7XG4gICAgdHJlZS5hcHBlbmRDaGlsZChjb2xsZWN0aW9uRWwpO1xuICB9XG5cbiAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0cmVlKTtcblxuICAvLyBDcmVhdGUgc3VtbWFyeVxuICBjb25zdCBzdW1tYXJ5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHN1bW1hcnkuY2xhc3NOYW1lID0gJ3ByZXZpZXctc3VtbWFyeSc7XG4gIHN1bW1hcnkuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJzdW1tYXJ5LWxpbmVcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic3VtbWFyeS1jb3VudHNcIj5cbiAgICAgIDxzcGFuPlRvdGFsOiAke3ByZXZpZXcudG90YWxDb2xsZWN0aW9uc30gY29sbGVjdGlvbiR7cHJldmlldy50b3RhbENvbGxlY3Rpb25zICE9PSAxID8gJ3MnIDogJyd9LCAke3ByZXZpZXcudG90YWxNb2Rlc30gbW9kZSR7cHJldmlldy50b3RhbE1vZGVzICE9PSAxID8gJ3MnIDogJyd9LCAke3ByZXZpZXcudG90YWxWYXJpYWJsZXN9IHZhcmlhYmxlJHtwcmV2aWV3LnRvdGFsVmFyaWFibGVzICE9PSAxID8gJ3MnIDogJyd9PC9zcGFuPlxuICAgIDwvZGl2PlxuICBgO1xuICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHN1bW1hcnkpO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIHNpbmdsZSBjb2xsZWN0aW9uIGluIHRoZSB0cmVlXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbGxlY3Rpb24oY29sbGVjdGlvbjogUHJldmlld0NvbGxlY3Rpb24pOiBIVE1MRWxlbWVudCB7XG4gIGNvbnN0IGNvbGxlY3Rpb25FbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb2xsZWN0aW9uRWwuY2xhc3NOYW1lID0gJ3ByZXZpZXctY29sbGVjdGlvbic7XG5cbiAgLy8gQ29sbGVjdGlvbiBoZWFkZXIgKGV4cGFuZGFibGUpXG4gIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBoZWFkZXIuY2xhc3NOYW1lID0gJ2NvbGxlY3Rpb24taGVhZGVyJztcbiAgaGVhZGVyLmlubmVySFRNTCA9IGBcbiAgICA8c3BhbiBjbGFzcz1cImV4cGFuZC1pY29uXCI+XHUyNUJDPC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiY29sbGVjdGlvbi1pY29uXCI+XHVEODNEXHVEQ0U2PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiY29sbGVjdGlvbi1uYW1lXCI+JHtlc2NhcGVIdG1sKGNvbGxlY3Rpb24ubmFtZSl9PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwiY29sbGVjdGlvbi1jb3VudFwiPihDb2xsZWN0aW9uKTwvc3Bhbj5cbiAgYDtcblxuICAvLyBNb2RlcyBjb250YWluZXJcbiAgY29uc3QgbW9kZXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgbW9kZXNDb250YWluZXIuY2xhc3NOYW1lID0gJ21vZGVzLWNvbnRhaW5lcic7XG5cbiAgLy8gUmVuZGVyIGVhY2ggbW9kZVxuICBmb3IgKGNvbnN0IG1vZGUgb2YgY29sbGVjdGlvbi5tb2Rlcykge1xuICAgIGNvbnN0IG1vZGVFbCA9IHJlbmRlck1vZGUobW9kZSk7XG4gICAgbW9kZXNDb250YWluZXIuYXBwZW5kQ2hpbGQobW9kZUVsKTtcbiAgfVxuXG4gIC8vIFRvZ2dsZSBleHBhbmQvY29sbGFwc2VcbiAgbGV0IGlzRXhwYW5kZWQgPSB0cnVlO1xuICBoZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgaXNFeHBhbmRlZCA9ICFpc0V4cGFuZGVkO1xuICAgIG1vZGVzQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBpc0V4cGFuZGVkID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICBjb25zdCBpY29uID0gaGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJy5leHBhbmQtaWNvbicpO1xuICAgIGlmIChpY29uKSB7XG4gICAgICBpY29uLnRleHRDb250ZW50ID0gaXNFeHBhbmRlZCA/ICdcdTI1QkMnIDogJ1x1MjVCNic7XG4gICAgfVxuICB9KTtcblxuICBjb2xsZWN0aW9uRWwuYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgY29sbGVjdGlvbkVsLmFwcGVuZENoaWxkKG1vZGVzQ29udGFpbmVyKTtcblxuICByZXR1cm4gY29sbGVjdGlvbkVsO1xufVxuXG4vKipcbiAqIFJlbmRlciBhIHNpbmdsZSBtb2RlIGluIHRoZSB0cmVlXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck1vZGUobW9kZTogUHJldmlld01vZGUpOiBIVE1MRWxlbWVudCB7XG4gIGNvbnN0IG1vZGVFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBtb2RlRWwuY2xhc3NOYW1lID0gJ3ByZXZpZXctbW9kZSc7XG5cbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIGRlZmF1bHQgbW9kZSAoY3JlYXRlZCBhdXRvbWF0aWNhbGx5KVxuICBjb25zdCBpc0RlZmF1bHRNb2RlID0gbW9kZS5uYW1lID09PSAnTW9kZSAxJztcblxuICAvLyBNb2RlIGhlYWRlclxuICBjb25zdCBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaGVhZGVyLmNsYXNzTmFtZSA9ICdtb2RlLWhlYWRlcic7XG5cbiAgLy8gQ2hvb3NlIGljb24gYmFzZWQgb24gbW9kZSBuYW1lXG4gIGxldCBtb2RlSWNvbiA9ICdcdUQ4M0NcdURGQTgnOyAvLyBEZWZhdWx0XG4gIGlmIChtb2RlLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnbW9iaWxlJykpIHtcbiAgICBtb2RlSWNvbiA9ICdcdUQ4M0RcdURDRjEnO1xuICB9IGVsc2UgaWYgKG1vZGUubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdkZXNrdG9wJykgfHwgbW9kZS5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3dlYicpKSB7XG4gICAgbW9kZUljb24gPSAnXHVEODNEXHVEREE1JztcbiAgfSBlbHNlIGlmIChpc0RlZmF1bHRNb2RlKSB7XG4gICAgbW9kZUljb24gPSAnXHUyNjk5XHVGRTBGJztcbiAgfVxuXG4gIGhlYWRlci5pbm5lckhUTUwgPSBgXG4gICAgPHNwYW4gY2xhc3M9XCJtb2RlLWluZGVudFwiPlx1MjUxQ1x1MjUwMDwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cIm1vZGUtaWNvblwiPiR7bW9kZUljb259PC9zcGFuPlxuICAgIDxzcGFuIGNsYXNzPVwibW9kZS1uYW1lXCI+JHtlc2NhcGVIdG1sKG1vZGUubmFtZSl9PC9zcGFuPlxuICAgICR7aXNEZWZhdWx0TW9kZSA/ICc8c3BhbiBjbGFzcz1cImRlZmF1bHQtYmFkZ2VcIj5kZWZhdWx0IG1vZGU8L3NwYW4+JyA6ICcnfVxuICBgO1xuXG4gIG1vZGVFbC5hcHBlbmRDaGlsZChoZWFkZXIpO1xuXG4gIC8vIFZhcmlhYmxlcyBzZWN0aW9uXG4gIGNvbnN0IHZhcnNFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXJzRWwuY2xhc3NOYW1lID0gJ21vZGUtdmFyaWFibGVzJztcblxuICBpZiAobW9kZS5zYW1wbGVWYXJpYWJsZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHNhbXBsZXNUZXh0ID0gbW9kZS5zYW1wbGVWYXJpYWJsZXMubWFwKCh2OiBzdHJpbmcpID0+IGVzY2FwZUh0bWwodikpLmpvaW4oJywgJyk7XG4gICAgY29uc3QgaGFzTW9yZSA9IG1vZGUudmFyaWFibGVDb3VudCA+IG1vZGUuc2FtcGxlVmFyaWFibGVzLmxlbmd0aDtcbiAgICBjb25zdCBtb3JlVGV4dCA9IGhhc01vcmUgPyAnLi4uJyA6ICcnO1xuXG4gICAgdmFyc0VsLmlubmVySFRNTCA9IGBcbiAgICAgIDxzcGFuIGNsYXNzPVwidmFyLWluZGVudFwiPlx1MjUwMiAgIFx1MjUxNFx1MjUwMDwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwidmFyLXNhbXBsZXNcIj4ke3NhbXBsZXNUZXh0fSR7bW9yZVRleHR9PC9zcGFuPlxuICAgICAgPGRpdiBjbGFzcz1cInZhci1jb3VudFwiPiR7bW9kZS52YXJpYWJsZUNvdW50fSB2YXJpYWJsZSR7bW9kZS52YXJpYWJsZUNvdW50ICE9PSAxID8gJ3MnIDogJyd9PC9kaXY+XG4gICAgYDtcbiAgfSBlbHNlIHtcbiAgICB2YXJzRWwuaW5uZXJIVE1MID0gYFxuICAgICAgPHNwYW4gY2xhc3M9XCJ2YXItaW5kZW50XCI+XHUyNTAyICAgXHUyNTE0XHUyNTAwPC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJ2YXItY291bnRcIj4ke21vZGUudmFyaWFibGVDb3VudH0gdmFyaWFibGUke21vZGUudmFyaWFibGVDb3VudCAhPT0gMSA/ICdzJyA6ICcnfTwvc3Bhbj5cbiAgICBgO1xuICB9XG5cbiAgbW9kZUVsLmFwcGVuZENoaWxkKHZhcnNFbCk7XG5cbiAgcmV0dXJuIG1vZGVFbDtcbn1cblxuLyoqXG4gKiBIaWRlIHRoZSBsaXZlIHByZXZpZXdcbiAqXG4gKiBDYWxsZWQgd2hlbiB0aGVyZSdzIG5vIHZhbGlkIGNvbmZpZ3VyYXRpb24gdG8gcHJldmlldy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhpZGVMaXZlUHJldmlldygpOiB2b2lkIHtcbiAgaWYgKHByZXZpZXdDb250YWluZXIpIHtcbiAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcHJldmlld0NvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBIVE1MIHRvIHByZXZlbnQgWFNTXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUh0bWwodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MO1xufVxuIiwgIi8qKlxuICogTXVsdGktQ29sbGVjdGlvbiBMZXZlbCBDb25maWd1cmF0aW9uIENvbXBvbmVudFxuICogU2hvd3Mgb25lIGxldmVsIHNlbGVjdG9yIGNhcmQgcGVyIGNvbGxlY3Rpb24gZm9yIG11bHRpLWZpbGUgaW1wb3J0c1xuICovXG5cbmltcG9ydCB7IGdldFN0YXRlLCBzZXRTdGF0ZSB9IGZyb20gJy4uL3N0YXRlLmpzJztcbmltcG9ydCB7IHNlbmRNZXNzYWdlIH0gZnJvbSAnLi4vbWVzc2FnZS1icmlkZ2UuanMnO1xuaW1wb3J0IHsgcmVuZGVyTGV2ZWxTZWxlY3RvciB9IGZyb20gJy4vbGV2ZWwtc2VsZWN0b3IuanMnO1xuaW1wb3J0IHR5cGUgeyBGaWxlR3JvdXAsIExldmVsQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uLy4uL3R5cGVzL2xldmVsLWNvbmZpZy50eXBlcy5qcyc7XG5cbmludGVyZmFjZSBDb2xsZWN0aW9uQW5hbHlzaXNTdGF0ZSB7XG4gIGdyb3VwSWQ6IHN0cmluZztcbiAgY29sbGVjdGlvbk5hbWU6IHN0cmluZztcbiAgYW5hbHl6ZWQ6IGJvb2xlYW47XG4gIGxldmVscz86IExldmVsQ29uZmlndXJhdGlvbltdO1xuICBtb2RlU3RyYXRlZ3k6ICdwZXItZmlsZScgfCAnbWVyZ2VkJztcbiAgbW9kZU5hbWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+OyAvLyBmaWxlTmFtZSAtPiBtb2RlTmFtZVxufVxuXG5sZXQgYW5hbHlzaXNTdGF0ZXM6IE1hcDxzdHJpbmcsIENvbGxlY3Rpb25BbmFseXNpc1N0YXRlPiA9IG5ldyBNYXAoKTtcbmxldCBjdXJyZW50QW5hbHl6aW5nSW5kZXggPSAwO1xuXG4vKipcbiAqIEV4dHJhY3QgbW9kZSBuYW1lIGZyb20gZmlsZW5hbWUgKFVJLXNpZGUgdmVyc2lvbilcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdE1vZGVOYW1lRnJvbUZpbGVuYW1lKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBuYW1lV2l0aG91dEV4dCA9IGZpbGVuYW1lLnJlcGxhY2UoL1xcLmpzb24kL2ksICcnKTtcbiAgXG4gIGlmIChuYW1lV2l0aG91dEV4dC5pbmNsdWRlcygnLScpKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lV2l0aG91dEV4dC5zcGxpdCgnLScpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGlmIChuYW1lV2l0aG91dEV4dC5pbmNsdWRlcygnLicpKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lV2l0aG91dEV4dC5zcGxpdCgnLicpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGlmIChuYW1lV2l0aG91dEV4dC5pbmNsdWRlcygnXycpKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lV2l0aG91dEV4dC5zcGxpdCgnXycpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggPj0gMikgcmV0dXJuIHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBuYW1lV2l0aG91dEV4dDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIGFuZCByZW5kZXIgbXVsdGktY29sbGVjdGlvbiBjb25maWd1cmF0aW9uIFVJXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJNdWx0aUNvbGxlY3Rpb25Db25maWcoKTogdm9pZCB7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtdWx0aUNvbGxlY3Rpb25Db25maWdTZWN0aW9uJyk7XG4gIGlmICghY29udGFpbmVyKSB7XG4gICAgY29uc29sZS5lcnJvcignW011bHRpQ29sbGVjdGlvbkNvbmZpZ10gQ29udGFpbmVyIG5vdCBmb3VuZCcpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgY29uc3QgZ3JvdXBzID0gc3RhdGUuZmlsZUdyb3VwcyB8fCBbXTtcblxuICBpZiAoZ3JvdXBzLmxlbmd0aCA9PT0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tNdWx0aUNvbGxlY3Rpb25Db25maWddIE5vIGZpbGUgZ3JvdXBzIGZvdW5kJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ1tNdWx0aUNvbGxlY3Rpb25Db25maWddIFJlbmRlcmluZyBjb25maWcgZm9yJywgZ3JvdXBzLmxlbmd0aCwgJ2NvbGxlY3Rpb25zJyk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBhbmFseXNpcyBzdGF0ZXMgd2l0aCBtb2RlIG5hbWVzIGV4dHJhY3RlZCBmcm9tIGZpbGVuYW1lc1xuICBhbmFseXNpc1N0YXRlcy5jbGVhcigpO1xuICBncm91cHMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgY29uc3QgbW9kZU5hbWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgZ3JvdXAuZmlsZU5hbWVzLmZvckVhY2goZmlsZU5hbWUgPT4ge1xuICAgICAgbW9kZU5hbWVzW2ZpbGVOYW1lXSA9IGV4dHJhY3RNb2RlTmFtZUZyb21GaWxlbmFtZShmaWxlTmFtZSk7XG4gICAgfSk7XG4gICAgXG4gICAgYW5hbHlzaXNTdGF0ZXMuc2V0KGdyb3VwLmlkLCB7XG4gICAgICBncm91cElkOiBncm91cC5pZCxcbiAgICAgIGNvbGxlY3Rpb25OYW1lOiBncm91cC5jb2xsZWN0aW9uTmFtZSxcbiAgICAgIGFuYWx5emVkOiBmYWxzZSxcbiAgICAgIG1vZGVTdHJhdGVneTogZ3JvdXAuZmlsZU5hbWVzLmxlbmd0aCA+IDEgPyAncGVyLWZpbGUnIDogJ21lcmdlZCcsXG4gICAgICBtb2RlTmFtZXNcbiAgICB9KTtcbiAgfSk7XG5cbiAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICByZW5kZXJVSShjb250YWluZXIsIGdyb3Vwcyk7XG5cbiAgLy8gU3RhcnQgYW5hbHl6aW5nIGZpcnN0IGNvbGxlY3Rpb25cbiAgY3VycmVudEFuYWx5emluZ0luZGV4ID0gMDtcbiAgYW5hbHl6ZU5leHRDb2xsZWN0aW9uKCk7XG59XG5cbi8qKlxuICogUmVuZGVyIHRoZSBtdWx0aS1jb2xsZWN0aW9uIGNvbmZpZ3VyYXRpb24gVUlcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVUkoY29udGFpbmVyOiBIVE1MRWxlbWVudCwgZ3JvdXBzOiBGaWxlR3JvdXBbXSk6IHZvaWQge1xuICBjb250YWluZXIuaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJtdWx0aS1jb2xsZWN0aW9uLWNvbmZpZ1wiPlxuICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tdGl0bGVcIj4zLiBDb25maWd1cmUgRWFjaCBDb2xsZWN0aW9uPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1kZXNjcmlwdGlvblwiPlxuICAgICAgICBEZWZpbmUgaG93IEpTT04gbGV2ZWxzIG1hcCB0byBGaWdtYSBjb2xsZWN0aW9ucyBhbmQgbW9kZXMgZm9yIGVhY2ggY29sbGVjdGlvbi5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGlkPVwiY29sbGVjdGlvbkNhcmRzXCI+XG4gICAgICAgICR7Z3JvdXBzLm1hcChncm91cCA9PiByZW5kZXJDb2xsZWN0aW9uQ2FyZChncm91cCkpLmpvaW4oJycpfVxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJjb2xsZWN0aW9uLWFjdGlvbnNcIj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBidXR0b24tcHJpbWFyeSBidXR0b24tZnVsbFwiIGlkPVwiaW1wb3J0QWxsQnRuXCIgZGlzYWJsZWQ+XG4gICAgICAgICAgSW1wb3J0IEFsbCBDb2xsZWN0aW9uc1xuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xuXG4gIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgY29uc3QgaW1wb3J0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ltcG9ydEFsbEJ0bicpO1xuICBpbXBvcnRCdG4/LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlSW1wb3J0QWxsKTtcbiAgXG4gIC8vIEF0dGFjaCBtb2RlIHN0cmF0ZWd5IGxpc3RlbmVyc1xuICBhdHRhY2hNb2RlU3RyYXRlZ3lMaXN0ZW5lcnMoKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgYSBzaW5nbGUgY29sbGVjdGlvbiBjYXJkXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbGxlY3Rpb25DYXJkKGdyb3VwOiBGaWxlR3JvdXApOiBzdHJpbmcge1xuICBjb25zdCBhbmFseXNpc1N0YXRlID0gYW5hbHlzaXNTdGF0ZXMuZ2V0KGdyb3VwLmlkKTtcbiAgY29uc3QgaGFzTXVsdGlwbGVGaWxlcyA9IGdyb3VwLmZpbGVOYW1lcy5sZW5ndGggPiAxO1xuICBjb25zdCBtb2RlU3RyYXRlZ3kgPSBhbmFseXNpc1N0YXRlPy5tb2RlU3RyYXRlZ3kgfHwgJ3Blci1maWxlJztcbiAgY29uc3QgZmlsZUNvdW50ID0gZ3JvdXAuZmlsZU5hbWVzLmxlbmd0aDtcblxuICAvLyBCdWlsZCBtb2RlIHN0cmF0ZWd5IHNlY3Rpb24gSFRNTCBmb3IgbXVsdGktZmlsZSBncm91cHNcbiAgbGV0IG1vZGVTdHJhdGVneVNlY3Rpb25IdG1sID0gJyc7XG4gIGlmIChoYXNNdWx0aXBsZUZpbGVzKSB7XG4gICAgY29uc3QgbW9kZU5hbWVzSHRtbCA9IG1vZGVTdHJhdGVneSA9PT0gJ3Blci1maWxlJyBcbiAgICAgID8gcmVuZGVyTW9kZU5hbWVzTGlzdChncm91cC5pZCwgZ3JvdXAuZmlsZU5hbWVzLCBhbmFseXNpc1N0YXRlPy5tb2RlTmFtZXMgfHwge30pXG4gICAgICA6ICcnO1xuICAgIFxuICAgIG1vZGVTdHJhdGVneVNlY3Rpb25IdG1sID0gYFxuICAgICAgPGRpdiBjbGFzcz1cIm1vZGUtc3RyYXRlZ3ktc2VjdGlvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZS1zdHJhdGVneS1sYWJlbFwiPkhvdyBzaG91bGQgdGhlc2UgJHtmaWxlQ291bnR9IGZpbGVzIGJlIGNvbWJpbmVkPzwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwibW9kZS1zdHJhdGVneS1vcHRpb25zXCI+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwibW9kZS1zdHJhdGVneS1vcHRpb24gJHttb2RlU3RyYXRlZ3kgPT09ICdwZXItZmlsZScgPyAnc2VsZWN0ZWQnIDogJyd9XCI+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cIm1vZGUtc3RyYXRlZ3ktJHtlc2NhcGVIdG1sKGdyb3VwLmlkKX1cIiBcbiAgICAgICAgICAgICAgICAgICB2YWx1ZT1cInBlci1maWxlXCIgJHttb2RlU3RyYXRlZ3kgPT09ICdwZXItZmlsZScgPyAnY2hlY2tlZCcgOiAnJ31cbiAgICAgICAgICAgICAgICAgICBkYXRhLWdyb3VwLWlkPVwiJHtlc2NhcGVIdG1sKGdyb3VwLmlkKX1cIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicmFkaW8taW5kaWNhdG9yXCI+PC9zcGFuPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdGlvbi1jb250ZW50XCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHRpb24tdGl0bGVcIj5FYWNoIGZpbGUgPSAxIG1vZGU8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdGlvbi1kZXNjcmlwdGlvblwiPkNyZWF0ZXMgJHtmaWxlQ291bnR9IG1vZGVzIGluIHRoaXMgY29sbGVjdGlvbjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJtb2RlLXN0cmF0ZWd5LW9wdGlvbiAke21vZGVTdHJhdGVneSA9PT0gJ21lcmdlZCcgPyAnc2VsZWN0ZWQnIDogJyd9XCI+XG4gICAgICAgICAgICA8aW5wdXQgdHlwZT1cInJhZGlvXCIgbmFtZT1cIm1vZGUtc3RyYXRlZ3ktJHtlc2NhcGVIdG1sKGdyb3VwLmlkKX1cIiBcbiAgICAgICAgICAgICAgICAgICB2YWx1ZT1cIm1lcmdlZFwiICR7bW9kZVN0cmF0ZWd5ID09PSAnbWVyZ2VkJyA/ICdjaGVja2VkJyA6ICcnfVxuICAgICAgICAgICAgICAgICAgIGRhdGEtZ3JvdXAtaWQ9XCIke2VzY2FwZUh0bWwoZ3JvdXAuaWQpfVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJyYWRpby1pbmRpY2F0b3JcIj48L3NwYW4+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3B0aW9uLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9wdGlvbi10aXRsZVwiPk1lcmdlIGludG8gMSBtb2RlPC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcHRpb24tZGVzY3JpcHRpb25cIj5BbGwgdG9rZW5zIGNvbWJpbmVkIGludG8gXCJNb2RlIDFcIjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9sYWJlbD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgICR7bW9kZU5hbWVzSHRtbH1cbiAgICAgIDwvZGl2PlxuICAgIGA7XG4gIH1cblxuICAvLyBCdWlsZCBzdHJ1Y3R1cmUgc2VjdGlvbiBIVE1MXG4gIC8vIEZvciBtdWx0aS1maWxlIGNvbGxlY3Rpb25zLCBzaG93IHNpbXBsaWZpZWQgc3RydWN0dXJlIChqdXN0IFRva2VuIFBhdGggc2luY2UgbW9kZSBjb21lcyBmcm9tIGZpbGVzKVxuICAvLyBGb3Igc2luZ2xlLWZpbGUgY29sbGVjdGlvbnMsIHNob3cgZnVsbCBsZXZlbCBzZWxlY3RvciB3aXRoIENvbGxlY3Rpb24vTW9kZS9Ub2tlbiBQYXRoIG9wdGlvbnNcbiAgY29uc3Qgc3RydWN0dXJlTGFiZWwgPSBoYXNNdWx0aXBsZUZpbGVzID8gJ1N0cnVjdHVyZSBpbnNpZGUgZWFjaCBmaWxlOicgOiAnVG9rZW4gc3RydWN0dXJlOic7XG4gIFxuICBsZXQgc3RydWN0dXJlQ29udGVudEh0bWwgPSAnJztcbiAgaWYgKCFhbmFseXNpc1N0YXRlPy5hbmFseXplZCkge1xuICAgIHN0cnVjdHVyZUNvbnRlbnRIdG1sID0gYDxkaXYgY2xhc3M9XCJhbmFseXppbmdcIj48c3BhbiBjbGFzcz1cInNwaW5uZXJcIj48L3NwYW4+IEFuYWx5emluZyBzdHJ1Y3R1cmUuLi48L2Rpdj5gO1xuICB9IGVsc2UgaWYgKGhhc011bHRpcGxlRmlsZXMgJiYgbW9kZVN0cmF0ZWd5ID09PSAncGVyLWZpbGUnKSB7XG4gICAgLy8gU2ltcGxpZmllZCB2aWV3IGZvciBtdWx0aS1maWxlOiBqdXN0IHNob3cgdG9rZW4gcGF0aCBzdHJ1Y3R1cmVcbiAgICBzdHJ1Y3R1cmVDb250ZW50SHRtbCA9IHJlbmRlclNpbXBsaWZpZWRTdHJ1Y3R1cmUoZ3JvdXAuaWQsIGFuYWx5c2lzU3RhdGUubGV2ZWxzIHx8IFtdKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGdWxsIGxldmVsIHNlbGVjdG9yIGZvciBzaW5nbGUtZmlsZSBvciBtZXJnZWQgbW9kZVxuICAgIHN0cnVjdHVyZUNvbnRlbnRIdG1sID0gYDxkaXYgaWQ9XCJsZXZlbC1zZWxlY3Rvci0ke2VzY2FwZUh0bWwoZ3JvdXAuaWQpfVwiPjwvZGl2PmA7XG4gIH1cbiAgXG4gIGNvbnN0IHN0cnVjdHVyZVNlY3Rpb25IdG1sID0gYFxuICAgIDxkaXYgY2xhc3M9XCJzdHJ1Y3R1cmUtc2VjdGlvblwiPlxuICAgICAgPGRpdiBjbGFzcz1cInN0cnVjdHVyZS1sYWJlbFwiPiR7c3RydWN0dXJlTGFiZWx9PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwic3RydWN0dXJlLWNvbnRlbnRcIj5cbiAgICAgICAgJHtzdHJ1Y3R1cmVDb250ZW50SHRtbH1cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgO1xuXG4gIC8vIEJ1aWxkIGZpbGUgbGlzdCBmb3IgaGVhZGVyXG4gIGNvbnN0IGZpbGVMaXN0U2hvcnQgPSBncm91cC5maWxlTmFtZXMubGVuZ3RoIDw9IDIgXG4gICAgPyBncm91cC5maWxlTmFtZXMubWFwKGYgPT4gYCR7Zn0uanNvbmApLmpvaW4oJywgJylcbiAgICA6IGAke2dyb3VwLmZpbGVOYW1lc1swXX0uanNvbiArICR7Z3JvdXAuZmlsZU5hbWVzLmxlbmd0aCAtIDF9IG1vcmVgO1xuXG4gIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cImNvbGxlY3Rpb24tY2FyZFwiIGlkPVwiY29sbGVjdGlvbi0ke2VzY2FwZUh0bWwoZ3JvdXAuaWQpfVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImNvbGxlY3Rpb24taGVhZGVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2xsZWN0aW9uLWljb25cIj5cdUQ4M0RcdURDRTY8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbGxlY3Rpb24taW5mb1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2xsZWN0aW9uLW5hbWVcIj4ke2VzY2FwZUh0bWwoZ3JvdXAuY29sbGVjdGlvbk5hbWUpfTwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb2xsZWN0aW9uLWZpbGVzXCI+JHtmaWxlQ291bnR9IGZpbGUke2ZpbGVDb3VudCA+IDEgPyAncycgOiAnJ306ICR7ZXNjYXBlSHRtbChmaWxlTGlzdFNob3J0KX08L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJjb2xsZWN0aW9uLWJhZGdlXCI+JHtoYXNNdWx0aXBsZUZpbGVzID8gYCR7ZmlsZUNvdW50fSBmaWxlc2AgOiAnMSBmaWxlJ308L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImNvbGxlY3Rpb24tYm9keVwiIGlkPVwiY29sbGVjdGlvbi1ib2R5LSR7ZXNjYXBlSHRtbChncm91cC5pZCl9XCI+XG4gICAgICAgICR7bW9kZVN0cmF0ZWd5U2VjdGlvbkh0bWx9XG4gICAgICAgICR7c3RydWN0dXJlU2VjdGlvbkh0bWx9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgYDtcbn1cblxuLyoqXG4gKiBSZW5kZXIgbW9kZSBuYW1lcyBsaXN0IGZvciBwZXItZmlsZSBzdHJhdGVneVxuICovXG5mdW5jdGlvbiByZW5kZXJNb2RlTmFtZXNMaXN0KGdyb3VwSWQ6IHN0cmluZywgZmlsZU5hbWVzOiBzdHJpbmdbXSwgbW9kZU5hbWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogc3RyaW5nIHtcbiAgcmV0dXJuIGBcbiAgICA8ZGl2IGNsYXNzPVwibW9kZS1uYW1lcy1saXN0XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibW9kZS1uYW1lcy1sYWJlbFwiPk1vZGUgbmFtZXMgKGVkaXRhYmxlKTo8L2Rpdj5cbiAgICAgICR7ZmlsZU5hbWVzLm1hcChmaWxlTmFtZSA9PiBgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJtb2RlLW5hbWUtcm93XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJtb2RlLW5hbWUtZmlsZVwiPiR7ZXNjYXBlSHRtbChmaWxlTmFtZSl9Lmpzb248L3NwYW4+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCJtb2RlLW5hbWUtYXJyb3dcIj5cdTIxOTI8L3NwYW4+XG4gICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJtb2RlLW5hbWUtaW5wdXRcIiBcbiAgICAgICAgICAgICAgICAgdmFsdWU9XCIke2VzY2FwZUh0bWwobW9kZU5hbWVzW2ZpbGVOYW1lXSB8fCBleHRyYWN0TW9kZU5hbWVGcm9tRmlsZW5hbWUoZmlsZU5hbWUpKX1cIlxuICAgICAgICAgICAgICAgICBkYXRhLWdyb3VwLWlkPVwiJHtlc2NhcGVIdG1sKGdyb3VwSWQpfVwiXG4gICAgICAgICAgICAgICAgIGRhdGEtZmlsZS1uYW1lPVwiJHtlc2NhcGVIdG1sKGZpbGVOYW1lKX1cIlxuICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIk1vZGUgbmFtZVwiPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIGApLmpvaW4oJycpfVxuICAgIDwvZGl2PlxuICBgO1xufVxuXG4vKipcbiAqIFJlbmRlciBzaW1wbGlmaWVkIHN0cnVjdHVyZSBwcmV2aWV3IGZvciBtdWx0aS1maWxlIFwiZWFjaCBmaWxlID0gMSBtb2RlXCIgc2NlbmFyaW9cbiAqIFNob3dzIG9ubHkgVG9rZW4gUGF0aCBzdHJ1Y3R1cmUgc2luY2UgbW9kZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmaWxlXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNpbXBsaWZpZWRTdHJ1Y3R1cmUoZ3JvdXBJZDogc3RyaW5nLCBsZXZlbHM6IExldmVsQ29uZmlndXJhdGlvbltdKTogc3RyaW5nIHtcbiAgaWYgKGxldmVscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJuby1zdHJ1Y3R1cmVcIj5ObyBzdHJ1Y3R1cmUgZGV0ZWN0ZWQ8L2Rpdj4nO1xuICB9XG4gIFxuICByZXR1cm4gYFxuICAgIDxkaXYgY2xhc3M9XCJzaW1wbGlmaWVkLXN0cnVjdHVyZVwiIGlkPVwic2ltcGxpZmllZC1zdHJ1Y3R1cmUtJHtlc2NhcGVIdG1sKGdyb3VwSWQpfVwiPlxuICAgICAgJHtsZXZlbHMubWFwKGxldmVsID0+IHtcbiAgICAgICAgY29uc3QgZGlzcGxheUtleXMgPSAobGV2ZWwuZXhhbXBsZUtleXMgfHwgW10pLnNsaWNlKDAsIDUpLmpvaW4oJywgJyk7XG4gICAgICAgIGNvbnN0IG1vcmVDb3VudCA9IChsZXZlbC5rZXlDb3VudCB8fCAwKSA+IDUgPyAobGV2ZWwua2V5Q291bnQgfHwgMCkgLSA1IDogMDtcbiAgICAgICAgY29uc3Qga2V5c0Rpc3BsYXkgPSBtb3JlQ291bnQgPiAwID8gYCR7ZGlzcGxheUtleXN9Li4uICgrJHttb3JlQ291bnR9IG1vcmUpYCA6IGRpc3BsYXlLZXlzO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RydWN0dXJlLWxldmVsXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RydWN0dXJlLWxldmVsLWhlYWRlclwiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInN0cnVjdHVyZS1sZXZlbC1sYWJlbFwiPkxldmVsICR7bGV2ZWwuZGVwdGh9Ojwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdHJ1Y3R1cmUtbGV2ZWwtY291bnRcIj4ke2xldmVsLmtleUNvdW50IHx8IDB9IGtleXM8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdHJ1Y3R1cmUtbGV2ZWwta2V5c1wiPiR7ZXNjYXBlSHRtbChrZXlzRGlzcGxheSl9PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RydWN0dXJlLWxldmVsLXJvbGVcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJyb2xlLWluZGljYXRvclwiPlx1MjE5Mjwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJyb2xlLWxhYmVsXCI+VG9rZW4gUGF0aDwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICBgO1xuICAgICAgfSkuam9pbignJyl9XG4gICAgICA8ZGl2IGNsYXNzPVwic3RydWN0dXJlLWluZm9cIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJpbmZvLWljb25cIj5cdUQ4M0RcdURDQTE8L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaW5mby10ZXh0XCI+TW9kZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmaWxlIChlYWNoIGZpbGUgPSAxIG1vZGUpPC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG59XG5cbi8qKlxuICogQXR0YWNoIGV2ZW50IGxpc3RlbmVycyBmb3IgbW9kZSBzdHJhdGVneSBjaGFuZ2VzXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaE1vZGVTdHJhdGVneUxpc3RlbmVycygpOiB2b2lkIHtcbiAgLy8gTW9kZSBzdHJhdGVneSByYWRpbyBidXR0b25zXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lXj1cIm1vZGUtc3RyYXRlZ3ktXCJdJykuZm9yRWFjaChyYWRpbyA9PiB7XG4gICAgcmFkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICBjb25zdCBncm91cElkID0gdGFyZ2V0LmRhdGFzZXQuZ3JvdXBJZDtcbiAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gdGFyZ2V0LnZhbHVlIGFzICdwZXItZmlsZScgfCAnbWVyZ2VkJztcbiAgICAgIFxuICAgICAgaWYgKGdyb3VwSWQpIHtcbiAgICAgICAgaGFuZGxlTW9kZVN0cmF0ZWd5Q2hhbmdlKGdyb3VwSWQsIHN0cmF0ZWd5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIFxuICAvLyBNb2RlIG5hbWUgaW5wdXRzXG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5tb2RlLW5hbWUtaW5wdXQnKS5mb3JFYWNoKGlucHV0ID0+IHtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgIGNvbnN0IGdyb3VwSWQgPSB0YXJnZXQuZGF0YXNldC5ncm91cElkO1xuICAgICAgY29uc3QgZmlsZU5hbWUgPSB0YXJnZXQuZGF0YXNldC5maWxlTmFtZTtcbiAgICAgIGNvbnN0IG5ld05hbWUgPSB0YXJnZXQudmFsdWU7XG4gICAgICBcbiAgICAgIGlmIChncm91cElkICYmIGZpbGVOYW1lKSB7XG4gICAgICAgIGhhbmRsZU1vZGVOYW1lQ2hhbmdlKGdyb3VwSWQsIGZpbGVOYW1lLCBuZXdOYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogSGFuZGxlIG1vZGUgc3RyYXRlZ3kgY2hhbmdlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU1vZGVTdHJhdGVneUNoYW5nZShncm91cElkOiBzdHJpbmcsIHN0cmF0ZWd5OiAncGVyLWZpbGUnIHwgJ21lcmdlZCcpOiB2b2lkIHtcbiAgY29uc29sZS5sb2coJ1tNdWx0aUNvbGxlY3Rpb25Db25maWddIE1vZGUgc3RyYXRlZ3kgY2hhbmdlZDonLCBncm91cElkLCBzdHJhdGVneSk7XG4gIFxuICBjb25zdCBhbmFseXNpc1N0YXRlID0gYW5hbHlzaXNTdGF0ZXMuZ2V0KGdyb3VwSWQpO1xuICBpZiAoYW5hbHlzaXNTdGF0ZSkge1xuICAgIGFuYWx5c2lzU3RhdGUubW9kZVN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIH1cbiAgXG4gIC8vIFVwZGF0ZSB0aGUgZmlsZSBncm91cCBpbiBzdGF0ZVxuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IGdyb3VwcyA9IHN0YXRlLmZpbGVHcm91cHMgfHwgW107XG4gIGNvbnN0IGdyb3VwID0gZ3JvdXBzLmZpbmQoZyA9PiBnLmlkID09PSBncm91cElkKTtcbiAgaWYgKGdyb3VwKSB7XG4gICAgZ3JvdXAubW9kZVN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgc2V0U3RhdGUoeyBmaWxlR3JvdXBzOiBncm91cHMgfSk7XG4gIH1cbiAgXG4gIC8vIFJlLXJlbmRlciB0aGUgY2FyZCB0byBzaG93L2hpZGUgbW9kZSBuYW1lcyBsaXN0XG4gIHJlUmVuZGVyQ29sbGVjdGlvbkNhcmQoZ3JvdXBJZCk7XG59XG5cbi8qKlxuICogSGFuZGxlIG1vZGUgbmFtZSBjaGFuZ2VcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTW9kZU5hbWVDaGFuZ2UoZ3JvdXBJZDogc3RyaW5nLCBmaWxlTmFtZTogc3RyaW5nLCBuZXdOYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc29sZS5sb2coJ1tNdWx0aUNvbGxlY3Rpb25Db25maWddIE1vZGUgbmFtZSBjaGFuZ2VkOicsIGdyb3VwSWQsIGZpbGVOYW1lLCAnLT4nLCBuZXdOYW1lKTtcbiAgXG4gIGNvbnN0IGFuYWx5c2lzU3RhdGUgPSBhbmFseXNpc1N0YXRlcy5nZXQoZ3JvdXBJZCk7XG4gIGlmIChhbmFseXNpc1N0YXRlKSB7XG4gICAgYW5hbHlzaXNTdGF0ZS5tb2RlTmFtZXNbZmlsZU5hbWVdID0gbmV3TmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIFJlLXJlbmRlciBhIHNpbmdsZSBjb2xsZWN0aW9uIGNhcmRcbiAqL1xuZnVuY3Rpb24gcmVSZW5kZXJDb2xsZWN0aW9uQ2FyZChncm91cElkOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBjb25zdCBncm91cHMgPSBzdGF0ZS5maWxlR3JvdXBzIHx8IFtdO1xuICBjb25zdCBncm91cCA9IGdyb3Vwcy5maW5kKGcgPT4gZy5pZCA9PT0gZ3JvdXBJZCk7XG4gIFxuICBpZiAoIWdyb3VwKSByZXR1cm47XG4gIFxuICBjb25zdCBjYXJkRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBjb2xsZWN0aW9uLSR7Z3JvdXBJZH1gKTtcbiAgaWYgKGNhcmRFbGVtZW50KSB7XG4gICAgY2FyZEVsZW1lbnQub3V0ZXJIVE1MID0gcmVuZGVyQ29sbGVjdGlvbkNhcmQoZ3JvdXApO1xuICAgIFxuICAgIC8vIFJlLXJlbmRlciBsZXZlbCBzZWxlY3RvciBpZiBhbmFseXplZCBhbmQgTk9UIHVzaW5nIHNpbXBsaWZpZWQgc3RydWN0dXJlXG4gICAgY29uc3QgYW5hbHlzaXNTdGF0ZSA9IGFuYWx5c2lzU3RhdGVzLmdldChncm91cElkKTtcbiAgICBjb25zdCBoYXNNdWx0aXBsZUZpbGVzID0gZ3JvdXAuZmlsZU5hbWVzLmxlbmd0aCA+IDE7XG4gICAgY29uc3QgbW9kZVN0cmF0ZWd5ID0gYW5hbHlzaXNTdGF0ZT8ubW9kZVN0cmF0ZWd5IHx8ICdwZXItZmlsZSc7XG4gICAgXG4gICAgLy8gT25seSByZW5kZXIgZnVsbCBsZXZlbCBzZWxlY3RvciBmb3Igc2luZ2xlLWZpbGUgb3IgbWVyZ2VkIG1vZGVcbiAgICAvLyBNdWx0aS1maWxlIFwicGVyLWZpbGVcIiBtb2RlIHVzZXMgc2ltcGxpZmllZCBzdHJ1Y3R1cmUgKGFscmVhZHkgcmVuZGVyZWQgaW5saW5lKVxuICAgIGlmIChhbmFseXNpc1N0YXRlPy5hbmFseXplZCAmJiBhbmFseXNpc1N0YXRlLmxldmVscyAmJiAhKGhhc011bHRpcGxlRmlsZXMgJiYgbW9kZVN0cmF0ZWd5ID09PSAncGVyLWZpbGUnKSkge1xuICAgICAgcmVuZGVyTGV2ZWxTZWxlY3RvcihcbiAgICAgICAgYW5hbHlzaXNTdGF0ZS5sZXZlbHMubWFwKGxldmVsID0+ICh7XG4gICAgICAgICAgZGVwdGg6IGxldmVsLmRlcHRoLFxuICAgICAgICAgIGV4YW1wbGVLZXlzOiBsZXZlbC5leGFtcGxlS2V5cyB8fCBbXSxcbiAgICAgICAgICBrZXlDb3VudDogbGV2ZWwua2V5Q291bnQgfHwgMFxuICAgICAgICB9KSksXG4gICAgICAgIHtcbiAgICAgICAgICBjb250YWluZXJJZDogYGxldmVsLXNlbGVjdG9yLSR7Z3JvdXBJZH1gLFxuICAgICAgICAgIGNvbXBhY3Q6IHRydWUsXG4gICAgICAgICAgb25Db25maWdDaGFuZ2U6IChjb25maWcpID0+IHtcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSB1cGRhdGVkIGNvbmZpZyBpbiB0aGUgYW5hbHlzaXMgc3RhdGUgZm9yIHRoaXMgZ3JvdXBcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gYW5hbHlzaXNTdGF0ZXMuZ2V0KGdyb3VwSWQpO1xuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxldmVscyA9IGNvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlLWF0dGFjaCBsaXN0ZW5lcnMgZm9yIHRoaXMgY2FyZFxuICAgIGF0dGFjaE1vZGVTdHJhdGVneUxpc3RlbmVycygpO1xuICB9XG59XG5cbi8qKlxuICogQW5hbHl6ZSBuZXh0IGNvbGxlY3Rpb24gaW4gc2VxdWVuY2VcbiAqL1xuZnVuY3Rpb24gYW5hbHl6ZU5leHRDb2xsZWN0aW9uKCk6IHZvaWQge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gIGNvbnN0IGdyb3VwcyA9IHN0YXRlLmZpbGVHcm91cHMgfHwgW107XG5cbiAgaWYgKGN1cnJlbnRBbmFseXppbmdJbmRleCA+PSBncm91cHMubGVuZ3RoKSB7XG4gICAgY29uc29sZS5sb2coJ1tNdWx0aUNvbGxlY3Rpb25Db25maWddIEFsbCBjb2xsZWN0aW9ucyBhbmFseXplZCcpO1xuICAgIGVuYWJsZUltcG9ydEJ1dHRvbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGdyb3VwID0gZ3JvdXBzW2N1cnJlbnRBbmFseXppbmdJbmRleF07XG4gIGNvbnN0IGZpcnN0RmlsZU5hbWUgPSBncm91cC5maWxlTmFtZXNbMF07XG4gIGNvbnN0IGZpbGUgPSBzdGF0ZS5maWxlcy5nZXQoZmlyc3RGaWxlTmFtZSk7XG5cbiAgaWYgKCFmaWxlKSB7XG4gICAgY29uc29sZS5lcnJvcignW011bHRpQ29sbGVjdGlvbkNvbmZpZ10gRmlsZSBub3QgZm91bmQ6JywgZmlyc3RGaWxlTmFtZSk7XG4gICAgY3VycmVudEFuYWx5emluZ0luZGV4Kys7XG4gICAgYW5hbHl6ZU5leHRDb2xsZWN0aW9uKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ1tNdWx0aUNvbGxlY3Rpb25Db25maWddIEFuYWx5emluZyBjb2xsZWN0aW9uOicsIGdyb3VwLmNvbGxlY3Rpb25OYW1lLCAnZmlsZTonLCBmaXJzdEZpbGVOYW1lKTtcblxuICAvLyBTZW5kIGFuYWx5c2lzIHJlcXVlc3RcbiAgc2VuZE1lc3NhZ2Uoe1xuICAgIHR5cGU6ICdhbmFseXplLXN0cnVjdHVyZScsXG4gICAgZmlsZU5hbWU6IGZpcnN0RmlsZU5hbWUsXG4gICAganNvbkRhdGE6IGZpbGUuY29udGVudCxcbiAgICBtZXRhZGF0YTogeyBncm91cElkOiBncm91cC5pZCB9IC8vIFBhc3MgZ3JvdXBJZCBzbyB3ZSBrbm93IHdoaWNoIGNvbGxlY3Rpb24gdGhpcyBpcyBmb3JcbiAgfSk7XG59XG5cbi8qKlxuICogSGFuZGxlIHN0cnVjdHVyZSBhbmFseXplZCBmb3IgYSBzcGVjaWZpYyBjb2xsZWN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVDb2xsZWN0aW9uU3RydWN0dXJlQW5hbHl6ZWQobXNnOiB7XG4gIGZpbGVOYW1lOiBzdHJpbmc7XG4gIGxldmVsczogTGV2ZWxDb25maWd1cmF0aW9uW107XG4gIG1ldGFkYXRhPzogeyBncm91cElkOiBzdHJpbmcgfTtcbn0pOiB2b2lkIHtcbiAgY29uc3QgZ3JvdXBJZCA9IG1zZy5tZXRhZGF0YT8uZ3JvdXBJZDtcbiAgaWYgKCFncm91cElkKSB7XG4gICAgY29uc29sZS5lcnJvcignW011bHRpQ29sbGVjdGlvbkNvbmZpZ10gTm8gZ3JvdXBJZCBpbiBzdHJ1Y3R1cmUgYW5hbHlzaXMgcmVzcG9uc2UnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zb2xlLmxvZygnW011bHRpQ29sbGVjdGlvbkNvbmZpZ10gU3RydWN0dXJlIGFuYWx5emVkIGZvciBjb2xsZWN0aW9uOicsIGdyb3VwSWQpO1xuXG4gIC8vIFVwZGF0ZSBhbmFseXNpcyBzdGF0ZVxuICBjb25zdCBhbmFseXNpc1N0YXRlID0gYW5hbHlzaXNTdGF0ZXMuZ2V0KGdyb3VwSWQpO1xuICBpZiAoYW5hbHlzaXNTdGF0ZSkge1xuICAgIGFuYWx5c2lzU3RhdGUuYW5hbHl6ZWQgPSB0cnVlO1xuICAgIGFuYWx5c2lzU3RhdGUubGV2ZWxzID0gbXNnLmxldmVscztcbiAgfVxuXG4gIC8vIFJlLXJlbmRlciB0aGUgZnVsbCBjb2xsZWN0aW9uIGNhcmQgKGluY2x1ZGVzIG1vZGUgc3RyYXRlZ3kgc2VjdGlvbilcbiAgcmVSZW5kZXJDb2xsZWN0aW9uQ2FyZChncm91cElkKTtcblxuICAvLyBNb3ZlIHRvIG5leHQgY29sbGVjdGlvblxuICBjdXJyZW50QW5hbHl6aW5nSW5kZXgrKztcbiAgYW5hbHl6ZU5leHRDb2xsZWN0aW9uKCk7XG59XG5cbi8qKlxuICogRW5hYmxlIGltcG9ydCBidXR0b24gb25jZSBhbGwgY29sbGVjdGlvbnMgYXJlIGFuYWx5emVkXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUltcG9ydEJ1dHRvbigpOiB2b2lkIHtcbiAgY29uc3QgaW1wb3J0QnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ltcG9ydEFsbEJ0bicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICBpZiAoaW1wb3J0QnRuKSB7XG4gICAgaW1wb3J0QnRuLmRpc2FibGVkID0gZmFsc2U7XG4gICAgY29uc29sZS5sb2coJ1tNdWx0aUNvbGxlY3Rpb25Db25maWddIEltcG9ydCBidXR0b24gZW5hYmxlZCcpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGltcG9ydCBhbGwgY29sbGVjdGlvbnNcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW1wb3J0QWxsKCk6IHZvaWQge1xuICBjb25zb2xlLmxvZygnW011bHRpQ29sbGVjdGlvbkNvbmZpZ10gSW1wb3J0IGFsbCBjb2xsZWN0aW9ucyBjbGlja2VkJyk7XG5cbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICBjb25zdCBncm91cHMgPSBzdGF0ZS5maWxlR3JvdXBzIHx8IFtdO1xuXG4gIC8vIENvbGxlY3QgbGV2ZWwgY29uZmlndXJhdGlvbnMgZm9yIGVhY2ggZ3JvdXAgKGFzIHBsYWluIG9iamVjdCBmb3Igc2VyaWFsaXphdGlvbilcbiAgY29uc3QgbGV2ZWxzQnlHcm91cDogUmVjb3JkPHN0cmluZywgTGV2ZWxDb25maWd1cmF0aW9uW10+ID0ge307XG5cbiAgLy8gVXBkYXRlIGdyb3VwcyB3aXRoIGN1cnJlbnQgbW9kZVN0cmF0ZWd5IGFuZCBtb2RlTmFtZXMgZnJvbSBhbmFseXNpc1N0YXRlc1xuICBjb25zdCB1cGRhdGVkR3JvdXBzID0gZ3JvdXBzLm1hcChncm91cCA9PiB7XG4gICAgY29uc3QgYW5hbHlzaXNTdGF0ZSA9IGFuYWx5c2lzU3RhdGVzLmdldChncm91cC5pZCk7XG4gICAgaWYgKGFuYWx5c2lzU3RhdGU/LmxldmVscykge1xuICAgICAgbGV2ZWxzQnlHcm91cFtncm91cC5pZF0gPSBhbmFseXNpc1N0YXRlLmxldmVscztcbiAgICB9XG4gICAgXG4gICAgLy8gQXBwbHkgbW9kZVN0cmF0ZWd5IGFuZCBtb2RlTmFtZXMgZnJvbSBVSSBzdGF0ZVxuICAgIHJldHVybiB7XG4gICAgICAuLi5ncm91cCxcbiAgICAgIG1vZGVTdHJhdGVneTogYW5hbHlzaXNTdGF0ZT8ubW9kZVN0cmF0ZWd5IHx8ICdwZXItZmlsZScsXG4gICAgICBtb2RlTmFtZXM6IGFuYWx5c2lzU3RhdGU/Lm1vZGVOYW1lcyB8fCB7fVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIENvbGxlY3QgZmlsZSBkYXRhIGZyb20gc3RhdGUgKGFzIHBsYWluIG9iamVjdCBmb3Igc2VyaWFsaXphdGlvbilcbiAgY29uc3QgZmlsZXNEYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuICBncm91cHMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgZ3JvdXAuZmlsZU5hbWVzLmZvckVhY2goZmlsZU5hbWUgPT4ge1xuICAgICAgY29uc3QgZmlsZUluZm8gPSBzdGF0ZS5maWxlcy5nZXQoZmlsZU5hbWUpO1xuICAgICAgaWYgKGZpbGVJbmZvKSB7XG4gICAgICAgIGZpbGVzRGF0YVtmaWxlTmFtZV0gPSBmaWxlSW5mby5jb250ZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBjb25zb2xlLmxvZygnW011bHRpQ29sbGVjdGlvbkNvbmZpZ10gU2VuZGluZyBpbXBvcnQgd2l0aCcsIE9iamVjdC5rZXlzKGZpbGVzRGF0YSkubGVuZ3RoLCAnZmlsZXMnKTtcbiAgY29uc29sZS5sb2coJ1tNdWx0aUNvbGxlY3Rpb25Db25maWddIEdyb3VwcyB3aXRoIG1vZGUgc3RyYXRlZ2llczonLCB1cGRhdGVkR3JvdXBzLm1hcChnID0+ICh7XG4gICAgbmFtZTogZy5jb2xsZWN0aW9uTmFtZSxcbiAgICBzdHJhdGVneTogZy5tb2RlU3RyYXRlZ3ksXG4gICAgZmlsZXM6IGcuZmlsZU5hbWVzLmxlbmd0aFxuICB9KSkpO1xuXG4gIC8vIFNlbmQgaW1wb3J0IHJlcXVlc3RcbiAgc2VuZE1lc3NhZ2Uoe1xuICAgIHR5cGU6ICdpbXBvcnQtd2l0aC1tYW51YWwtY29uZmlnJyxcbiAgICBjb25maWc6IHtcbiAgICAgIG11bHRpRmlsZToge1xuICAgICAgICBncm91cHM6IHVwZGF0ZWRHcm91cHMsXG4gICAgICAgIGxldmVsc0J5R3JvdXAsXG4gICAgICAgIGZpbGVzRGF0YVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogSGlkZSBtdWx0aS1jb2xsZWN0aW9uIGNvbmZpZyBVSVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGlkZU11bHRpQ29sbGVjdGlvbkNvbmZpZygpOiB2b2lkIHtcbiAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ211bHRpQ29sbGVjdGlvbkNvbmZpZ1NlY3Rpb24nKTtcbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5cbi8qKlxuICogRXNjYXBlIEhUTUwgdG8gcHJldmVudCBYU1NcbiAqL1xuZnVuY3Rpb24gZXNjYXBlSHRtbCh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgcmV0dXJuIGRpdi5pbm5lckhUTUw7XG59XG4iLCAiLyoqXG4gKiBVSSBFbnRyeSBQb2ludFxuICpcbiAqIEluaXRpYWxpemVzIGFsbCBVSSBjb21wb25lbnRzLCBzZXRzIHVwIGV2ZW50IGxpc3RlbmVycyxcbiAqIGFuZCBjb29yZGluYXRlcyBzdGF0ZSBtYW5hZ2VtZW50IGFuZCBtZXNzYWdlIGhhbmRsaW5nLlxuICovXG5cbmltcG9ydCB7IGdldFN0YXRlLCBzZXRTdGF0ZSwgc2V0SW1wb3J0U3RlcCwgc2V0U3RydWN0dXJlQ29uZmlnIH0gZnJvbSAnLi9zdGF0ZSc7XG5pbXBvcnQgeyBzZW5kTWVzc2FnZSwgb25NZXNzYWdlIH0gZnJvbSAnLi9tZXNzYWdlLWJyaWRnZSc7XG5pbXBvcnQgeyBpbml0VGFicywgdXBkYXRlQWN0aW9uQnV0dG9uIH0gZnJvbSAnLi9jb21wb25lbnRzL3RhYnMnO1xuaW1wb3J0IHsgaW5pdEZpbGVVcGxvYWQgfSBmcm9tICcuL2NvbXBvbmVudHMvZmlsZS11cGxvYWQnO1xuaW1wb3J0IHsgaW5pdENvbGxlY3Rpb25MaXN0cywgcmVuZGVyRXhwb3J0Q29sbGVjdGlvbnMsIHJlbmRlclN5bmNDb2xsZWN0aW9ucyB9IGZyb20gJy4vY29tcG9uZW50cy9jb2xsZWN0aW9uLWxpc3QnO1xuaW1wb3J0IHsgc2hvd0V4cG9ydE1vZGFsIH0gZnJvbSAnLi9jb21wb25lbnRzL2V4cG9ydC1tb2RhbCc7XG5pbXBvcnQgeyBzaG93U3luY1N1Y2Nlc3MsIGluaXRTeW5jU3VjY2Vzc1NjcmVlbiB9IGZyb20gJy4vY29tcG9uZW50cy9zdWNjZXNzLXNjcmVlbic7XG5pbXBvcnQgeyBzaG93TGFzdFN5bmNJbmZvLCBpbml0U3luY0luZm8gfSBmcm9tICcuL2NvbXBvbmVudHMvc3luYy1pbmZvJztcbmltcG9ydCB7IHJlbmRlckJhc2VsaW5lQ29uZmlybWF0aW9uLCBoaWRlQmFzZWxpbmVDb25maXJtYXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMvYmFzZWxpbmUtY29uZmlybWF0aW9uJztcbmltcG9ydCB7IHJlbmRlclN5bmNDaGFuZ2VzRGlmZiwgaGlkZVN5bmNDaGFuZ2VzRGlmZiB9IGZyb20gJy4vY29tcG9uZW50cy9zeW5jLWNoYW5nZXMtZGlmZic7XG5pbXBvcnQgeyByZW5kZXJJbXBvcnRDaGFuZ2VzRGlmZiwgaGlkZUltcG9ydENoYW5nZXNEaWZmIH0gZnJvbSAnLi9jb21wb25lbnRzL2ltcG9ydC1jaGFuZ2VzLWRpZmYnO1xuaW1wb3J0IHsgZGlzcGxheUFuYWx5emVkU3RydWN0dXJlLCBoaWRlU3RydWN0dXJlUHJldmlldywgcmVuZGVyU3RydWN0dXJlUHJldmlldyB9IGZyb20gJy4vY29tcG9uZW50cy9zdHJ1Y3R1cmUtcHJldmlldyc7XG5pbXBvcnQgeyByZW5kZXJMZXZlbFNlbGVjdG9yIH0gZnJvbSAnLi9jb21wb25lbnRzL2xldmVsLXNlbGVjdG9yJztcbmltcG9ydCB7IHJlbmRlckZpbGVHcm91cGluZywgaGlkZUZpbGVHcm91cGluZyB9IGZyb20gJy4vY29tcG9uZW50cy9maWxlLWdyb3VwaW5nJztcbmltcG9ydCB7IHJlbmRlckxpdmVQcmV2aWV3LCBoaWRlTGl2ZVByZXZpZXcgfSBmcm9tICcuL2NvbXBvbmVudHMvbGl2ZS1wcmV2aWV3JztcbmltcG9ydCB7IHJlbmRlck11bHRpQ29sbGVjdGlvbkNvbmZpZywgaGFuZGxlQ29sbGVjdGlvblN0cnVjdHVyZUFuYWx5emVkLCBoaWRlTXVsdGlDb2xsZWN0aW9uQ29uZmlnIH0gZnJvbSAnLi9jb21wb25lbnRzL211bHRpLWNvbGxlY3Rpb24tY29uZmlnJztcbmltcG9ydCB0eXBlIHsgTWFudWFsSW1wb3J0Q29uZmlnLCBQcmV2aWV3U3RydWN0dXJlIH0gZnJvbSAnLi4vdHlwZXMvbWVzc2FnZS50eXBlcyc7XG5pbXBvcnQgdHlwZSB7IExldmVsQ29uZmlndXJhdGlvbiB9IGZyb20gJy4uL3R5cGVzL2xldmVsLWNvbmZpZy50eXBlcyc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhbGwgVUkgY29tcG9uZW50cyBhbmQgZXZlbnQgaGFuZGxlcnNcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVVJKCk6IHZvaWQge1xuICAvLyBJbml0aWFsaXplIHRhYiBuYXZpZ2F0aW9uXG4gIGluaXRUYWJzKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBmaWxlIHVwbG9hZCBjb21wb25lbnRcbiAgaW5pdEZpbGVVcGxvYWQoe1xuICAgIG9uRmlsZXNDaGFuZ2VkOiAoKSA9PiB7XG4gICAgICBoYW5kbGVGaWxlc0NoYW5nZWQoKTtcbiAgICB9LFxuICAgIG9uRXJyb3I6IChmaWxlTmFtZSwgZXJyb3IpID0+IHtcbiAgICAgIHNob3dOb3RpZmljYXRpb24oYEVycm9yIHBhcnNpbmcgJHtmaWxlTmFtZX06ICR7ZXJyb3J9YCwgJ2Vycm9yJyk7XG4gICAgfVxuICB9KTtcblxuICAvLyBJbml0aWFsaXplIGNvbGxlY3Rpb24gbGlzdHMgKGV4cG9ydC9zeW5jIHRhYnMpXG4gIGluaXRDb2xsZWN0aW9uTGlzdHMoe1xuICAgIG9uU2VsZWN0aW9uQ2hhbmdlZDogKCkgPT4ge1xuICAgICAgdXBkYXRlQWN0aW9uQnV0dG9uKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBMaXN0ZW4gZm9yIGNvbGxlY3Rpb25zIGxvYWRlZCBldmVudCB0byByZS1yZW5kZXIgdGhlIGFjdGl2ZSB0YWIncyBsaXN0XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NvbGxlY3Rpb25zLWxvYWRlZCcsICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnRUYWIgPT09ICdleHBvcnQnKSB7XG4gICAgICByZW5kZXJFeHBvcnRDb2xsZWN0aW9ucygpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuY3VycmVudFRhYiA9PT0gJ3N5bmMnKSB7XG4gICAgICByZW5kZXJTeW5jQ29sbGVjdGlvbnMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEluaXRpYWxpemUgc3luYyBzdWNjZXNzIHNjcmVlblxuICBpbml0U3luY1N1Y2Nlc3NTY3JlZW4oKTtcblxuICAvLyBJbml0aWFsaXplIHN5bmMgaW5mbyBkaXNwbGF5XG4gIGluaXRTeW5jSW5mbygpO1xuXG4gIC8vIEluaXRpYWxpemUgc3luYyB0YWIgXCJDaGVjayBmb3IgQ2hhbmdlc1wiIGJ1dHRvblxuICBpbml0U3luY0NoZWNrQ2hhbmdlcygpO1xuXG4gIC8vIEluaXRpYWxpemUgYWN0aW9uIGJ1dHRvbiBoYW5kbGVyc1xuICBpbml0QWN0aW9uQnV0dG9uKCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBjYW5jZWwgYnV0dG9uXG4gIGluaXRDYW5jZWxCdXR0b24oKTtcblxuICAvLyBTZXQgdXAgbWVzc2FnZSBoYW5kbGVyXG4gIHNldHVwTWVzc2FnZUhhbmRsZXIoKTtcblxuICAvLyBTZXQgdXAgZmxleGlibGUgaW1wb3J0IGV2ZW50IGxpc3RlbmVyc1xuICBzZXR1cEZsZXhpYmxlSW1wb3J0TGlzdGVuZXJzKCk7XG5cbiAgLy8gSW5pdGlhbCBVSSBzdGF0ZVxuICB1cGRhdGVBY3Rpb25CdXR0b24oKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgZmlsZXMgY2hhbmdlZCBldmVudCBmcm9tIGZpbGUgdXBsb2FkXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUZpbGVzQ2hhbmdlZCgpOiB2b2lkIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuXG4gIC8vIFVwZGF0ZSBhY3Rpb24gYnV0dG9uXG4gIHVwZGF0ZUFjdGlvbkJ1dHRvbigpO1xuXG4gIC8vIEluaXRpYXRlIGZsZXhpYmxlIGltcG9ydCBmbG93IGlmIGZpbGVzIGFyZSB1cGxvYWRlZFxuICBpZiAoc3RhdGUuZmlsZXMuc2l6ZSA+IDApIHtcbiAgICAvLyBDaGVjayBpZiBhbnkgZmlsZSBpcyBOT1QgYmFzZWxpbmVcbiAgICBjb25zdCBoYXNOb25CYXNlbGluZUZpbGVzID0gQXJyYXkuZnJvbShzdGF0ZS5maWxlcy52YWx1ZXMoKSkuc29tZShmID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBmLmNvbnRlbnQ7XG4gICAgICByZXR1cm4gIShkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAnJG1ldGFkYXRhJyBpbiBkYXRhICYmICdiYXNlbGluZScgaW4gZGF0YSk7XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzTm9uQmFzZWxpbmVGaWxlcykge1xuICAgICAgY29uc29sZS5sb2coJ1tVSV0gRmlsZXMgcmVhZHkgLSBpbml0aWF0aW5nIGZsZXhpYmxlIGltcG9ydCcpO1xuICAgICAgaW5pdGlhdGVGbGV4aWJsZUltcG9ydCgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluaXRpYWxpemUgc3luYyBjaGVjayBmb3IgY2hhbmdlcyBidXR0b25cbiAqL1xuZnVuY3Rpb24gaW5pdFN5bmNDaGVja0NoYW5nZXMoKTogdm9pZCB7XG4gIGNvbnN0IGNoZWNrQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoZWNrQ2hhbmdlc0J0bicpO1xuICBpZiAoIWNoZWNrQnRuKSByZXR1cm47XG5cbiAgY2hlY2tCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgc2VuZE1lc3NhZ2UoeyB0eXBlOiAnY2hlY2stc3luYy1jaGFuZ2VzJyB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBtYWluIGFjdGlvbiBidXR0b24gaGFuZGxlclxuICovXG5mdW5jdGlvbiBpbml0QWN0aW9uQnV0dG9uKCk6IHZvaWQge1xuICBjb25zdCBhY3Rpb25CdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWN0aW9uQnRuJyk7XG4gIGlmICghYWN0aW9uQnRuKSByZXR1cm47XG5cbiAgYWN0aW9uQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcblxuICAgIHN3aXRjaCAoc3RhdGUuY3VycmVudFRhYikge1xuICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgICAgaGFuZGxlSW1wb3J0QWN0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgICBzZW5kTWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogJ2V4cG9ydC1iYXNlbGluZScsXG4gICAgICAgICAgY29sbGVjdGlvbklkczogQXJyYXkuZnJvbShzdGF0ZS5zZWxlY3RlZEV4cG9ydENvbGxlY3Rpb25zKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N5bmMnOlxuICAgICAgICBzZW5kTWVzc2FnZSh7XG4gICAgICAgICAgdHlwZTogJ3N5bmMtdG8tbm9kZScsXG4gICAgICAgICAgY29sbGVjdGlvbklkczogQXJyYXkuZnJvbShzdGF0ZS5zZWxlY3RlZFN5bmNDb2xsZWN0aW9ucylcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogSGFuZGxlIGltcG9ydCBhY3Rpb25cbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW1wb3J0QWN0aW9uKCk6IHZvaWQge1xuICBoYW5kbGVGbGV4aWJsZUltcG9ydCgpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBmbGV4aWJsZSBpbXBvcnQgYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUZsZXhpYmxlSW1wb3J0KCk6IHZvaWQge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG5cbiAgaWYgKCFzdGF0ZS5zdHJ1Y3R1cmVDb25maWcpIHtcbiAgICBzaG93Tm90aWZpY2F0aW9uKCdObyBjb25maWd1cmF0aW9uIGZvdW5kLiBQbGVhc2UgY29uZmlndXJlIGxldmVsIG1hcHBpbmcgZmlyc3QuJywgJ2Vycm9yJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY29uZmlnOiBNYW51YWxJbXBvcnRDb25maWcgPSB7fTtcblxuICAvLyBTaW5nbGUtZmlsZSBpbXBvcnRcbiAgaWYgKHN0YXRlLmZpbGVzLnNpemUgPT09IDEgJiYgIXN0YXRlLmZpbGVHcm91cHMpIHtcbiAgICBjb25zdCBmaWxlTmFtZSA9IEFycmF5LmZyb20oc3RhdGUuZmlsZXMua2V5cygpKVswXTtcbiAgICBjb25zdCBmaWxlID0gc3RhdGUuZmlsZXMuZ2V0KGZpbGVOYW1lKTtcblxuICAgIGlmIChmaWxlKSB7XG4gICAgICBjb25maWcuc2luZ2xlRmlsZSA9IHtcbiAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgIGRhdGE6IGZpbGUuY29udGVudCxcbiAgICAgICAgbGV2ZWxzOiBzdGF0ZS5zdHJ1Y3R1cmVDb25maWcubGV2ZWxzXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIE11bHRpLWZpbGUgaW1wb3J0XG4gIGlmIChzdGF0ZS5maWxlR3JvdXBzICYmIHN0YXRlLmZpbGVHcm91cHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxldmVsc0J5R3JvdXAgPSBuZXcgTWFwPHN0cmluZywgTGV2ZWxDb25maWd1cmF0aW9uW10+KCk7XG5cbiAgICAvLyBGb3Igbm93LCB1c2UgdGhlIHNhbWUgbGV2ZWwgY29uZmlndXJhdGlvbiBmb3IgYWxsIGdyb3Vwc1xuICAgIC8vIEluIGEgZnV0dXJlIGVuaGFuY2VtZW50LCB3ZSBjb3VsZCBzdXBwb3J0IHBlci1ncm91cCBjb25maWd1cmF0aW9uXG4gICAgc3RhdGUuZmlsZUdyb3Vwcy5mb3JFYWNoKChncm91cCkgPT4ge1xuICAgICAgbGV2ZWxzQnlHcm91cC5zZXQoZ3JvdXAuaWQsIHN0YXRlLnN0cnVjdHVyZUNvbmZpZyEubGV2ZWxzKTtcbiAgICB9KTtcblxuICAgIGNvbmZpZy5tdWx0aUZpbGUgPSB7XG4gICAgICBncm91cHM6IHN0YXRlLmZpbGVHcm91cHMsXG4gICAgICBsZXZlbHNCeUdyb3VwXG4gICAgfTtcbiAgfVxuXG4gIC8vIFNlbmQgdG8gYmFja2VuZFxuICBzZW5kTWVzc2FnZSh7XG4gICAgdHlwZTogJ2ltcG9ydC13aXRoLW1hbnVhbC1jb25maWcnLFxuICAgIGNvbmZpZ1xuICB9KTtcbn1cblxuXG4vKipcbiAqIEluaXRpYWxpemUgY2FuY2VsIGJ1dHRvblxuICovXG5mdW5jdGlvbiBpbml0Q2FuY2VsQnV0dG9uKCk6IHZvaWQge1xuICBjb25zdCBjYW5jZWxCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FuY2VsQnRuJyk7XG4gIGlmICghY2FuY2VsQnRuKSByZXR1cm47XG5cbiAgY2FuY2VsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgIHNlbmRNZXNzYWdlKHsgdHlwZTogJ2NhbmNlbCcgfSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB1cCBmbGV4aWJsZSBpbXBvcnQgZXZlbnQgbGlzdGVuZXJzXG4gKi9cbmZ1bmN0aW9uIHNldHVwRmxleGlibGVJbXBvcnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gIC8vIExpc3RlbiBmb3IgbGV2ZWwgY29uZmlndXJhdGlvbiBjaGFuZ2VzXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xldmVsLWNvbmZpZ3VyYXRpb24tY2hhbmdlZCcsICgoZXZlbnQ6IEN1c3RvbUV2ZW50KSA9PiB7XG4gICAgaGFuZGxlTGV2ZWxDb25maWd1cmF0aW9uQ2hhbmdlZChldmVudC5kZXRhaWwpO1xuICB9KSBhcyBFdmVudExpc3RlbmVyKTtcblxuICAvLyBMaXN0ZW4gZm9yIGZpbGUgZ3JvdXBpbmcgY29tcGxldGVcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZmlsZS1ncm91cGluZy1jb21wbGV0ZScsICgpID0+IHtcbiAgICBoYW5kbGVGaWxlR3JvdXBpbmdDb21wbGV0ZSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgbGV2ZWwgY29uZmlndXJhdGlvbiBjaGFuZ2VkXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUxldmVsQ29uZmlndXJhdGlvbkNoYW5nZWQoZGV0YWlsOiB7XG4gIGNvbmZpZ3VyYXRpb246IExldmVsQ29uZmlndXJhdGlvbltdO1xuICB2YWxpZGF0aW9uOiB7IHZhbGlkOiBib29sZWFuIH07XG59KTogdm9pZCB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcblxuICAvLyBVcGRhdGUgYWN0aW9uIGJ1dHRvbiBzdGF0ZSBiYXNlZCBvbiB2YWxpZGF0aW9uXG4gIGNvbnN0IGFjdGlvbkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhY3Rpb25CdG4nKSBhcyBIVE1MQnV0dG9uRWxlbWVudDtcbiAgaWYgKGFjdGlvbkJ0bikge1xuICAgIGFjdGlvbkJ0bi5kaXNhYmxlZCA9ICFkZXRhaWwudmFsaWRhdGlvbi52YWxpZDtcbiAgICBhY3Rpb25CdG4udGV4dENvbnRlbnQgPSAnSW1wb3J0IHRvIEZpZ21hJztcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHByZXZpZXcgaWYgY29uZmlndXJhdGlvbiBpcyB2YWxpZFxuICBpZiAoZGV0YWlsLnZhbGlkYXRpb24udmFsaWQgJiYgc3RhdGUuZmlsZXMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBmaWxlTmFtZSA9IEFycmF5LmZyb20oc3RhdGUuZmlsZXMua2V5cygpKVswXTtcbiAgICBjb25zdCBmaWxlID0gc3RhdGUuZmlsZXMuZ2V0KGZpbGVOYW1lKTtcblxuICAgIGlmIChmaWxlKSB7XG4gICAgICBzZW5kTWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdnZW5lcmF0ZS1wcmV2aWV3JyxcbiAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgIGpzb25EYXRhOiBmaWxlLmNvbnRlbnQsXG4gICAgICAgIGxldmVsczogZGV0YWlsLmNvbmZpZ3VyYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZSBmaWxlIGdyb3VwaW5nIGNvbXBsZXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUZpbGVHcm91cGluZ0NvbXBsZXRlKCk6IHZvaWQge1xuICBjb25zb2xlLmxvZygnW1VJXSBoYW5kbGVGaWxlR3JvdXBpbmdDb21wbGV0ZSBjYWxsZWQhJyk7XG4gIGNvbnNvbGUudHJhY2UoJ1tVSV0gU3RhY2sgdHJhY2U6Jyk7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcblxuICAvLyBIaWRlIGZpbGUgZ3JvdXBpbmcgVUlcbiAgaGlkZUZpbGVHcm91cGluZygpO1xuXG4gIC8vIFNob3cgbXVsdGktY29sbGVjdGlvbiBjb25maWd1cmF0aW9uIFVJXG4gIGlmIChzdGF0ZS5maWxlR3JvdXBzICYmIHN0YXRlLmZpbGVHcm91cHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnNvbGUubG9nKCdbVUldIFN0YXJ0aW5nIG11bHRpLWNvbGxlY3Rpb24gY29uZmlndXJhdGlvbiBmb3InLCBzdGF0ZS5maWxlR3JvdXBzLmxlbmd0aCwgJ2NvbGxlY3Rpb24ocyknKTtcblxuICAgIHNldEltcG9ydFN0ZXAoJ2NvbmZpZ3VyZScpO1xuICAgIHJlbmRlck11bHRpQ29sbGVjdGlvbkNvbmZpZygpO1xuICB9XG59XG5cbi8qKlxuICogU2V0IHVwIG1lc3NhZ2UgaGFuZGxlciBmb3IgYmFja2VuZCBtZXNzYWdlc1xuICovXG5mdW5jdGlvbiBzZXR1cE1lc3NhZ2VIYW5kbGVyKCk6IHZvaWQge1xuICBvbk1lc3NhZ2UoKG1zZykgPT4ge1xuICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2xhc3Qtc3luYy1sb2FkZWQnOlxuICAgICAgICBpZiAobXNnLmV4aXN0cyAmJiBtc2cubm9kZUlkICYmIG1zZy52YXJpYWJsZUNvdW50ICE9PSB1bmRlZmluZWQgJiYgbXNnLnVwZGF0ZWRBdCkge1xuICAgICAgICAgIHNob3dMYXN0U3luY0luZm8obXNnLm5vZGVJZCwgbXNnLnZhcmlhYmxlQ291bnQsIG1zZy51cGRhdGVkQXQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjb2xsZWN0aW9ucy1sb2FkZWQnOlxuICAgICAgICBoYW5kbGVDb2xsZWN0aW9uc0xvYWRlZChtc2cuY29sbGVjdGlvbnMpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW1wb3J0LWNvbXBsZXRlJzpcbiAgICAgICAgc2hvd05vdGlmaWNhdGlvbihtc2cubWVzc2FnZSwgJ3N1Y2Nlc3MnKTtcbiAgICAgICAgaGlkZUJhc2VsaW5lQ29uZmlybWF0aW9uKCk7XG4gICAgICAgIGhpZGVGbGV4aWJsZUltcG9ydFVJKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbXBvcnQtZXJyb3InOlxuICAgICAgICBzaG93Tm90aWZpY2F0aW9uKCdFcnJvcjogJyArIG1zZy5tZXNzYWdlLCAnZXJyb3InKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2V4cG9ydC1jb21wbGV0ZSc6XG4gICAgICAgIHNob3dFeHBvcnRNb2RhbChtc2cuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdleHBvcnQtZXJyb3InOlxuICAgICAgICBzaG93Tm90aWZpY2F0aW9uKCdFeHBvcnQgRXJyb3I6ICcgKyBtc2cubWVzc2FnZSwgJ2Vycm9yJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzeW5jLWNvbXBsZXRlJzpcbiAgICAgICAgc2hvd1N5bmNTdWNjZXNzKG1zZy5ub2RlSWQsIG1zZy52YXJpYWJsZUNvdW50KTtcbiAgICAgICAgaGlkZVN5bmNDaGFuZ2VzRGlmZigpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3luYy1lcnJvcic6XG4gICAgICAgIHNob3dOb3RpZmljYXRpb24oJ1N5bmMgRXJyb3I6ICcgKyBtc2cubWVzc2FnZSwgJ2Vycm9yJyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbXBvcnQtZm9ybWF0LWRldGVjdGVkJzpcbiAgICAgICAgaGFuZGxlSW1wb3J0Rm9ybWF0RGV0ZWN0ZWQobXNnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cnVjdHVyZS1hbmFseXplZCc6XG4gICAgICAgIGhhbmRsZVN0cnVjdHVyZUFuYWx5emVkKG1zZyk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwcmV2aWV3LWdlbmVyYXRlZCc6XG4gICAgICAgIGhhbmRsZVByZXZpZXdHZW5lcmF0ZWQobXNnKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N5bmMtY2hhbmdlcy1kZXRlY3RlZCc6XG4gICAgICAgIHJlbmRlclN5bmNDaGFuZ2VzRGlmZihtc2cudmVyc2lvbkJ1bXApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW1wb3J0LWNoYW5nZXMtZGV0ZWN0ZWQnOlxuICAgICAgICByZW5kZXJJbXBvcnRDaGFuZ2VzRGlmZihtc2cudmVyc2lvbkJ1bXAsIG1zZy5iYXNlbGluZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogSGFuZGxlIHN0cnVjdHVyZSBhbmFseXplZCBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVN0cnVjdHVyZUFuYWx5emVkKG1zZzoge1xuICBmaWxlTmFtZTogc3RyaW5nO1xuICBsZXZlbHM6IExldmVsQ29uZmlndXJhdGlvbltdO1xuICBtZXRhZGF0YT86IHsgZ3JvdXBJZDogc3RyaW5nIH07XG59KTogdm9pZCB7XG4gIGNvbnNvbGUubG9nKCdbVUldIFN0cnVjdHVyZSBhbmFseXplZCAtIHNob3dpbmcgbGV2ZWwgc2VsZWN0b3InLCBtc2cubGV2ZWxzLmxlbmd0aCwgJ2xldmVscycpO1xuXG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGZvciBtdWx0aS1jb2xsZWN0aW9uIGNvbmZpZ1xuICBpZiAoc3RhdGUuZmlsZUdyb3VwcyAmJiBzdGF0ZS5maWxlR3JvdXBzLmxlbmd0aCA+IDEgJiYgbXNnLm1ldGFkYXRhPy5ncm91cElkKSB7XG4gICAgY29uc29sZS5sb2coJ1tVSV0gUm91dGluZyB0byBtdWx0aS1jb2xsZWN0aW9uIGhhbmRsZXIgZm9yIGdyb3VwSWQ6JywgbXNnLm1ldGFkYXRhLmdyb3VwSWQpO1xuICAgIGhhbmRsZUNvbGxlY3Rpb25TdHJ1Y3R1cmVBbmFseXplZChtc2cpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFNpbmdsZS1maWxlIGZsb3c6IEluaXRpYWxpemUgc3RydWN0dXJlIGNvbmZpZyBzdGF0ZVxuICBzZXRTdHJ1Y3R1cmVDb25maWcoe1xuICAgIGZpbGVOYW1lOiBtc2cuZmlsZU5hbWUsXG4gICAgbGV2ZWxzOiBtc2cubGV2ZWxzXG4gIH0pO1xuXG4gIC8vIFNob3cgc3RydWN0dXJlIHByZXZpZXcgc2VjdGlvblxuICBjb25zdCBzdHJ1Y3R1cmVTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0cnVjdHVyZVByZXZpZXdTZWN0aW9uJyk7XG4gIGlmIChzdHJ1Y3R1cmVTZWN0aW9uKSB7XG4gICAgY29uc29sZS5sb2coJ1tVSV0gU2hvd2luZyBzdHJ1Y3R1cmUgcHJldmlldyBzZWN0aW9uJyk7XG4gICAgc3RydWN0dXJlU2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVUldIHN0cnVjdHVyZVByZXZpZXdTZWN0aW9uIG5vdCBmb3VuZCEnKTtcbiAgfVxuXG4gIC8vIFNob3cgbGV2ZWwgc2VsZWN0b3Igc2VjdGlvblxuICBjb25zdCBsZXZlbFNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGV2ZWxTZWxlY3RvclNlY3Rpb24nKTtcbiAgaWYgKGxldmVsU2VjdGlvbikge1xuICAgIGNvbnNvbGUubG9nKCdbVUldIFNob3dpbmcgbGV2ZWwgc2VsZWN0b3Igc2VjdGlvbicpO1xuICAgIGxldmVsU2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVUldIGxldmVsU2VsZWN0b3JTZWN0aW9uIG5vdCBmb3VuZCEnKTtcbiAgfVxuXG4gIC8vIFJlbmRlciBsZXZlbCBzZWxlY3RvciB3aXRoIGFuYWx5emVkIGxldmVsc1xuICBjb25zb2xlLmxvZygnW1VJXSBSZW5kZXJpbmcgbGV2ZWwgc2VsZWN0b3InKTtcbiAgcmVuZGVyTGV2ZWxTZWxlY3RvcihcbiAgICBtc2cubGV2ZWxzLm1hcCgobGV2ZWwpID0+ICh7XG4gICAgICBkZXB0aDogbGV2ZWwuZGVwdGgsXG4gICAgICBleGFtcGxlS2V5czogbGV2ZWwuZXhhbXBsZUtleXMgfHwgW10sXG4gICAgICBrZXlDb3VudDogbGV2ZWwua2V5Q291bnQgfHwgMFxuICAgIH0pKVxuICApO1xufVxuXG4vKipcbiAqIEhhbmRsZSBwcmV2aWV3IGdlbmVyYXRlZCBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByZXZpZXdHZW5lcmF0ZWQobXNnOiB7IHByZXZpZXc6IFByZXZpZXdTdHJ1Y3R1cmUgfSk6IHZvaWQge1xuICAvLyBTaG93IGxpdmUgcHJldmlldyBzZWN0aW9uXG4gIGNvbnN0IHByZXZpZXdTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xpdmVQcmV2aWV3U2VjdGlvbicpO1xuICBpZiAocHJldmlld1NlY3Rpb24pIHtcbiAgICBwcmV2aWV3U2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfVxuXG4gIC8vIFJlbmRlciB0aGUgcHJldmlld1xuICByZW5kZXJMaXZlUHJldmlldyhtc2cucHJldmlldyk7XG5cbiAgLy8gRW5hYmxlIGltcG9ydCBidXR0b25cbiAgY29uc3QgYWN0aW9uQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjdGlvbkJ0bicpIGFzIEhUTUxCdXR0b25FbGVtZW50O1xuICBpZiAoYWN0aW9uQnRuKSB7XG4gICAgYWN0aW9uQnRuLmRpc2FibGVkID0gZmFsc2U7XG4gICAgYWN0aW9uQnRuLnRleHRDb250ZW50ID0gJ0ltcG9ydCB0byBGaWdtYSc7XG4gIH1cbn1cblxuLyoqXG4gKiBIaWRlIGZsZXhpYmxlIGltcG9ydCBVSSBzZWN0aW9uc1xuICovXG5mdW5jdGlvbiBoaWRlRmxleGlibGVJbXBvcnRVSSgpOiB2b2lkIHtcbiAgaGlkZVN0cnVjdHVyZVByZXZpZXcoKTtcbiAgaGlkZUZpbGVHcm91cGluZygpO1xuICBoaWRlTGl2ZVByZXZpZXcoKTtcblxuICBjb25zdCBsZXZlbFNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGV2ZWxTZWxlY3RvclNlY3Rpb24nKTtcbiAgaWYgKGxldmVsU2VjdGlvbikge1xuICAgIGxldmVsU2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGltcG9ydCBmb3JtYXQgZGV0ZWN0aW9uIHJlc3VsdHNcbiAqL1xuZnVuY3Rpb24gaGFuZGxlSW1wb3J0Rm9ybWF0RGV0ZWN0ZWQobXNnOiB7XG4gIGZpbGVOYW1lOiBzdHJpbmc7XG4gIGJhc2VsaW5lRGV0ZWN0aW9uOiBhbnk7XG4gIHZhbGlkYXRpb24/OiBhbnk7XG59KTogdm9pZCB7XG4gIGNvbnNvbGUubG9nKCdbVUldIERldGVjdGlvbiByZXN1bHRzIHJlY2VpdmVkOicsIHtcbiAgICBmaWxlTmFtZTogbXNnLmZpbGVOYW1lLFxuICAgIGlzQmFzZWxpbmU6IG1zZy5iYXNlbGluZURldGVjdGlvbi5pc0Jhc2VsaW5lLFxuICAgIHZhbGlkYXRpb246IG1zZy52YWxpZGF0aW9uXG4gIH0pO1xuXG4gIC8vIFVwZGF0ZSBzdGF0ZSB3aXRoIGRldGVjdGlvbiByZXN1bHRzXG4gIHNldFN0YXRlKHtcbiAgICBiYXNlbGluZURldGVjdGlvbjogbXNnLmJhc2VsaW5lRGV0ZWN0aW9uLFxuICAgIHZhbGlkYXRpb246IG1zZy52YWxpZGF0aW9uXG4gIH0pO1xuXG4gIC8vIFNob3cgYmFzZWxpbmUgY29uZmlybWF0aW9uIFVJIGlmIGRldGVjdGVkXG4gIGlmIChtc2cuYmFzZWxpbmVEZXRlY3Rpb24uaXNCYXNlbGluZSkge1xuICAgIGNvbnNvbGUubG9nKCdbVUldIFNob3dpbmcgYmFzZWxpbmUgY29uZmlybWF0aW9uIFVJJyk7XG5cbiAgICByZW5kZXJCYXNlbGluZUNvbmZpcm1hdGlvbih7XG4gICAgICBkZXRlY3Rpb246IG1zZy5iYXNlbGluZURldGVjdGlvbixcbiAgICAgIHZhbGlkYXRpb246IG1zZy52YWxpZGF0aW9uISxcbiAgICAgIG9uQ29uZmlndXJlTWFudWFsbHk6ICgpID0+IHtcbiAgICAgICAgaGlkZUJhc2VsaW5lQ29uZmlybWF0aW9uKCk7XG4gICAgICAgIC8vIFNob3cgZmxleGlibGUgaW1wb3J0IGZsb3cgZm9yIGJhc2VsaW5lIGZpbGVzIHRvb1xuICAgICAgICBpbml0aWF0ZUZsZXhpYmxlSW1wb3J0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gTk9URTogRG8gTk9UIGNhbGwgaW5pdGlhdGVGbGV4aWJsZUltcG9ydCgpIGhlcmUgZm9yIG5vbi1iYXNlbGluZSBmaWxlcyFcbiAgLy8gSXQgd2lsbCBiZSBjYWxsZWQgYnkgY2hlY2tGaWxlc1JlYWR5KCkgYWZ0ZXIgQUxMIGZpbGVzIGFyZSB1cGxvYWRlZFxufVxuXG4vKipcbiAqIEluaXRpYXRlIGZsZXhpYmxlIGltcG9ydCBmbG93XG4gKi9cbmZ1bmN0aW9uIGluaXRpYXRlRmxleGlibGVJbXBvcnQoKTogdm9pZCB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcblxuICBjb25zb2xlLmxvZygnW1VJXSBpbml0aWF0ZUZsZXhpYmxlSW1wb3J0IC0gZmlsZXMuc2l6ZTonLCBzdGF0ZS5maWxlcy5zaXplKTtcbiAgY29uc29sZS5sb2coJ1tVSV0gRmlsZXM6JywgQXJyYXkuZnJvbShzdGF0ZS5maWxlcy5rZXlzKCkpKTtcblxuICAvLyBDaGVjayBpZiBtdWx0aXBsZSBmaWxlc1xuICBpZiAoc3RhdGUuZmlsZXMuc2l6ZSA+IDEpIHtcbiAgICBjb25zb2xlLmxvZygnW1VJXSBNdWx0aXBsZSBmaWxlcyBkZXRlY3RlZCAtIHNob3dpbmcgZmlsZSBncm91cGluZyBVSScpO1xuICAgIC8vIFNob3cgZmlsZSBncm91cGluZyBVSVxuICAgIHNldEltcG9ydFN0ZXAoJ2dyb3VwJyk7XG4gICAgY29uc3QgZ3JvdXBpbmdTZWN0aW9uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbGVHcm91cGluZ1NlY3Rpb24nKTtcbiAgICBpZiAoZ3JvdXBpbmdTZWN0aW9uKSB7XG4gICAgICBjb25zb2xlLmxvZygnW1VJXSBmaWxlR3JvdXBpbmdTZWN0aW9uIGZvdW5kLCBkaXNwbGF5aW5nLi4uJyk7XG4gICAgICBncm91cGluZ1NlY3Rpb24uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tVSV0gZmlsZUdyb3VwaW5nU2VjdGlvbiBOT1QgRk9VTkQhJyk7XG4gICAgfVxuICAgIGNvbnNvbGUubG9nKCdbVUldIENhbGxpbmcgcmVuZGVyRmlsZUdyb3VwaW5nKCkuLi4nKTtcbiAgICByZW5kZXJGaWxlR3JvdXBpbmcoKTtcbiAgICBjb25zb2xlLmxvZygnW1VJXSByZW5kZXJGaWxlR3JvdXBpbmcoKSBjb21wbGV0ZWQnKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5maWxlcy5zaXplID09PSAxKSB7XG4gICAgY29uc29sZS5sb2coJ1tVSV0gU2luZ2xlIGZpbGUgZGV0ZWN0ZWQgLSBnb2luZyB0byBzdHJ1Y3R1cmUgYW5hbHlzaXMnKTtcbiAgICAvLyBTaW5nbGUgZmlsZSAtIGdvIGRpcmVjdGx5IHRvIHN0cnVjdHVyZSBhbmFseXNpc1xuICAgIHNldEltcG9ydFN0ZXAoJ2NvbmZpZ3VyZScpO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gQXJyYXkuZnJvbShzdGF0ZS5maWxlcy5rZXlzKCkpWzBdO1xuICAgIGNvbnN0IGZpbGUgPSBzdGF0ZS5maWxlcy5nZXQoZmlsZU5hbWUpO1xuXG4gICAgaWYgKGZpbGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbVUldIGluaXRpYXRlRmxleGlibGVJbXBvcnQgKHNpbmdsZSBmaWxlKSAtIHNlbmRpbmcgYW5hbHl6ZS1zdHJ1Y3R1cmUgZm9yOicsIGZpbGVOYW1lKTtcbiAgICAgIHNlbmRNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ2FuYWx5emUtc3RydWN0dXJlJyxcbiAgICAgICAgZmlsZU5hbWUsXG4gICAgICAgIGpzb25EYXRhOiBmaWxlLmNvbnRlbnRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbVUldIEZpbGUgbm90IGZvdW5kIGZvciBhbmFseXNpczonLCBmaWxlTmFtZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNvbGxlY3Rpb25zIGxvYWRlZCBmcm9tIEZpZ21hXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUNvbGxlY3Rpb25zTG9hZGVkKGNvbGxlY3Rpb25zOiBBcnJheTx7IGlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZzsgdmFyaWFibGVDb3VudDogbnVtYmVyOyBtb2RlQ291bnQ6IG51bWJlciB9Pik6IHZvaWQge1xuICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG5cbiAgLy8gQXV0by1zZWxlY3QgYWxsIGJ5IGRlZmF1bHRcbiAgY29uc3Qgc2VsZWN0ZWRFeHBvcnQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3Qgc2VsZWN0ZWRTeW5jID0gbmV3IFNldDxzdHJpbmc+KCk7XG5cbiAgY29sbGVjdGlvbnMuZm9yRWFjaChjb2wgPT4ge1xuICAgIHNlbGVjdGVkRXhwb3J0LmFkZChjb2wuaWQpO1xuICAgIHNlbGVjdGVkU3luYy5hZGQoY29sLmlkKTtcbiAgfSk7XG5cbiAgc2V0U3RhdGUoe1xuICAgIGZpZ21hQ29sbGVjdGlvbnM6IGNvbGxlY3Rpb25zLFxuICAgIHNlbGVjdGVkRXhwb3J0Q29sbGVjdGlvbnM6IHNlbGVjdGVkRXhwb3J0LFxuICAgIHNlbGVjdGVkU3luY0NvbGxlY3Rpb25zOiBzZWxlY3RlZFN5bmNcbiAgfSk7XG5cbiAgLy8gVHJpZ2dlciByZS1yZW5kZXIgb2YgY29sbGVjdGlvbiBsaXN0c1xuICBjb25zdCByZW5kZXJFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29sbGVjdGlvbnMtbG9hZGVkJyk7XG4gIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQocmVuZGVyRXZlbnQpO1xuXG4gIHVwZGF0ZUFjdGlvbkJ1dHRvbigpO1xufVxuXG4vKipcbiAqIFNob3cgbm90aWZpY2F0aW9uIHRvIHVzZXJcbiAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gZGlzcGxheVxuICogQHBhcmFtIHR5cGUgLSBUaGUgbm90aWZpY2F0aW9uIHR5cGVcbiAqL1xuZnVuY3Rpb24gc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlOiBzdHJpbmcsIHR5cGU6ICdlcnJvcicgfCAnc3VjY2VzcycgfCAnaW5mbycgPSAnaW5mbycpOiB2b2lkIHtcbiAgLy8gU2ltcGxlIGFsZXJ0IGZvciBub3cgLSBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIHRvYXN0IGNvbXBvbmVudFxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gIH1cbiAgYWxlcnQobWVzc2FnZSk7XG59XG5cbi8vIEluaXRpYWxpemUgd2hlbiBET00gaXMgcmVhZHlcbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGluaXRpYWxpemVVSSk7XG59IGVsc2Uge1xuICBpbml0aWFsaXplVUkoKTtcbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0ZBLE1BQU0sZUFBeUI7QUFBQSxJQUM3QixPQUFPLG9CQUFJLElBQUk7QUFBQSxJQUNmLGFBQWEsQ0FBQztBQUFBLElBQ2QsWUFBWTtBQUFBLElBQ1osa0JBQWtCLENBQUM7QUFBQSxJQUNuQiwyQkFBMkIsb0JBQUksSUFBSTtBQUFBLElBQ25DLHlCQUF5QixvQkFBSSxJQUFJO0FBQUEsRUFDbkM7QUFLQSxNQUFJLFFBQWtCLG1CQUFLO0FBSzNCLE1BQU0sWUFBZ0Msb0JBQUksSUFBSTtBQUt2QyxXQUFTLFdBQStCO0FBQzdDLFdBQU87QUFBQSxFQUNUO0FBTU8sV0FBUyxTQUFTLFNBQWtDO0FBQ3pELFlBQVEsa0NBQUssUUFBVTtBQUN2QixvQkFBZ0I7QUFBQSxFQUNsQjtBQW9CTyxXQUFTLGNBQWMsTUFBd0I7QUFDcEQsYUFBUyxFQUFFLG1CQUFtQixLQUFLLENBQUM7QUFBQSxF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QUFBQSxJQUMzQixDQUFDO0FBR0QsVUFBTSxjQUFjLElBQUksWUFBWSxvQkFBb0I7QUFDeEQsYUFBUyxjQUFjLFdBQVc7QUFFbEMsdUJBQW1CO0FBQUEsRUFDckI7QUFPQSxXQUFTRCxrQkFBaUIsU0FBaUIsT0FBcUMsUUFBYztBQUU1RixRQUFJLFNBQVMsU0FBUztBQUNwQixjQUFRLE1BQU0sT0FBTztBQUFBLElBQ3ZCLE9BQU87QUFDTCxjQUFRLElBQUksT0FBTztBQUFBLElBQ3JCO0FBQ0EsVUFBTSxPQUFPO0FBQUEsRUFDZjtBQUdBLE1BQUksU0FBUyxlQUFlLFdBQVc7QUFDckMsYUFBUyxpQkFBaUIsb0JBQW9CLFlBQVk7QUFBQSxFQUM1RCxPQUFPO0FBQ0wsaUJBQWE7QUFBQSxFQUNmOyIsCiAgIm5hbWVzIjogWyJzdGF0ZSIsICJzdGF0ZSIsICJzdGF0ZSIsICJlc2NhcGVIdG1sIiwgImVzY2FwZUh0bWwiLCAiZm9ybWF0RGF0ZSIsICJzdGF0ZSIsICJzaG93Tm90aWZpY2F0aW9uIiwgImVzY2FwZUh0bWwiLCAicmVuZGVyQ2hhbmdlU2VjdGlvbiIsICJlc2NhcGVIdG1sIiwgImVzY2FwZUh0bWwiLCAic3RhdGUiLCAiZXNjYXBlSHRtbCIsICJmb3JtYXRGaWxlU2l6ZSIsICJleHRyYWN0TW9kZU5hbWVGcm9tRmlsZW5hbWUiLCAiZXNjYXBlSHRtbCIsICJleHRyYWN0TW9kZU5hbWVGcm9tRmlsZW5hbWUiLCAic3RhdGUiLCAiaGFuZGxlSW1wb3J0QWxsIiwgInJlbmRlck1vZGVOYW1lc0xpc3QiLCAiZXNjYXBlSHRtbCIsICJoYW5kbGVNb2RlU3RyYXRlZ3lDaGFuZ2UiLCAiaGFuZGxlTW9kZU5hbWVDaGFuZ2UiLCAiZXNjYXBlSHRtbCIsICJzaG93Tm90aWZpY2F0aW9uIiwgInN0YXRlIl0KfQo=

  </script>
</body>
</html>
