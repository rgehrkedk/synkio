import { describe, it, expect } from 'vitest';
import { generateTokensCSS, generateUtilitiesCSS } from './index.js';
import type { ParsedToken } from '../docs/index.js';

describe('generateTokensCSS', () => {
  describe('basic generation', () => {
    it('should generate CSS custom properties in :root', () => {
      const tokens: ParsedToken[] = [
        {
          path: 'colors.primary',
          value: '#ff0000',
          type: 'color',
          collection: 'theme',
          mode: 'light',
          cssVariable: '--colors-primary',
        },
      ];

      const result = generateTokensCSS(tokens, ['light']);

      expect(result).toContain(':root {');
      expect(result).toContain('--colors-primary: #ff0000;');
      expect(result).toContain('}');
    });

    it('should include description as comment', () => {
      const tokens: ParsedToken[] = [
        {
          path: 'colors.brand',
          value: '#0000ff',
          type: 'color',
          collection: 'theme',
          mode: 'light',
          cssVariable: '--colors-brand',
          description: 'Brand primary color',
        },
      ];

      const result = generateTokensCSS(tokens, ['light']);

      expect(result).toContain('--colors-brand: #0000ff; /* Brand primary color */');
    });

    it('should include header comments', () => {
      const tokens: ParsedToken[] = [];

      const result = generateTokensCSS(tokens, []);

      expect(result).toContain('Design Tokens - CSS Custom Properties');
      expect(result).toContain('Generated by Synkio');
    });
  });

  describe('multi-mode support', () => {
    it('should use first mode as :root default', () => {
      const tokens: ParsedToken[] = [
        {
          path: 'colors.bg',
          value: '#ffffff',
          type: 'color',
          collection: 'theme',
          mode: 'light',
          cssVariable: '--colors-bg',
        },
        {
          path: 'colors.bg',
          value: '#000000',
          type: 'color',
          collection: 'theme',
          mode: 'dark',
          cssVariable: '--colors-bg',
        },
      ];

      const result = generateTokensCSS(tokens, ['light', 'dark']);

      expect(result).toContain(':root {');
      expect(result).toContain('--colors-bg: #ffffff;');
    });

    it('should generate data-mode selectors for non-default modes', () => {
      const tokens: ParsedToken[] = [
        {
          path: 'colors.bg',
          value: '#ffffff',
          type: 'color',
          collection: 'theme',
          mode: 'light',
          cssVariable: '--colors-bg',
        },
        {
          path: 'colors.bg',
          value: '#000000',
          type: 'color',
          collection: 'theme',
          mode: 'dark',
          cssVariable: '--colors-bg',
        },
      ];

      const result = generateTokensCSS(tokens, ['light', 'dark']);

      expect(result).toContain('[data-mode="dark"] {');
      expect(result).toContain('--colors-bg: #000000;');
    });

    it('should handle multiple alternate modes', () => {
      const tokens: ParsedToken[] = [
        { path: 'a', value: 1, type: 'number', collection: 'c', mode: 'default', cssVariable: '--a' },
        { path: 'a', value: 2, type: 'number', collection: 'c', mode: 'alt1', cssVariable: '--a' },
        { path: 'a', value: 3, type: 'number', collection: 'c', mode: 'alt2', cssVariable: '--a' },
      ];

      const result = generateTokensCSS(tokens, ['default', 'alt1', 'alt2']);

      expect(result).toContain(':root {');
      expect(result).toContain('[data-mode="alt1"] {');
      expect(result).toContain('[data-mode="alt2"] {');
    });
  });

  describe('color transforms', () => {
    it('should pass through hex colors', () => {
      const tokens: ParsedToken[] = [
        { path: 'c', value: '#aabbcc', type: 'color', collection: 'c', mode: 'm', cssVariable: '--c' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--c: #aabbcc;');
    });

    it('should pass through rgb/rgba strings', () => {
      const tokens: ParsedToken[] = [
        { path: 'c', value: 'rgba(255, 0, 0, 0.5)', type: 'color', collection: 'c', mode: 'm', cssVariable: '--c' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--c: rgba(255, 0, 0, 0.5);');
    });

    it('should convert Figma color objects to hex', () => {
      const tokens: ParsedToken[] = [
        {
          path: 'c',
          value: { r: 1, g: 0.5, b: 0, a: 1 },
          type: 'color',
          collection: 'c',
          mode: 'm',
          cssVariable: '--c',
        },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--c: #ff8000;');
    });

    it('should convert Figma color objects with alpha to rgba', () => {
      const tokens: ParsedToken[] = [
        {
          path: 'c',
          value: { r: 1, g: 0, b: 0, a: 0.5 },
          type: 'color',
          collection: 'c',
          mode: 'm',
          cssVariable: '--c',
        },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('rgba(255, 0, 0, 0.5)');
    });
  });

  describe('dimension transforms', () => {
    it('should add px unit to numeric dimensions', () => {
      const tokens: ParsedToken[] = [
        { path: 's', value: 16, type: 'dimension', collection: 'c', mode: 'm', cssVariable: '--s' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--s: 16px;');
    });

    it('should convert to rem when useRem option is true', () => {
      const tokens: ParsedToken[] = [
        { path: 's', value: 32, type: 'dimension', collection: 'c', mode: 'm', cssVariable: '--s' },
      ];

      const result = generateTokensCSS(tokens, ['m'], { useRem: true, basePxFontSize: 16 });

      expect(result).toContain('--s: 2rem;');
    });

    it('should use custom base font size for rem calculation', () => {
      const tokens: ParsedToken[] = [
        { path: 's', value: 20, type: 'dimension', collection: 'c', mode: 'm', cssVariable: '--s' },
      ];

      const result = generateTokensCSS(tokens, ['m'], { useRem: true, basePxFontSize: 10 });

      expect(result).toContain('--s: 2rem;');
    });

    it('should output 0 without unit', () => {
      const tokens: ParsedToken[] = [
        { path: 's', value: 0, type: 'dimension', collection: 'c', mode: 'm', cssVariable: '--s' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--s: 0;');
    });

    it('should preserve existing units in string values', () => {
      const tokens: ParsedToken[] = [
        { path: 's', value: '2rem', type: 'dimension', collection: 'c', mode: 'm', cssVariable: '--s' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--s: 2rem;');
    });

    it('should handle spacing type like dimension', () => {
      const tokens: ParsedToken[] = [
        { path: 's', value: 8, type: 'spacing', collection: 'c', mode: 'm', cssVariable: '--s' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--s: 8px;');
    });

    it('should handle borderRadius type', () => {
      const tokens: ParsedToken[] = [
        { path: 'r', value: 4, type: 'borderRadius', collection: 'c', mode: 'm', cssVariable: '--r' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--r: 4px;');
    });
  });

  describe('font transforms', () => {
    it('should quote font families with spaces', () => {
      const tokens: ParsedToken[] = [
        { path: 'f', value: 'Open Sans', type: 'fontFamily', collection: 'c', mode: 'm', cssVariable: '--f' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--f: "Open Sans";');
    });

    it('should not quote generic font families', () => {
      const tokens: ParsedToken[] = [
        { path: 'f', value: 'sans-serif', type: 'fontFamily', collection: 'c', mode: 'm', cssVariable: '--f' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--f: sans-serif;');
    });

    it('should handle font family arrays', () => {
      const tokens: ParsedToken[] = [
        {
          path: 'f',
          value: ['Inter', 'Helvetica Neue', 'sans-serif'],
          type: 'fontFamily',
          collection: 'c',
          mode: 'm',
          cssVariable: '--f',
        },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--f: Inter, "Helvetica Neue", sans-serif;');
    });

    it('should convert font weight names to numbers', () => {
      const tokens: ParsedToken[] = [
        { path: 'w', value: 'bold', type: 'fontWeight', collection: 'c', mode: 'm', cssVariable: '--w' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--w: 700;');
    });

    it('should handle various font weight names', () => {
      const weights = [
        { input: 'thin', expected: '100' },
        { input: 'light', expected: '300' },
        { input: 'regular', expected: '400' },
        { input: 'medium', expected: '500' },
        { input: 'semibold', expected: '600' },
        { input: 'bold', expected: '700' },
        { input: 'black', expected: '900' },
      ];

      for (const { input, expected } of weights) {
        const tokens: ParsedToken[] = [
          { path: 'w', value: input, type: 'fontWeight', collection: 'c', mode: 'm', cssVariable: '--w' },
        ];

        const result = generateTokensCSS(tokens, ['m']);

        expect(result).toContain(`--w: ${expected};`);
      }
    });

    it('should pass through numeric font weights', () => {
      const tokens: ParsedToken[] = [
        { path: 'w', value: 500, type: 'fontWeight', collection: 'c', mode: 'm', cssVariable: '--w' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--w: 500;');
    });
  });

  describe('other token types', () => {
    it('should handle duration/time with ms unit', () => {
      const tokens: ParsedToken[] = [
        { path: 'd', value: 200, type: 'duration', collection: 'c', mode: 'm', cssVariable: '--d' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--d: 200ms;');
    });

    it('should handle opacity as plain number', () => {
      const tokens: ParsedToken[] = [
        { path: 'o', value: 0.5, type: 'opacity', collection: 'c', mode: 'm', cssVariable: '--o' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--o: 0.5;');
    });

    it('should handle line height as plain number', () => {
      const tokens: ParsedToken[] = [
        { path: 'lh', value: 1.5, type: 'lineHeight', collection: 'c', mode: 'm', cssVariable: '--lh' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--lh: 1.5;');
    });

    it('should handle null/undefined values as inherit', () => {
      const tokens: ParsedToken[] = [
        { path: 'n', value: null, type: 'color', collection: 'c', mode: 'm', cssVariable: '--n' },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--n: inherit;');
    });
  });

  describe('type inference from path', () => {
    it('should infer color type from path containing "color"', () => {
      const tokens: ParsedToken[] = [
        {
          path: 'background.color',
          value: { r: 1, g: 1, b: 1, a: 1 },
          type: 'number', // Generic type
          collection: 'c',
          mode: 'm',
          cssVariable: '--bg-color',
        },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--bg-color: #ffffff;');
    });

    it('should infer dimension type from path containing "spacing"', () => {
      const tokens: ParsedToken[] = [
        {
          path: 'spacing.large',
          value: 24,
          type: 'number', // Generic type
          collection: 'c',
          mode: 'm',
          cssVariable: '--spacing-large',
        },
      ];

      const result = generateTokensCSS(tokens, ['m']);

      expect(result).toContain('--spacing-large: 24px;');
    });
  });
});

describe('generateUtilitiesCSS', () => {
  it('should generate color utilities', () => {
    const tokens: ParsedToken[] = [
      { path: 'colors.primary', value: '#ff0000', type: 'color', collection: 'c', mode: 'm', cssVariable: '--colors-primary' },
    ];

    const result = generateUtilitiesCSS(tokens);

    expect(result).toContain('.text-colors-primary { color: var(--colors-primary); }');
    expect(result).toContain('.bg-colors-primary { background-color: var(--colors-primary); }');
    expect(result).toContain('.border-colors-primary { border-color: var(--colors-primary); }');
  });

  it('should generate spacing utilities', () => {
    const tokens: ParsedToken[] = [
      { path: 'spacing.md', value: 16, type: 'spacing', collection: 'c', mode: 'm', cssVariable: '--spacing-md' },
    ];

    const result = generateUtilitiesCSS(tokens);

    expect(result).toContain('.p-spacing-md { padding: var(--spacing-md); }');
    expect(result).toContain('.px-spacing-md { padding-left: var(--spacing-md); padding-right: var(--spacing-md); }');
    expect(result).toContain('.m-spacing-md { margin: var(--spacing-md); }');
    expect(result).toContain('.gap-spacing-md { gap: var(--spacing-md); }');
  });

  it('should generate font size utilities', () => {
    const tokens: ParsedToken[] = [
      { path: 'text.lg', value: 18, type: 'fontSize', collection: 'c', mode: 'm', cssVariable: '--text-lg' },
    ];

    const result = generateUtilitiesCSS(tokens);

    expect(result).toContain('.text-text-lg { font-size: var(--text-lg); }');
  });

  it('should generate font family utilities', () => {
    const tokens: ParsedToken[] = [
      { path: 'font.sans', value: 'Inter', type: 'fontFamily', collection: 'c', mode: 'm', cssVariable: '--font-sans' },
    ];

    const result = generateUtilitiesCSS(tokens);

    expect(result).toContain('.font-font-sans { font-family: var(--font-sans); }');
  });

  it('should generate border radius utilities', () => {
    const tokens: ParsedToken[] = [
      { path: 'radius.md', value: 8, type: 'borderRadius', collection: 'c', mode: 'm', cssVariable: '--radius-md' },
    ];

    const result = generateUtilitiesCSS(tokens);

    expect(result).toContain('.rounded-radius-md { border-radius: var(--radius-md); }');
  });

  it('should generate shadow utilities', () => {
    const tokens: ParsedToken[] = [
      { path: 'shadow.md', value: '0 4px 8px rgba(0,0,0,0.1)', type: 'boxShadow', collection: 'c', mode: 'm', cssVariable: '--shadow-md' },
    ];

    const result = generateUtilitiesCSS(tokens);

    expect(result).toContain('.shadow-shadow-md { box-shadow: var(--shadow-md); }');
  });

  it('should include header comments', () => {
    const tokens: ParsedToken[] = [];

    const result = generateUtilitiesCSS(tokens);

    expect(result).toContain('Utility Classes - Generated from Design Tokens');
  });

  it('should lowercase class names', () => {
    const tokens: ParsedToken[] = [
      { path: 'Colors.Primary', value: '#ff0000', type: 'color', collection: 'c', mode: 'm', cssVariable: '--colors-primary' },
    ];

    const result = generateUtilitiesCSS(tokens);

    expect(result).toContain('.text-colors-primary');
    expect(result).not.toContain('.text-Colors-Primary');
  });

  it('should replace dots with dashes in class names', () => {
    const tokens: ParsedToken[] = [
      { path: 'colors.brand.primary', value: '#ff0000', type: 'color', collection: 'c', mode: 'm', cssVariable: '--colors-brand-primary' },
    ];

    const result = generateUtilitiesCSS(tokens);

    expect(result).toContain('.text-colors-brand-primary');
  });
});
