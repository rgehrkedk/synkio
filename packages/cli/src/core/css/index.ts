/**
 * CSS Token Generator
 * 
 * Generates CSS Custom Properties from design tokens.
 * Zero external dependencies - works standalone.
 */

import { ParsedToken } from '../docs/index.js';

/**
 * CSS Transform Options
 */
export interface CSSTransformOptions {
  basePxFontSize?: number;  // Base font size for rem calculations (default: 16)
  useRem?: boolean;         // Use rem instead of px for dimensions (default: false)
}

/**
 * Generate CSS Custom Properties from tokens
 * Groups by mode for theme switching support
 */
export function generateTokensCSS(
  tokens: ParsedToken[], 
  modes: string[],
  options: CSSTransformOptions = {}
): string {
  const lines: string[] = [
    '/**',
    ' * Design Tokens - CSS Custom Properties',
    ' * Generated by Synkio',
    ' * https://github.com/rgehrkedk/synkio',
    ' */',
    '',
  ];

  // Group tokens by mode
  const tokensByMode = new Map<string, ParsedToken[]>();
  for (const token of tokens) {
    if (!tokensByMode.has(token.mode)) {
      tokensByMode.set(token.mode, []);
    }
    tokensByMode.get(token.mode)!.push(token);
  }

  // Generate :root with first mode as default
  const defaultMode = modes[0] || 'default';
  const defaultTokens = tokensByMode.get(defaultMode) || [];
  
  lines.push(
    ':root {',
    ...defaultTokens.map(token => {
      const cssValue = formatCSSValue(token.value, token.type, options, token.path);
      const comment = token.description ? ` /* ${token.description} */` : '';
      return `  ${token.cssVariable}: ${cssValue};${comment}`;
    }),
    '}',
    ''
  );

  // Generate mode-specific overrides using data attributes
  for (const [mode, modeTokens] of tokensByMode) {
    if (mode === defaultMode) continue;
    
    lines.push(
      `[data-mode="${mode}"] {`,
      ...modeTokens.map(token => {
        const cssValue = formatCSSValue(token.value, token.type, options, token.path);
        return `  ${token.cssVariable}: ${cssValue};`;
      }),
      '}',
      ''
    );
  }

  return lines.join('\n');
}

/**
 * Generate utility CSS classes from tokens
 */
export function generateUtilitiesCSS(tokens: ParsedToken[]): string {
  const lines: string[] = [
    '/**',
    ' * Utility Classes - Generated from Design Tokens',
    ' * Generated by Synkio',
    ' */',
    '',
  ];

  for (const token of tokens) {
    const className = token.path.replaceAll('.', '-').toLowerCase();
    
    switch (token.type.toLowerCase()) {
      case 'color':
        lines.push(
          `.text-${className} { color: var(${token.cssVariable}); }`,
          `.bg-${className} { background-color: var(${token.cssVariable}); }`,
          `.border-${className} { border-color: var(${token.cssVariable}); }`
        );
        break;
        
      case 'fontsize':
        lines.push(`.text-${className} { font-size: var(${token.cssVariable}); }`);
        break;
        
      case 'fontfamily':
        lines.push(`.font-${className} { font-family: var(${token.cssVariable}); }`);
        break;
        
      case 'fontweight':
        lines.push(`.font-${className} { font-weight: var(${token.cssVariable}); }`);
        break;
        
      case 'lineheight':
        lines.push(`.leading-${className} { line-height: var(${token.cssVariable}); }`);
        break;
        
      case 'letterspacing':
        lines.push(`.tracking-${className} { letter-spacing: var(${token.cssVariable}); }`);
        break;
        
      case 'dimension':
      case 'spacing':
      case 'size':
      case 'number':
        lines.push(
          `.p-${className} { padding: var(${token.cssVariable}); }`,
          `.px-${className} { padding-left: var(${token.cssVariable}); padding-right: var(${token.cssVariable}); }`,
          `.py-${className} { padding-top: var(${token.cssVariable}); padding-bottom: var(${token.cssVariable}); }`,
          `.m-${className} { margin: var(${token.cssVariable}); }`,
          `.mx-${className} { margin-left: var(${token.cssVariable}); margin-right: var(${token.cssVariable}); }`,
          `.my-${className} { margin-top: var(${token.cssVariable}); margin-bottom: var(${token.cssVariable}); }`,
          `.gap-${className} { gap: var(${token.cssVariable}); }`
        );
        break;
        
      case 'borderradius':
        lines.push(`.rounded-${className} { border-radius: var(${token.cssVariable}); }`);
        break;
        
      case 'boxshadow':
        lines.push(`.shadow-${className} { box-shadow: var(${token.cssVariable}); }`);
        break;
    }
  }

  return lines.join('\n');
}

// ============================================================================
// VALUE TRANSFORMS
// ============================================================================

/**
 * Format a value for CSS output
 */
function formatCSSValue(value: any, type: string, options: CSSTransformOptions = {}, path?: string): string {
  if (value === null || value === undefined) {
    return 'inherit';
  }

  const resolvedType = inferTypeFromPath(type, path);
  const tokenType = resolvedType.toLowerCase();

  switch (tokenType) {
    case 'color':
      return transformColor(value);
    case 'dimension':
    case 'spacing':
    case 'size':
    case 'borderradius':
    case 'radius':
    case 'fontsize':
    case 'letterspacing':
      return transformDimension(value, options);
    case 'fontfamily':
      return transformFontFamily(value);
    case 'fontweight':
      return transformFontWeight(value);
    case 'lineheight':
      return String(roundNumber(Number(value)));
    case 'duration':
    case 'time':
      return typeof value === 'number' ? `${value}ms` : String(value);
    case 'opacity':
    case 'number':
    case 'float':
      return String(roundNumber(Number(value)));
    default:
      return String(value);
  }
}

/**
 * Infer token type from path when type is generic (number/float)
 */
function inferTypeFromPath(type: string, path?: string): string {
  const genericTypes = ['number', 'float', 'boolean'];
  if (!genericTypes.includes(type.toLowerCase()) || !path) {
    return type;
  }

  const pathLower = path.toLowerCase();
  
  if (/\b(color|background|foreground|fill|stroke|border-color)\b/.test(pathLower)) return 'color';
  if (/\b(spacing|space|gap|padding|margin|size|width|height|radius|inset|offset|blur)\b/.test(pathLower)) return 'dimension';
  if (/\b(font-?size|text-?size)\b/.test(pathLower)) return 'fontSize';
  if (/\b(font-?family|typeface)\b/.test(pathLower)) return 'fontFamily';
  if (/\b(font-?weight|weight)\b/.test(pathLower)) return 'fontWeight';
  if (/\b(line-?height|leading)\b/.test(pathLower)) return 'lineHeight';
  if (/\b(letter-?spacing|tracking)\b/.test(pathLower)) return 'letterSpacing';
  if (/\b(shadow|elevation)\b/.test(pathLower)) return 'shadow';
  if (/\b(duration|delay|timing)\b/.test(pathLower)) return 'duration';
  if (/\b(opacity|alpha)\b/.test(pathLower)) return 'opacity';
  
  return type;
}

/**
 * Transform color values (handles Figma color objects)
 */
function transformColor(value: any): string {
  if (typeof value === 'string') return value;
  
  if (typeof value === 'object' && value !== null) {
    if ('r' in value && 'g' in value && 'b' in value) {
      const r = Math.round((value.r ?? 0) * 255);
      const g = Math.round((value.g ?? 0) * 255);
      const b = Math.round((value.b ?? 0) * 255);
      const a = value.a ?? 1;
      
      if (a === 1) return rgbToHex(r, g, b);
      return `rgba(${r}, ${g}, ${b}, ${roundNumber(a)})`;
    }
  }
  
  return String(value);
}

/**
 * Transform dimension values (adds px/rem units)
 */
function transformDimension(value: any, options: CSSTransformOptions = {}): string {
  const { basePxFontSize = 16, useRem = false } = options;
  
  if (typeof value === 'number') {
    if (value === 0) return '0';
    if (useRem) return `${roundNumber(value / basePxFontSize)}rem`;
    return `${value}px`;
  }
  
  if (typeof value === 'string') {
    if (hasUnit(value)) return value;
    const num = Number.parseFloat(value);
    if (!Number.isNaN(num)) {
      if (num === 0) return '0';
      if (useRem) return `${roundNumber(num / basePxFontSize)}rem`;
      return `${num}px`;
    }
  }
  
  return String(value);
}

/**
 * Transform font family values
 */
function transformFontFamily(value: any): string {
  if (Array.isArray(value)) return value.map(quoteIfNeeded).join(', ');
  if (typeof value === 'string') return value.split(',').map(f => quoteIfNeeded(f.trim())).join(', ');
  return String(value);
}

/**
 * Transform font weight values
 */
function transformFontWeight(value: any): string {
  const weightMap: Record<string, number> = {
    thin: 100, hairline: 100, extralight: 200, ultralight: 200, light: 300,
    regular: 400, normal: 400, medium: 500, semibold: 600, demibold: 600,
    bold: 700, extrabold: 800, ultrabold: 800, black: 900, heavy: 900,
  };
  
  if (typeof value === 'number') return String(value);
  if (typeof value === 'string') {
    const normalized = value.toLowerCase().replaceAll(/[\s\-_]/g, '');
    if (weightMap[normalized]) return String(weightMap[normalized]);
  }
  return String(value);
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function rgbToHex(r: number, g: number, b: number): string {
  return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
}

function roundNumber(num: number, decimals: number = 4): number {
  return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
}

function hasUnit(value: string): boolean {
  return /\d(px|rem|em|%|vh|vw|pt|ch|ex|vmin|vmax|cm|mm|in|pc)$/i.test(value);
}

function quoteIfNeeded(fontName: string): string {
  const unquoted = fontName.replaceAll(/(?:^['"])|(?:['"]$)/g, '');
  const genericFonts = ['serif', 'sans-serif', 'monospace', 'cursive', 'fantasy', 'system-ui'];
  if (genericFonts.includes(unquoted.toLowerCase())) return unquoted;
  if (/\s/.test(unquoted)) return `"${unquoted}"`;
  return unquoted;
}
