/**
 * JavaScript/TypeScript Generator
 * 
 * Generates JS/TS files with token exports.
 * Supports nested objects, flat exports, and TypeScript type definitions.
 */

import { ParsedToken } from '../docs/index.js';
import { transformForCSS, transformForReactNative, CSSTransformOptions } from '../transforms/index.js';
import { pathToCamelCase } from '../transforms/utils.js';

export interface JSGeneratorOptions extends CSSTransformOptions {
  /** Output format: 'nested' creates object hierarchy, 'flat' creates individual exports */
  format?: 'nested' | 'flat';
  /** Generate TypeScript with type definitions */
  typescript?: boolean;
  /** Use React Native transforms (unitless numbers) */
  reactNative?: boolean;
  /** Export format: 'esm' for ES modules, 'cjs' for CommonJS */
  moduleFormat?: 'esm' | 'cjs';
  /** Use const assertions for literal types in TypeScript */
  constAssertion?: boolean;
}

/**
 * Generate JavaScript/TypeScript from tokens
 */
export function generateJS(
  tokens: ParsedToken[],
  modes: string[],
  options: JSGeneratorOptions = {}
): string {
  const {
    format = 'nested',
    typescript = false,
    reactNative = false,
    moduleFormat = 'esm',
    constAssertion = true,
  } = options;

  const lines: string[] = [
    '/**',
    ' * Design Tokens',
    ' * Generated by Synkio',
    ' * https://github.com/rgehrkedk/synkio',
    typescript ? ' * @generated' : '',
    ' */',
    '',
  ].filter(Boolean);

  // Group tokens by mode
  const tokensByMode = new Map<string, ParsedToken[]>();
  for (const token of tokens) {
    if (!tokensByMode.has(token.mode)) {
      tokensByMode.set(token.mode, []);
    }
    tokensByMode.get(token.mode)!.push(token);
  }

  const defaultMode = modes[0] || 'default';
  const defaultTokens = tokensByMode.get(defaultMode) || [];

  if (format === 'nested') {
    const content = generateNestedFormat(defaultTokens, options);
    lines.push(content);
  } else {
    const content = generateFlatFormat(defaultTokens, options);
    lines.push(content);
  }

  // Generate mode-specific exports
  for (const [mode, modeTokens] of tokensByMode) {
    if (mode === defaultMode) continue;
    
    lines.push('');
    lines.push(`// ${mode} mode overrides`);
    
    if (format === 'nested') {
      const varName = `tokens${capitalize(mode)}`;
      const content = generateNestedObject(modeTokens, options);
      if (moduleFormat === 'esm') {
        lines.push(`export const ${varName} = ${content}${constAssertion && typescript ? ' as const' : ''};`);
      } else {
        lines.push(`const ${varName} = ${content};`);
      }
    } else {
      // Flat format with mode suffix
      for (const token of modeTokens) {
        const varName = pathToCamelCase(token.path) + capitalize(mode);
        const value = formatJSValue(token, options);
        if (moduleFormat === 'esm') {
          lines.push(`export const ${varName} = ${value};`);
        } else {
          lines.push(`const ${varName} = ${value};`);
        }
      }
    }
  }

  // CommonJS exports
  if (moduleFormat === 'cjs') {
    lines.push('');
    lines.push('module.exports = {');
    lines.push('  tokens,');
    for (const [mode] of tokensByMode) {
      if (mode !== defaultMode) {
        lines.push(`  tokens${capitalize(mode)},`);
      }
    }
    lines.push('};');
  }

  return lines.join('\n');
}

/**
 * Generate nested object format
 */
function generateNestedFormat(tokens: ParsedToken[], options: JSGeneratorOptions): string {
  const { moduleFormat = 'esm', typescript = false, constAssertion = true } = options;
  
  const content = generateNestedObject(tokens, options);
  
  if (moduleFormat === 'esm') {
    const assertion = constAssertion && typescript ? ' as const' : '';
    return `export const tokens = ${content}${assertion};`;
  } else {
    return `const tokens = ${content};`;
  }
}

/**
 * Generate a nested object from tokens
 */
function generateNestedObject(tokens: ParsedToken[], options: JSGeneratorOptions): string {
  const root: any = {};
  
  for (const token of tokens) {
    const parts = token.path.split('.');
    let current = root;
    
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }
    
    const lastPart = parts[parts.length - 1];
    current[lastPart] = getRawValue(token, options);
  }
  
  return formatObject(root, 0);
}

/**
 * Format an object as indented JavaScript
 */
function formatObject(obj: any, indent: number): string {
  const spaces = '  '.repeat(indent);
  const innerSpaces = '  '.repeat(indent + 1);
  
  if (typeof obj !== 'object' || obj === null) {
    return formatPrimitive(obj);
  }
  
  const entries = Object.entries(obj);
  if (entries.length === 0) {
    return '{}';
  }
  
  const lines = entries.map(([key, value]) => {
    const formattedKey = isValidIdentifier(key) ? key : `'${key}'`;
    const formattedValue = typeof value === 'object' && value !== null
      ? formatObject(value, indent + 1)
      : formatPrimitive(value);
    return `${innerSpaces}${formattedKey}: ${formattedValue},`;
  });
  
  return `{\n${lines.join('\n')}\n${spaces}}`;
}

/**
 * Format a primitive value for JavaScript
 */
function formatPrimitive(value: any): string {
  if (typeof value === 'string') {
    return `'${value.replace(/'/g, "\\'")}'`;
  }
  if (typeof value === 'number') {
    return String(value);
  }
  if (typeof value === 'boolean') {
    return String(value);
  }
  if (value === null) {
    return 'null';
  }
  if (value === undefined) {
    return 'undefined';
  }
  return String(value);
}

/**
 * Generate flat export format
 */
function generateFlatFormat(tokens: ParsedToken[], options: JSGeneratorOptions): string {
  const { moduleFormat = 'esm' } = options;
  const lines: string[] = [];
  
  for (const token of tokens) {
    const varName = pathToCamelCase(token.path);
    const value = formatJSValue(token, options);
    
    if (moduleFormat === 'esm') {
      lines.push(`export const ${varName} = ${value};`);
    } else {
      lines.push(`const ${varName} = ${value};`);
    }
  }
  
  return lines.join('\n');
}

/**
 * Get the raw value for a token (transformed but not quoted)
 */
function getRawValue(token: ParsedToken, options: JSGeneratorOptions): string | number {
  const { reactNative = false } = options;
  
  if (reactNative) {
    return transformForReactNative({ value: token.value, type: token.type, path: token.path });
  }
  
  return transformForCSS({ value: token.value, type: token.type, path: token.path }, options);
}

/**
 * Format a token value for JavaScript output
 */
function formatJSValue(token: ParsedToken, options: JSGeneratorOptions): string {
  const value = getRawValue(token, options);
  
  if (typeof value === 'number') {
    return String(value);
  }
  
  return `'${String(value).replace(/'/g, "\\'")}'`;
}

/**
 * Check if a string is a valid JavaScript identifier
 */
function isValidIdentifier(str: string): boolean {
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(str);
}

/**
 * Capitalize the first letter of a string
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generate TypeScript type definitions
 */
export function generateTSTypes(
  tokens: ParsedToken[],
  modes: string[],
  options: JSGeneratorOptions = {}
): string {
  const lines: string[] = [
    '/**',
    ' * Design Token Types',
    ' * Generated by Synkio',
    ' */',
    '',
  ];

  // Generate the main tokens type
  const typeContent = generateTypeDefinition(tokens);
  lines.push(`export interface Tokens ${typeContent}`);
  lines.push('');

  // Generate mode types
  const defaultMode = modes[0] || 'default';
  for (const mode of modes) {
    if (mode === defaultMode) continue;
    lines.push(`export type Tokens${capitalize(mode)} = Partial<Tokens>;`);
  }

  return lines.join('\n');
}

/**
 * Generate TypeScript type definition from tokens
 */
function generateTypeDefinition(tokens: ParsedToken[]): string {
  const root: any = {};
  
  for (const token of tokens) {
    const parts = token.path.split('.');
    let current = root;
    
    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }
    
    const lastPart = parts[parts.length - 1];
    // Use string type for most values, number for specific types
    const valueType = isNumberType(token.type) ? 'number' : 'string';
    current[lastPart] = valueType;
  }
  
  return formatTypeObject(root, 0);
}

/**
 * Format a type object as indented TypeScript
 */
function formatTypeObject(obj: any, indent: number): string {
  const spaces = '  '.repeat(indent);
  const innerSpaces = '  '.repeat(indent + 1);
  
  if (typeof obj === 'string') {
    return obj;
  }
  
  const entries = Object.entries(obj);
  if (entries.length === 0) {
    return '{}';
  }
  
  const lines = entries.map(([key, value]) => {
    const formattedKey = isValidIdentifier(key) ? key : `'${key}'`;
    const formattedValue = typeof value === 'object'
      ? formatTypeObject(value, indent + 1)
      : value;
    return `${innerSpaces}${formattedKey}: ${formattedValue};`;
  });
  
  return `{\n${lines.join('\n')}\n${spaces}}`;
}

/**
 * Check if a token type should be a number in output
 */
function isNumberType(type: string): boolean {
  const numberTypes = ['number', 'float', 'opacity'];
  return numberTypes.includes(type.toLowerCase());
}
