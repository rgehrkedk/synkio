/**
 * Tailwind CSS Config Generator
 * 
 * Generates a Tailwind configuration file from design tokens.
 * Supports theme.extend format for easy integration.
 */

import { ParsedToken } from '../docs/index.js';
import { transformForCSS, CSSTransformOptions } from '../transforms/index.js';
import { inferTypeFromPath } from '../transforms/infer.js';

export interface TailwindGeneratorOptions extends CSSTransformOptions {
  /** Use theme.extend (true) or replace theme entirely (false) */
  extend?: boolean;
  /** Output as ES module (true) or CommonJS (false) */
  esm?: boolean;
  /** Include CSS variable references instead of raw values */
  cssVariables?: boolean;
}

/**
 * Token type to Tailwind config key mapping
 */
const TYPE_TO_TAILWIND_KEY: Record<string, string> = {
  color: 'colors',
  spacing: 'spacing',
  dimension: 'spacing',
  fontsize: 'fontSize',
  fontfamily: 'fontFamily',
  fontweight: 'fontWeight',
  lineheight: 'lineHeight',
  letterspacing: 'letterSpacing',
  borderradius: 'borderRadius',
  radius: 'borderRadius',
  shadow: 'boxShadow',
  duration: 'transitionDuration',
  opacity: 'opacity',
};

/**
 * Generate Tailwind configuration from tokens
 */
export function generateTailwindConfig(
  tokens: ParsedToken[],
  modes: string[],
  options: TailwindGeneratorOptions = {}
): string {
  const {
    extend = true,
    esm = true,
    cssVariables = false,
  } = options;

  // Group tokens by mode - only use default mode for Tailwind
  const defaultMode = modes[0] || 'default';
  const defaultTokens = tokens.filter(t => t.mode === defaultMode);

  // Build the theme object
  const theme = buildTailwindTheme(defaultTokens, options);

  // Generate the config
  const lines: string[] = [
    '/**',
    ' * Tailwind CSS Configuration',
    ' * Generated by Synkio',
    ' * https://github.com/rgehrkedk/synkio',
    ' */',
    '',
  ];

  if (esm) {
    lines.push('/** @type {import("tailwindcss").Config} */');
    lines.push('export default {');
  } else {
    lines.push('/** @type {import("tailwindcss").Config} */');
    lines.push('module.exports = {');
  }

  if (extend) {
    lines.push('  theme: {');
    lines.push('    extend: ' + formatObject(theme, 3) + ',');
    lines.push('  },');
  } else {
    lines.push('  theme: ' + formatObject(theme, 2) + ',');
  }

  lines.push('};');

  return lines.join('\n');
}

/**
 * Build a Tailwind theme object from tokens
 */
function buildTailwindTheme(
  tokens: ParsedToken[],
  options: TailwindGeneratorOptions
): Record<string, any> {
  const theme: Record<string, any> = {};
  const { cssVariables = false } = options;

  for (const token of tokens) {
    // Determine the Tailwind key based on token type and path
    const tailwindKey = getTailwindKey(token);
    if (!tailwindKey) continue;

    if (!theme[tailwindKey]) {
      theme[tailwindKey] = {};
    }

    // Build the nested structure
    const pathParts = token.path.split('.');
    // Skip the first part if it matches the Tailwind key (e.g., "color.primary.500")
    const keyParts = shouldSkipFirstPart(pathParts[0], tailwindKey)
      ? pathParts.slice(1)
      : pathParts;

    let current = theme[tailwindKey];
    for (let i = 0; i < keyParts.length - 1; i++) {
      const part = keyParts[i];
      if (!current[part]) {
        current[part] = {};
      }
      current = current[part];
    }

    const lastPart = keyParts[keyParts.length - 1] || 'DEFAULT';
    
    if (cssVariables) {
      current[lastPart] = `var(${token.cssVariable})`;
    } else {
      current[lastPart] = transformForCSS(
        { value: token.value, type: token.type, path: token.path },
        options
      );
    }
  }

  // Post-process: convert fontFamily arrays to Tailwind format
  if (theme.fontFamily) {
    for (const [key, value] of Object.entries(theme.fontFamily)) {
      if (typeof value === 'string') {
        // Split comma-separated fonts into array
        theme.fontFamily[key] = value.split(',').map(f => f.trim());
      }
    }
  }

  return theme;
}

/**
 * Get the Tailwind theme key for a token
 */
function getTailwindKey(token: ParsedToken): string | null {
  const inferredType = inferTypeFromPath(token.type, token.path);
  const lowerType = inferredType.toLowerCase();
  
  // Check explicit type mapping
  if (TYPE_TO_TAILWIND_KEY[lowerType]) {
    return TYPE_TO_TAILWIND_KEY[lowerType];
  }

  // Try to infer from path
  const firstPart = token.path.split('.')[0].toLowerCase();
  
  const pathMappings: Record<string, string> = {
    color: 'colors',
    colors: 'colors',
    spacing: 'spacing',
    space: 'spacing',
    font: 'fontFamily',
    fontsize: 'fontSize',
    fontweight: 'fontWeight',
    lineheight: 'lineHeight',
    letterspacing: 'letterSpacing',
    radius: 'borderRadius',
    borderradius: 'borderRadius',
    shadow: 'boxShadow',
    boxshadow: 'boxShadow',
    duration: 'transitionDuration',
    transition: 'transitionDuration',
    opacity: 'opacity',
    zindex: 'zIndex',
    breakpoint: 'screens',
    screen: 'screens',
  };

  return pathMappings[firstPart] || null;
}

/**
 * Check if first path part should be skipped (matches Tailwind key)
 */
function shouldSkipFirstPart(firstPart: string, tailwindKey: string): boolean {
  const skipMappings: Record<string, string[]> = {
    colors: ['color', 'colors'],
    spacing: ['spacing', 'space'],
    fontSize: ['fontsize', 'font-size'],
    fontFamily: ['fontfamily', 'font-family', 'font'],
    fontWeight: ['fontweight', 'font-weight'],
    lineHeight: ['lineheight', 'line-height', 'leading'],
    letterSpacing: ['letterspacing', 'letter-spacing', 'tracking'],
    borderRadius: ['radius', 'borderradius', 'border-radius', 'rounded'],
    boxShadow: ['shadow', 'boxshadow', 'box-shadow'],
    opacity: ['opacity'],
  };

  const skipWords = skipMappings[tailwindKey] || [];
  return skipWords.includes(firstPart.toLowerCase());
}

/**
 * Format an object as indented JavaScript
 */
function formatObject(obj: any, indent: number): string {
  const spaces = '  '.repeat(indent);
  const innerSpaces = '  '.repeat(indent + 1);

  if (typeof obj !== 'object' || obj === null) {
    return formatValue(obj);
  }

  if (Array.isArray(obj)) {
    if (obj.length === 0) return '[]';
    const items = obj.map(item => formatValue(item));
    return `[${items.join(', ')}]`;
  }

  const entries = Object.entries(obj);
  if (entries.length === 0) {
    return '{}';
  }

  const lines = entries.map(([key, value]) => {
    const formattedKey = isValidIdentifier(key) ? key : `'${key}'`;
    const formattedValue = typeof value === 'object' && value !== null
      ? formatObject(value, indent + 1)
      : formatValue(value);
    return `${innerSpaces}${formattedKey}: ${formattedValue},`;
  });

  return `{\n${lines.join('\n')}\n${spaces}}`;
}

/**
 * Format a primitive value for JavaScript
 */
function formatValue(value: any): string {
  if (typeof value === 'string') {
    return `'${value.replace(/'/g, "\\'")}'`;
  }
  if (typeof value === 'number') {
    return String(value);
  }
  if (typeof value === 'boolean') {
    return String(value);
  }
  if (value === null) {
    return 'null';
  }
  return String(value);
}

/**
 * Check if a string is a valid JavaScript identifier
 */
function isValidIdentifier(str: string): boolean {
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(str);
}
