/**
 * SCSS Generator
 * 
 * Generates SCSS files with $variables from design tokens.
 * Optionally generates SCSS maps for programmatic access.
 */

import { ParsedToken } from '../docs/index.js';
import { transformForCSS, CSSTransformOptions } from '../transforms/index.js';

export interface SCSSGeneratorOptions extends CSSTransformOptions {
  /** Generate SCSS maps in addition to variables */
  maps?: boolean;
  /** Prefix for variable names (default: none) */
  prefix?: string;
}

/**
 * Generate SCSS variables from tokens
 */
export function generateSCSS(
  tokens: ParsedToken[],
  modes: string[],
  options: SCSSGeneratorOptions = {}
): string {
  const { maps = false, prefix = '' } = options;
  
  const lines: string[] = [
    '// =============================================================================',
    '// Design Tokens - SCSS Variables',
    '// Generated by Synkio',
    '// https://github.com/rgehrkedk/synkio',
    '// =============================================================================',
    '',
  ];

  // Group tokens by mode
  const tokensByMode = new Map<string, ParsedToken[]>();
  for (const token of tokens) {
    if (!tokensByMode.has(token.mode)) {
      tokensByMode.set(token.mode, []);
    }
    tokensByMode.get(token.mode)!.push(token);
  }

  // Generate variables for default mode
  const defaultMode = modes[0] || 'default';
  const defaultTokens = tokensByMode.get(defaultMode) || [];
  
  lines.push('// -----------------------------------------------------------------------------');
  lines.push('// Variables');
  lines.push('// -----------------------------------------------------------------------------');
  lines.push('');

  for (const token of defaultTokens) {
    const varName = formatSCSSVariableName(token.path, prefix);
    const value = formatValue(token.value, token.type, token.path, options);
    const comment = token.description ? ` // ${token.description}` : '';
    lines.push(`${varName}: ${value};${comment}`);
  }
  lines.push('');

  // Generate mode-specific variables with suffix
  for (const [mode, modeTokens] of tokensByMode) {
    if (mode === defaultMode) continue;
    
    lines.push(`// ${mode} mode`);
    for (const token of modeTokens) {
      const varName = formatSCSSVariableName(token.path, prefix, mode);
      const value = formatValue(token.value, token.type, token.path, options);
      lines.push(`${varName}: ${value};`);
    }
    lines.push('');
  }

  // Generate maps if enabled
  if (maps) {
    lines.push('// -----------------------------------------------------------------------------');
    lines.push('// Maps');
    lines.push('// -----------------------------------------------------------------------------');
    lines.push('');
    
    const mapContent = generateSCSSMaps(defaultTokens, prefix, options);
    lines.push(mapContent);
  }

  return lines.join('\n');
}

/**
 * Generate SCSS maps grouped by top-level category
 */
function generateSCSSMaps(
  tokens: ParsedToken[],
  prefix: string,
  options: SCSSGeneratorOptions
): string {
  const lines: string[] = [];
  
  // Group tokens by top-level category
  const categories = new Map<string, ParsedToken[]>();
  for (const token of tokens) {
    const parts = token.path.split('.');
    const category = parts[0];
    if (!categories.has(category)) {
      categories.set(category, []);
    }
    categories.get(category)!.push(token);
  }
  
  // Generate a map for each category
  for (const [category, categoryTokens] of categories) {
    const mapName = prefix ? `$${prefix}-${category}` : `$${category}`;
    lines.push(`${mapName}: (`);
    
    for (let i = 0; i < categoryTokens.length; i++) {
      const token = categoryTokens[i];
      // Use path without top-level category as key
      const parts = token.path.split('.');
      const key = parts.slice(1).join('-') || parts[0];
      const value = formatValue(token.value, token.type, token.path, options);
      const comma = i < categoryTokens.length - 1 ? ',' : '';
      lines.push(`  '${key}': ${value}${comma}`);
    }
    
    lines.push(');');
    lines.push('');
  }
  
  return lines.join('\n');
}

/**
 * Format a SCSS variable name from a token path
 */
function formatSCSSVariableName(path: string, prefix: string = '', modeSuffix?: string): string {
  let name = path.replace(/\./g, '-').toLowerCase();
  
  if (prefix) {
    name = `${prefix}-${name}`;
  }
  
  if (modeSuffix) {
    name = `${name}--${modeSuffix}`;
  }
  
  return `$${name}`;
}

/**
 * Format a value for SCSS output
 */
function formatValue(
  value: any,
  type: string,
  path: string,
  options: SCSSGeneratorOptions
): string {
  if (value === null || value === undefined) {
    return 'null';
  }
  
  return transformForCSS({ value, type, path }, options);
}

/**
 * Generate SCSS with CSS custom properties fallback
 * This creates SCSS that uses CSS variables with SCSS variable fallbacks
 */
export function generateSCSSWithCSSVars(
  tokens: ParsedToken[],
  modes: string[],
  options: SCSSGeneratorOptions = {}
): string {
  const { prefix = '' } = options;
  
  const lines: string[] = [
    '// =============================================================================',
    '// Design Tokens - SCSS with CSS Custom Properties',
    '// Generated by Synkio',
    '// =============================================================================',
    '',
    '// Use these mixins to apply tokens with CSS variable support',
    '',
  ];

  // Group tokens by mode
  const tokensByMode = new Map<string, ParsedToken[]>();
  for (const token of tokens) {
    if (!tokensByMode.has(token.mode)) {
      tokensByMode.set(token.mode, []);
    }
    tokensByMode.get(token.mode)!.push(token);
  }

  const defaultMode = modes[0] || 'default';
  const defaultTokens = tokensByMode.get(defaultMode) || [];

  // Generate SCSS variables
  lines.push('// SCSS Variables (static values)');
  for (const token of defaultTokens) {
    const varName = formatSCSSVariableName(token.path, prefix);
    const value = formatValue(token.value, token.type, token.path, options);
    lines.push(`${varName}: ${value};`);
  }
  lines.push('');

  // Generate CSS custom property mixin
  lines.push('// CSS Custom Properties (for runtime theming)');
  lines.push('@mixin token-vars {');
  for (const token of defaultTokens) {
    const cssVar = token.cssVariable;
    const scssVar = formatSCSSVariableName(token.path, prefix);
    lines.push(`  ${cssVar}: #{${scssVar}};`);
  }
  lines.push('}');
  lines.push('');

  // Generate mode mixins
  for (const [mode, modeTokens] of tokensByMode) {
    if (mode === defaultMode) continue;
    
    lines.push(`@mixin token-vars--${mode} {`);
    for (const token of modeTokens) {
      const cssVar = token.cssVariable;
      const value = formatValue(token.value, token.type, token.path, options);
      lines.push(`  ${cssVar}: ${value};`);
    }
    lines.push('}');
    lines.push('');
  }

  return lines.join('\n');
}
