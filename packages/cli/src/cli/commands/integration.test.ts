/**
 * Integration tests for init + sync workflow
 *
 * These tests verify the end-to-end integration between:
 * - init command (generates config)
 * - sync command (reads config)
 *
 * Focus areas:
 * - Config generated by init is valid for sync to read
 * - Style Dictionary detection flows through correctly
 * - Old config format fails gracefully with clear error
 * - First sync collection discovery persists for subsequent syncs
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { writeFileSync, mkdirSync, rmSync, readFileSync, existsSync } from 'fs';
import { resolve } from 'path';

// Store original cwd
const originalCwd = process.cwd();
const TEST_DIR = resolve(originalCwd, 'test-temp-integration');

describe('Init + Sync Integration', () => {
  beforeEach(() => {
    // Create a temporary directory for our test files
    mkdirSync(TEST_DIR, { recursive: true });
    process.chdir(TEST_DIR);
    // Clear environment
    delete process.env.FIGMA_TOKEN;
    // Reset module cache to ensure clean state
    vi.resetModules();
  });

  afterEach(() => {
    // Go back to the original directory
    process.chdir(originalCwd);
    // Clean up the temporary directory
    rmSync(TEST_DIR, { recursive: true, force: true });
    // Clear any environment variables we set
    delete process.env.FIGMA_TOKEN;
    // Reset all mocks
    vi.resetAllMocks();
    vi.resetModules();
  });

  describe('Config generation and reading', () => {
    it('config generated by init is valid for sync to read', async () => {
      // Create package.json
      writeFileSync('package.json', JSON.stringify({
        name: 'test-project',
        dependencies: {}
      }));

      // Generate config using init's generateConfig
      const { generateConfig } = await import('./init.js');
      const config = await generateConfig('ABC123');

      // Write config to file
      writeFileSync('synkio.config.json', JSON.stringify(config, null, 2));

      // Set FIGMA_TOKEN for loadConfig
      process.env.FIGMA_TOKEN = 'test-token';

      // Load config using sync's loadConfig
      const { loadConfig } = await import('../../core/config.js');
      const loadedConfig = loadConfig();

      // Verify config loaded correctly
      expect(loadedConfig.figma.fileId).toBe('ABC123');
      expect(loadedConfig.figma.accessToken).toBe('test-token');
      expect(loadedConfig.tokens.dir).toBeDefined();
      expect(loadedConfig.docsPages?.enabled).toBe(true);
    });

    it('init with SD detection generates config that sync recognizes as SD mode', async () => {
      // Create package.json with style-dictionary
      writeFileSync('package.json', JSON.stringify({
        name: 'test-project',
        dependencies: {
          'style-dictionary': '^5.0.0'
        }
      }));

      // Create SD config file
      writeFileSync('sd.config.js', `
module.exports = {
  source: ['src/tokens/**/*.json'],
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'dist/',
      files: [{ destination: 'tokens.css', format: 'css/variables' }]
    }
  }
};
`);

      // Generate config
      const { generateConfig } = await import('./init.js');
      const config = await generateConfig('ABC123');

      // Write config to file
      writeFileSync('synkio.config.json', JSON.stringify(config, null, 2));

      // Set FIGMA_TOKEN for loadConfig
      process.env.FIGMA_TOKEN = 'test-token';

      // Load config
      const { loadConfig } = await import('../../core/config.js');
      const loadedConfig = loadConfig();

      // Verify SD mode is detected
      const isSDMode = !!loadedConfig.build?.styleDictionary?.configFile;
      expect(isSDMode).toBe(true);
      expect(loadedConfig.build?.styleDictionary?.configFile).toBe('sd.config.js');

      // Verify tokens.dir was derived from SD source pattern
      expect(loadedConfig.tokens.dir).toBe('src/tokens');

      // Verify CSS build is NOT enabled when SD is detected
      expect(loadedConfig.build?.css).toBeUndefined();
    });

    it('init without SD generates config with CSS enabled for sync', async () => {
      // Create package.json without style-dictionary
      writeFileSync('package.json', JSON.stringify({
        name: 'test-project',
        dependencies: {
          'react': '^18.0.0'
        }
      }));

      // Generate config
      const { generateConfig } = await import('./init.js');
      const config = await generateConfig('ABC123');

      // Write config to file
      writeFileSync('synkio.config.json', JSON.stringify(config, null, 2));

      // Set FIGMA_TOKEN for loadConfig
      process.env.FIGMA_TOKEN = 'test-token';

      // Load config
      const { loadConfig } = await import('../../core/config.js');
      const loadedConfig = loadConfig();

      // Verify SD mode is NOT enabled
      const isSDMode = !!loadedConfig.build?.styleDictionary?.configFile;
      expect(isSDMode).toBe(false);

      // Verify CSS build IS enabled
      expect(loadedConfig.build?.css?.enabled).toBe(true);
      expect(loadedConfig.build?.css?.file).toBe('tokens.css');
      expect(loadedConfig.build?.css?.utilities).toBe(true);
    });
  });

  describe('Old config format handling', () => {
    it('sync with old config format fails with clear error message', async () => {
      // Create package.json
      writeFileSync('package.json', JSON.stringify({
        name: 'test-project'
      }));

      // Write old-format config (using deprecated keys)
      const oldConfig = {
        version: '1.0.0',
        figma: {
          fileId: 'ABC123',
          accessToken: 'test-token'
        },
        // Old format used 'output' instead of 'tokens'
        output: {
          dir: 'tokens',
          mode: 'json'
        },
        // Old format used 'css' at root level
        css: {
          enabled: true
        },
        // Old format used 'docs' instead of 'docsPages'
        docs: {
          enabled: true
        }
      };
      writeFileSync('synkio.config.json', JSON.stringify(oldConfig, null, 2));

      // Attempt to load config
      const { loadConfig, ConfigSchema } = await import('../../core/config.js');

      // Verify schema rejects old format
      const result = ConfigSchema.safeParse(oldConfig);
      expect(result.success).toBe(false);

      // Verify error mentions unrecognized keys
      if (!result.success) {
        const errorMessage = JSON.stringify(result.error.issues);
        expect(errorMessage).toContain('unrecognized_keys');
      }

      // Verify loadConfig throws
      expect(() => loadConfig()).toThrow();
    });

    it('provides helpful error message for missing tokens.dir', async () => {
      // Create package.json
      writeFileSync('package.json', JSON.stringify({
        name: 'test-project'
      }));

      // Write config missing required tokens.dir
      const configMissingDir = {
        version: '1.0.0',
        figma: {
          fileId: 'ABC123',
          accessToken: 'test-token'
        },
        tokens: {
          // dir is missing (required)
        }
      };
      writeFileSync('synkio.config.json', JSON.stringify(configMissingDir, null, 2));

      const { ConfigSchema } = await import('../../core/config.js');

      const result = ConfigSchema.safeParse(configMissingDir);
      expect(result.success).toBe(false);

      if (!result.success) {
        const messages = result.error.issues.map(i => `${i.path.join('.')}: ${i.message}`);
        expect(messages.some(m => m.includes('tokens.dir'))).toBe(true);
      }
    });
  });

  describe('Collection discovery persistence', () => {
    it('discovered collections are written to config and persist', async () => {
      // Create package.json
      writeFileSync('package.json', JSON.stringify({
        name: 'test-project'
      }));

      // Create initial config WITHOUT collections
      const initialConfig = {
        version: '1.0.0',
        figma: {
          fileId: 'ABC123',
          accessToken: 'test-token'
        },
        tokens: {
          dir: 'src/tokens'
        }
      };
      writeFileSync('synkio.config.json', JSON.stringify(initialConfig, null, 2));

      // Import updateConfigWithCollections
      const { updateConfigWithCollections, loadConfig } = await import('../../core/config.js');

      // Simulate discovered collections from first sync
      const discoveredCollections = [
        { name: 'primitives', modes: ['default'], splitModes: false },
        { name: 'semantic', modes: ['light', 'dark'], splitModes: true },
        { name: 'component', modes: ['default'], splitModes: false },
      ];

      // Update config with discovered collections
      const result = updateConfigWithCollections(discoveredCollections);
      expect(result.updated).toBe(true);

      // Read config file directly to verify it was written
      const configContent = readFileSync('synkio.config.json', 'utf-8');
      const parsedConfig = JSON.parse(configContent);

      expect(parsedConfig.tokens.collections).toBeDefined();
      expect(parsedConfig.tokens.collections.primitives.splitModes).toBe(false);
      expect(parsedConfig.tokens.collections.semantic.splitModes).toBe(true);
      expect(parsedConfig.tokens.collections.component.splitModes).toBe(false);

      // Verify original config values preserved
      expect(parsedConfig.tokens.dir).toBe('src/tokens');
    });

    it('subsequent config updates merge with existing collections', async () => {
      // Create package.json
      writeFileSync('package.json', JSON.stringify({
        name: 'test-project'
      }));

      // Create config WITH existing collections
      const existingConfig = {
        version: '1.0.0',
        figma: {
          fileId: 'ABC123',
          accessToken: 'test-token'
        },
        tokens: {
          dir: 'src/tokens',
          collections: {
            existing: {
              splitModes: true,
              dir: 'custom/path'
            }
          }
        }
      };
      writeFileSync('synkio.config.json', JSON.stringify(existingConfig, null, 2));

      const { updateConfigWithCollections } = await import('../../core/config.js');

      // Add new collections (simulating new collection discovered in Figma)
      const newCollections = [
        { name: 'newCollection', modes: ['default'], splitModes: false },
      ];

      updateConfigWithCollections(newCollections);

      // Read and verify
      const configContent = readFileSync('synkio.config.json', 'utf-8');
      const parsedConfig = JSON.parse(configContent);

      // Original collection preserved with custom config
      expect(parsedConfig.tokens.collections.existing.splitModes).toBe(true);
      expect(parsedConfig.tokens.collections.existing.dir).toBe('custom/path');

      // New collection added
      expect(parsedConfig.tokens.collections.newCollection.splitModes).toBe(false);
    });
  });

  describe('End-to-end workflow', () => {
    it('complete init -> sync flow works with detected SD config', async () => {
      // Setup: Create package.json with style-dictionary
      writeFileSync('package.json', JSON.stringify({
        name: 'test-project',
        dependencies: { 'style-dictionary': '^5.0.0' }
      }));

      // Setup: Create SD config
      writeFileSync('sd.config.js', `
module.exports = {
  source: ['design-tokens/**/*.json'],
  platforms: {
    web: {
      transformGroup: 'css',
      buildPath: 'build/',
      files: [{ destination: 'variables.css', format: 'css/variables' }]
    }
  }
};
`);

      // Step 1: Generate config (init phase)
      const { generateConfig } = await import('./init.js');
      const config = await generateConfig('FILE123');
      writeFileSync('synkio.config.json', JSON.stringify(config, null, 2));

      // Step 2: Set token and load config (sync phase)
      process.env.FIGMA_TOKEN = 'test-token';
      const { loadConfig } = await import('../../core/config.js');
      const loadedConfig = loadConfig();

      // Verify complete workflow
      expect(loadedConfig.figma.fileId).toBe('FILE123');
      expect(loadedConfig.tokens.dir).toBe('design-tokens'); // Derived from SD source
      expect(loadedConfig.build?.styleDictionary?.configFile).toBe('sd.config.js');
      expect(loadedConfig.docsPages?.enabled).toBe(true);
      expect(loadedConfig.docsPages?.dir).toBe('.synkio/docs');
    });
  });
});
